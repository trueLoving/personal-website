{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/image/avatar.jpeg","path":"image/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1683962339914},{"_id":"source/collection/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1683993069815},{"_id":"source/online/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1683993145535},{"_id":"source/bangumi/index.md","hash":"2e41efb9e208b43e048a41fdab070dec1d5f54f2","modified":1683934090999},{"_id":"source/comment/index.md","hash":"624c1baec8f5d4653b1b6a0935b0c2d670a0ffbd","modified":1683934091000},{"_id":"source/category/index.md","hash":"d1315415cf6e5d1b88d5f9745e998ab823897244","modified":1684157261149},{"_id":"source/links/index.md","hash":"b11d2779560bfb91541a582e7aa8a2f85878730b","modified":1683934091000},{"_id":"source/docs/index.md","hash":"f175f3b93da2a3f7c4a8ee705ec142775a7a8fe2","modified":1683934091000},{"_id":"source/music/index.md","hash":"84ad4e95d000fa7889dd307122b76cb4863eeb77","modified":1683934091000},{"_id":"source/paint/index.md","hash":"3ef69c5dcf586e80dfa60e0afa1ca0d4f6cdcf1d","modified":1683934091001},{"_id":"source/_posts/笔记/类数组转换为数组方法.md","hash":"be7e590ec95e212b98c9c83b33aded53ff468d68","modified":1683934090999},{"_id":"source/_posts/前端/网络基础 tcp的三次握手和四次挥手.md","hash":"9e4f0cb0cd1a6cb70fe170675cba92468d5a6884","modified":1683934090997},{"_id":"source/_posts/笔记/Flutter Widgets生命周期.md","hash":"889002d4ad7d9bce87ad41edac882e39bbab4f7d","modified":1683934090998},{"_id":"source/_posts/笔记/XHR的基本认识.md","hash":"f40da33be9662d698f41bc98d976336bf1070a11","modified":1683934090998},{"_id":"source/_posts/笔记/Virtual DOM.md","hash":"21470358a612752cff760b0a1eeb007a4f3ca3b6","modified":1683934090998},{"_id":"source/tags/index.md","hash":"2270373fa5826e1322acfa5252fdeb0e219a37a0","modified":1684157210995},{"_id":"source/_posts/数学/极限.md","hash":"4592e4a102b35c6d5859af7d64fa336224609baf","modified":1683934090998},{"_id":"source/_posts/笔记/bind&apply&call方法实现.md","hash":"2b4f7fd487015e0b5b03001438b67e4c27ce77ce","modified":1683934090998},{"_id":"source/_posts/算法/常见排序算法.md","hash":"93838f77df8b48c72d78366bb3ec0f4eb08529c5","modified":1683934090999},{"_id":"source/_posts/前端/ES6/Generator对象和Generator函数.md","hash":"45237676abeb278f5eb8e7844dbabe7cdf0aabfc","modified":1683934090992},{"_id":"source/_posts/前端/ES6/Promise对象.md","hash":"fc7130dc327b33062d352740e8d90681ef0cc60a","modified":1683934090993},{"_id":"source/_posts/前端/ES6/Promise认识.md","hash":"b1aa3d8a44cd1d0573e616c31274eeb183e05593","modified":1683934090993},{"_id":"source/_posts/前端/ES6/Proxy对象.md","hash":"d7760e2166ecdd96511e3264711bff6044f94527","modified":1683934090993},{"_id":"source/_posts/前端/ES6/Symbol对象.md","hash":"b8265b7feb560ea3e18a3d1555d923932800c59d","modified":1683934090993},{"_id":"source/_posts/前端/ES6/Reflect对象.md","hash":"1ddd73b27d3956cfdde1161e0548c0a8857d5449","modified":1683934090993},{"_id":"source/_posts/前端/ES6/自定义深拷贝.md","hash":"39f1a49855be8279e517b2ae4fbe799528dabcd6","modified":1683934090993},{"_id":"source/_posts/前端/ES总结/ES.md","hash":"6a5352b9b28bcaf6df7bb93e35bd202f39ae0c20","modified":1683934090994},{"_id":"source/_posts/前端/vue/vue2 computed&watch.md","hash":"59dc2baa415361c93715612bb4d4818e4fc67d3e","modified":1683934090995},{"_id":"source/_posts/前端/ES总结/ES6 语法总结 03.md","hash":"438804e9527c5012b7bdb559464d2520ccca74c4","modified":1683934090994},{"_id":"source/_posts/前端/ES总结/ES6 语法总结 02.md","hash":"589302ecc87870c1d165b297ea2ebf2f630289a2","modified":1683934090994},{"_id":"source/_posts/前端/ES总结/ES6 语法总结 01.md","hash":"1552ebdb581540415a4c2efd82c8de015fefa495","modified":1683934090994},{"_id":"source/_posts/前端/vue/vue2 vuex.md","hash":"33334b2d51db78ca5c206b9be88cccd6848653a5","modified":1683934090996},{"_id":"source/_posts/前端/vue/vue2的基本认识和使用.md","hash":"5b82713129084f01da7550f2865cdb74b6e83edb","modified":1683934090996},{"_id":"source/_posts/前端/vue/vue2组件.md","hash":"7beed96a71e751b8e2d14182e9c3ae4695e9e940","modified":1683934090996},{"_id":"source/_posts/前端/vue/vue2 v-slot.md","hash":"907438b9bc9ef37a3c6f21ed04f65882a3cbfbb0","modified":1683934090996},{"_id":"source/_posts/前端/vue/vue3的基本认识和使用.md","hash":"4a72759f826602fb28e7afbe728da05fda0164e0","modified":1683934090996},{"_id":"source/_posts/前端/Webpack/01 基本认识.md","hash":"e59b22e84303ad35fb40981655eea872c62658ec","modified":1683934090994},{"_id":"source/_posts/前端/Webpack/02 开发配置.md","hash":"08cdf8f990aaadf0dae5f7389817d154fb115fa7","modified":1683934090994},{"_id":"source/_posts/前端/Webpack/04 优化配置.md","hash":"7295b0379d457bb91c1b128b30ed8b93999d2bcf","modified":1683934090995},{"_id":"source/_posts/前端/Webpack/05 配置详解.md","hash":"239511ee618f3ef5dd4db185a683446e949578ef","modified":1683934090995},{"_id":"source/_posts/前端/Webpack/03 生产配置.md","hash":"8b047017feaf4ae3018ebb48c0fe98496bb96dc3","modified":1683934090995},{"_id":"source/_posts/前端/Webpack/06 webpack5.md","hash":"24aeb5cbe9f11c8ae7b1363668c7f83d0599caf3","modified":1683934090995},{"_id":"source/_posts/前端/设计模式/代理模式.md","hash":"9d933488809bb277cde2f87f79182a8487de5d66","modified":1683934090997},{"_id":"source/_posts/前端/设计模式/单例模式.md","hash":"f4f073fc6c4e9f6b54af9d19609183508c05d08c","modified":1683934090997},{"_id":"themes/Chic/_config.yml","hash":"6219cbc1da8b91d0f04151a290cd2cfc68572b56","modified":1684157682273},{"_id":"themes/Chic/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1683934091002},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1683934091001},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1683934091002},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1683934091002},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1683934091002},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1683934091003},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1683934091002},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1683934091003},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1683934091003},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1683934091002},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1683934091003},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1683934091003},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1683934091007},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1683934091006},{"_id":"themes/Chic/layout/page.ejs","hash":"3179c527694a789760742e1923c7ac5f94b4997c","modified":1683934091007},{"_id":"themes/Chic/layout/layout.ejs","hash":"03722fbf842e2b1926a8f3c50853cb17689e184d","modified":1684157761247},{"_id":"themes/Chic/layout/post.ejs","hash":"a23f83d6c559ce88588472267468a54488d50e8e","modified":1683934091007},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1683934091008},{"_id":"themes/Chic/layout/header.ejs","hash":"c8456bb9a702c7a22dc30fd33c9731a7e7c48309","modified":1684563444527},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1684155575438},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1683934091004},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1683934091004},{"_id":"themes/Chic/layout/tag.ejs","hash":"d85ca78392be138b1589499cba95186b20c3a902","modified":1683934091008},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1683934091004},{"_id":"themes/Chic/source/favicon.ico","hash":"124582ab19fd5de72b6f96f1faaeef3fe5e6926e","modified":1684156805342},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1683934091004},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1683934091005},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"60eec7b1f98b4485a17ee42bb10daedc80757efe","modified":1684155987045},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"e1c332fab0d6cd713e36d46ccc14d0991067ba40","modified":1683934091005},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"f49991a55cc08a1d90d8d6ae8d15a692163272e1","modified":1683996076609},{"_id":"themes/Chic/layout/_plugins/search.ejs","hash":"672621602d24e113f6faf387665437a95fb9c1ea","modified":1684159326276},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"c8456bb9a702c7a22dc30fd33c9731a7e7c48309","modified":1684562669850},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1683934091006},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"c47e8a5047ce0016f74b76028878d386af78bb7c","modified":1683934091006},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"4fe53c8ac9fe95dba888480790f7edea33fe579e","modified":1684155832243},{"_id":"themes/Chic/source/css/base.styl","hash":"72aef06d738853f13f1697b091002d6d776bd56d","modified":1683934091027},{"_id":"themes/Chic/source/css/layout.styl","hash":"4d9f83b5a3bac81e7857358744858fae708320de","modified":1683934091027},{"_id":"themes/Chic/source/css/custom.styl","hash":"bf8dee1a094b104d87a53b43f6daa7ba43b67574","modified":1683934091027},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1683934091028},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1683934091027},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1683934091028},{"_id":"themes/Chic/source/css/style.styl","hash":"a13f2c38070a89b06a2ede599f5ce5fd160e11c9","modified":1683934091028},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1683934091028},{"_id":"themes/Chic/source/image/avatar.jpeg","hash":"5d46dc78e55390dfab0149798249bf655dd03fca","modified":1683934091124},{"_id":"themes/Chic/source/js/script.js","hash":"5dd8ce4fa55a7201d7e2ffe417b48c95943a906b","modified":1683934091125},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1683934091124},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1683934091125},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1683934091009},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1683934091024},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1683934091009},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1683934091024},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1683934091009},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1683934091010},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1683934091009},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1683934091010},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1683934091010},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1683934091010},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1683934091011},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1683934091011},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1683934091011},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1683934091012},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1683934091012},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1683934091011},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1683934091012},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1683934091012},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1683934091013},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1683934091012},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1683934091013},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1683934091013},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1683934091013},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1683934091013},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1683934091014},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1683934091014},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1683934091014},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1683934091014},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1683934091015},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1683934091015},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1683934091015},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1683934091015},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1683934091016},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1683934091016},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1683934091016},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1683934091016},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1683934091016},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1683934091017},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1683934091018},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1683934091018},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1683934091018},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1683934091018},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1683934091018},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1683934091019},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1683934091019},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1683934091019},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1683934091019},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1683934091019},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1683934091020},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1683934091020},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1683934091020},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1683934091020},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1683934091020},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1683934091021},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1683934091021},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1683934091021},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1683934091021},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1683934091021},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1683934091022},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1683934091023},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1683934091023},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1683934091023},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1683934091023},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1683934091023},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1683934091024},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1683934091027},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1683934091027},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1683934091027},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1683934091026},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1683934091026},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1683934091026},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"057097e714284e72e97ab8a808a30df45555a342","modified":1683934091026},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1683934091027},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1683934091029},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1683934091029},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1683934091029},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1683934091029},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1683934091030},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1683934091030},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1683934091030},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1683934091031},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1683934091031},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1683934091030},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1683934091025},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1683934091025},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1683934091025},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1683934091025},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1683934091026},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1683934091025},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1683934091026},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1683934091123},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1683934091119},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1683934091077},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1683934091054},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1683934091115}],"Category":[{"name":"前端","_id":"clhws1t2d00042h17789m4pyc"},{"name":"笔记","_id":"clhws1t2i000c2h17gwika0pw"},{"name":"数学","_id":"clhws1t2s00182h172ct07ajt"},{"name":"算法","_id":"clhws1t2u001g2h172xghh3n3"}],"Data":[],"Page":[{"title":"'category'","date":"2019-06-09T01:56:49.000Z","layout":"category","_content":"","source":"category/index.md","raw":"---\n    title: '''category'''\n    date: 2019-06-09 09:56:49\n    layout: category\n---","updated":"2023-05-15T13:27:41.149Z","path":"category/index.html","comments":1,"_id":"clhws1t2400002h1725nc19bi","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"about/index.md","raw":"","date":"2023-05-13T07:18:59.914Z","updated":"2023-05-13T07:18:59.914Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clhws1t2a00022h17e6x57cnz","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"bangumi","title":"bangumi","comments":0,"date":"2019-02-10T13:32:48.000Z","keywords":null,"description":null,"bangumis":[{"img":"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg","title":"朝花夕誓——于离别之朝束起约定之花","status":"已追完","progress":100,"jp":"さよならの朝に約束の花をかざろう","time":"2018-02-24 SUN.","desc":"住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。"},{"img":"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=336712630,1386620623&fm=26&gp=0.jpg","title":"辉夜大小姐想让我告白 ~天才们的恋爱头脑战~","status":"已追完","progress":100,"jp":"かぐや様は告らせたい～天才たちの恋愛頭脳戦～","time":"2015-05-19(2015年6月号/ミラクルジャンプ)","desc":"先告白的人在恋爱当中是输家。”家庭背景与人品都很棒，一大群有前途的秀才所聚集的秀知院学园。在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引，但想不到都过半年了却仍然什么事情也没发生。最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”？直到恋情明朗之前都会很欢乐的故事，充满新鲜感的“斗智”爱情喜剧，就此开战。"},{"img":"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=336712630,1386620623&fm=26&gp=0.jpg","title":"辉夜大小姐想让我告白 ~天才们的恋爱头脑战~","status":"已追完","progress":100,"jp":"かぐや様は告らせたい～天才たちの恋愛頭脳戦～","time":"2015-05-19(2015年6月号/ミラクルジャンプ)","desc":"先告白的人在恋爱当中是输家。”家庭背景与人品都很棒，一大群有前途的秀才所聚集的秀知院学园。在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引，但想不到都过半年了却仍然什么事情也没发生。最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”？直到恋情明朗之前都会很欢乐的故事，充满新鲜感的“斗智”爱情喜剧，就此开战。"}],"_content":"","source":"bangumi/index.md","raw":"---\nlayout: bangumi\ntitle: bangumi\ncomments: false\ndate: 2019-02-10 21:32:48\nkeywords:\ndescription:\nbangumis:\n  - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\n    title: 朝花夕誓——于离别之朝束起约定之花\n    status: 已追完\n    progress: 100\n    jp: さよならの朝に約束の花をかざろう\n    time: 2018-02-24 SUN.\n    desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\n  - img: https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=336712630,1386620623&fm=26&gp=0.jpg\n    title: 辉夜大小姐想让我告白 ~天才们的恋爱头脑战~\n    status: 已追完\n    progress: 100\n    jp: かぐや様は告らせたい～天才たちの恋愛頭脳戦～\n    time: 2015-05-19(2015年6月号/ミラクルジャンプ)\n    desc: 先告白的人在恋爱当中是输家。”家庭背景与人品都很棒，一大群有前途的秀才所聚集的秀知院学园。在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引，但想不到都过半年了却仍然什么事情也没发生。最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”？直到恋情明朗之前都会很欢乐的故事，充满新鲜感的“斗智”爱情喜剧，就此开战。\n  - img: https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=336712630,1386620623&fm=26&gp=0.jpg\n    title: 辉夜大小姐想让我告白 ~天才们的恋爱头脑战~\n    status: 已追完\n    progress: 100\n    jp: かぐや様は告らせたい～天才たちの恋愛頭脳戦～\n    time: 2015-05-19(2015年6月号/ミラクルジャンプ)\n    desc: 先告白的人在恋爱当中是输家。”家庭背景与人品都很棒，一大群有前途的秀才所聚集的秀知院学园。在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引，但想不到都过半年了却仍然什么事情也没发生。最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”？直到恋情明朗之前都会很欢乐的故事，充满新鲜感的“斗智”爱情喜剧，就此开战。\n  \n---\n","updated":"2023-05-12T23:28:10.999Z","path":"bangumi/index.html","_id":"clhws1t2e00062h172p6v53lj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","keywords":"留言板","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg","_content":"{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","source":"comment/index.md","raw":"---\ntitle: comment\ndate: 2018-12-20 23:13:48\nkeywords: 留言板\ndescription: \ncomments: false\nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg\n---\n{% raw %}\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n{% endraw %}","updated":"2023-05-12T23:28:11.000Z","path":"comment/index.html","layout":"page","_id":"clhws1t2g00082h1747vtdmxd","content":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n","site":{"data":{}},"excerpt":"","more":"\n<div class=\"entry-content\">\n  <div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\">\n    </div>\n    <div class=\"poem-border poem-right\">\n    </div>\n    <h1>\n    念两句诗</h1>\n    <p id=\"poem\">\n    叙别梦、扬州一觉。</p>\n    <p id=\"info\">\n    【宋代】吴文英《夜游宫·人去西楼雁杳》</p>\n  </div>\n</div>\n"},{"_content":"","source":"collection/index.md","raw":"","date":"2023-05-13T15:51:09.815Z","updated":"2023-05-13T15:51:09.815Z","path":"collection/index.html","title":"","comments":1,"layout":"page","_id":"clhws1t2h000a2h17fxo03fao","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"docs","title":"文档 链接","date":"2018-12-20T15:13:48.000Z","keywords":"文档","description":null,"comments":0,"photos":"https://gitee.com/trueLoving/cdn/raw/master/img/docs_bg.jpg","links":[{"group":"前端","desc":"一入前端深似海，花里胡哨整不休 V ( ^_^ ) V","items":[{"url":"https://cn.vuejs.org/","img":"https://cn.vuejs.org/images/logo.png","name":"vue","desc":"一款渐进式的 JavaScript 框架"},{"url":"https://vuex.vuejs.org/zh/","img":"https://cn.vuejs.org/images/logo.png","name":"Vuex","desc":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式"},{"url":"https://router.vuejs.org/zh/","img":"https://cn.vuejs.org/images/logo.png","name":"Vue Router","desc":"Vue Router 是 Vue.js 官方的路由管理器"}]},{"group":"后端","desc":"一入后端深似海，算法容器伴一生 V ( ^_^ ) V","items":[{"url":"https://spring.io/projects/spring-boot","img":"https://spring.io/images/spring-logo-9146a4d3298760c2e7e49595184e1975.svg","name":"springboot","desc":"Spring 框架是 Java 平台上的一种开源应用框架，提供具有控制反转特性的容器"},{"url":"https://mybatis.org/mybatis-3/zh/index.html","img":"https://mybatis.org/images/mybatis-logo.png","name":"MyBatis","desc":"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射"},{"url":"https://shiro.apache.org/","img":"https://shiro.apache.org/assets/images/apache-shiro-logo.png","name":"Shiro","desc":"Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management"}]}],"_content":"","source":"docs/index.md","raw":"---\nlayout: docs\ntitle: 文档 链接\ndate: 2018-12-20 23:13:48\nkeywords: 文档\ndescription: \ncomments: false\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/docs_bg.jpg\nlinks:\n  - group: 前端\n    desc: 一入前端深似海，花里胡哨整不休 V ( ^_^ ) V\n    items:\n    - url: https://cn.vuejs.org/\n      img: https://cn.vuejs.org/images/logo.png\n      name: vue\n      desc: 一款渐进式的 JavaScript 框架\n    - url: https://vuex.vuejs.org/zh/\n      img: https://cn.vuejs.org/images/logo.png\n      name: Vuex\n      desc: Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式\n    - url: https://router.vuejs.org/zh/\n      img: https://cn.vuejs.org/images/logo.png\n      name: Vue Router\n      desc: Vue Router 是 Vue.js 官方的路由管理器\n  - group: 后端\n    desc: 一入后端深似海，算法容器伴一生 V ( ^_^ ) V\n    items:\n    - url: https://spring.io/projects/spring-boot\n      img: https://spring.io/images/spring-logo-9146a4d3298760c2e7e49595184e1975.svg\n      name: springboot\n      desc: Spring 框架是 Java 平台上的一种开源应用框架，提供具有控制反转特性的容器\n    - url: https://mybatis.org/mybatis-3/zh/index.html\n      img: https://mybatis.org/images/mybatis-logo.png\n      name: MyBatis\n      desc: MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射\n    - url: https://shiro.apache.org/\n      img: https://shiro.apache.org/assets/images/apache-shiro-logo.png\n      name: Shiro\n      desc: Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management\n---\n","updated":"2023-05-12T23:28:11.000Z","path":"docs/index.html","_id":"clhws1t2j000f2h17ec1gf60z","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"links","title":"links","date":"2018-12-19T15:11:06.000Z","keywords":"友人帐","description":null,"comments":0,"photos":"https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg","links":[{"group":"小伙伴们","items":[{"url":"https://www.liuxinc.ink/","img":"https://www.liuxinc.ink/images/avatar.jpg","name":"卫星@kqzh","desc":"a golang coder"},{"url":"http://ninging.top/","img":"http://ninging.top/avatar.jpg","name":"rookie30","desc":"어떤 문제 든 반드시 답 이 있다"},{"url":"https://toruneveryday.gitee.io/","img":"https://toruneveryday.gitee.io/img/avatar.jpg","name":"Salt","desc":"这是用于记录笔记的个人站，希望一点点的去积累每一天都有收获"}]}],"_content":"","source":"links/index.md","raw":"---\nlayout: links\ntitle: links\ndate: 2018-12-19 23:11:06\nkeywords: 友人帐\ndescription: \ncomments: false \nphotos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg\nlinks:\n  # - group: 个人项目\n  #   desc: 充分说明这家伙是条咸鱼 < (￣︶￣)>\n  #   items:\n  #   - url: https://shino.cc/fgvf\n  #     img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n  #     name: 卫星@kqzh\n  #     desc: Google 镜像\n  #   - url: https://shino.cc/fgvf\n  #     img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg\n  #     name: Google\n  #     desc: Google 镜像\n  - group: 小伙伴们\n    # desc: 欢迎交换友链 ꉂ(ˊᗜˋ)\n    items:\n    - url: https://www.liuxinc.ink/\n      img: https://www.liuxinc.ink/images/avatar.jpg\n      name: 卫星@kqzh\n      desc: a golang coder\n    - url: http://ninging.top/\n      img: http://ninging.top/avatar.jpg\n      name: rookie30\n      desc: 어떤 문제 든 반드시 답 이 있다\n    - url: https://toruneveryday.gitee.io/\n      img: https://toruneveryday.gitee.io/img/avatar.jpg\n      name: Salt\n      desc: 这是用于记录笔记的个人站，希望一点点的去积累每一天都有收获\n---\n","updated":"2023-05-12T23:28:11.000Z","path":"links/index.html","_id":"clhws1t2k000h2h17h97l3htx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","keywords":"喜欢的音乐","description":null,"comments":0,"photos":"https://gitee.com/trueLoving/cdn/raw/master/img/mp3.jpg","_content":"{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"3002651523\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"377233441\"\n  mutex=\"true\">\n</meting-js>\n{% endraw %}","source":"music/index.md","raw":"---\ntitle: music\ndate: 2018-12-20 23:14:28\nkeywords: 喜欢的音乐\ndescription: \ncomments: false\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/mp3.jpg\n---\n{% raw %}\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"3002651523\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"377233441\"\n  mutex=\"true\">\n</meting-js>\n{% endraw %}","updated":"2023-05-12T23:28:11.000Z","path":"music/index.html","layout":"page","_id":"clhws1t2m000n2h170nb3crtc","content":"\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"3002651523\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"377233441\"\n  mutex=\"true\">\n</meting-js>\n","site":{"data":{}},"excerpt":"","more":"\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"3002651523\"\n  mutex=\"true\">\n</meting-js>\n\n<meting-js\n  server=\"netease\"\n  type=\"playlist\"\n  id=\"377233441\"\n  mutex=\"true\">\n</meting-js>\n"},{"_content":"","source":"online/index.md","raw":"","date":"2023-05-13T15:52:25.535Z","updated":"2023-05-13T15:52:25.535Z","path":"online/index.html","title":"","comments":1,"layout":"page","_id":"clhws1t2n000q2h1726vr3jb7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"comment","layout":"paint","date":"2018-12-20T15:13:48.000Z","keywords":"涂鸦","description":null,"comments":0,"photos":"https://gitee.com/trueLoving/cdn/raw/master/img/paint.png","_content":"{% raw %}\n\n{% endraw %}\n","source":"paint/index.md","raw":"---\ntitle: comment\nlayout: paint\ndate: 2018-12-20 23:13:48\nkeywords: 涂鸦\ndescription: \ncomments: false\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/paint.png\n---\n{% raw %}\n\n{% endraw %}\n","updated":"2023-05-12T23:28:11.001Z","path":"paint/index.html","_id":"clhws1t2p000v2h171ac5ecjy","content":"\n\n\n","site":{"data":{}},"excerpt":"","more":"\n\n\n"},{"title":"'tag'","date":"2019-06-09T01:56:49.000Z","layout":"tag","_content":"","source":"tags/index.md","raw":"---\n    title: '''tag'''\n    date: 2019-06-09 09:56:49\n    layout: tag\n---","updated":"2023-05-15T13:26:50.995Z","path":"tags/index.html","comments":1,"_id":"clhws1t2q000z2h17gg061f8k","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"tcp的三次握手和四次挥手","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"网络基础","date":"2019-06-22T16:00:00.000Z","comments":0,"description":"网络基础","photos":["https://ae01.alicdn.com/kf/H3137199903e545088863b23a32bac75cd.jpg"],"_content":"\n## 前言\n\n1. tcp的三次握手是用于实现客户端和服务端的安全建立连接\n2. tcp的四次挥手是用于实现客户端和服务端的安全断开连接\n3. tcp的三次握手和四次挥手最终是为了确定客户端和服务端双方的接收和发送数据的能力是否正常\n\n## tcp的三次握手\n\n#### 1. 过程描述\n\n刚开始的时候，客户端是处于close状态，而服务端处理listen状态。接下来就是双方开始进行tcp的三次握手（即建立连接）\n\n\n![网络基础 tcp的三次握手和四次挥手01](images/网络基础 tcp的三次握手和四次挥手01.png)\n\n1. 第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始值序列号ISN(c),此时客户端的状态由最初的close状态变为SYN_Send状态\n2. 第二次握手：服务端接收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定自己的初始化序列号ISN(s)。同时把客户端的ISN+1作为ACK的值，表示自己已经接收到客户端的SYN。此时服务端的状态由listen状态变为SYN_Recevied状态\n3. 第三次握手：客户端收到服务端发送过来的SYN报文后，会发送一个ACK报文。该ACK报文的值为服务端的ISN值+1。发送该ACK报文给服务端，告诉服务端客户端已经接收到此报文。此时客户端的状态变为establised状态。\n4. 服务端接收到ACK报文之后，也变成了establised状态。此时双方就建立起了连接\n\n\n**过程图**\n\n![tcp的三次握手和四次挥手01](https://gitee.com/trueLoving/cdn/raw/master/img/tcp的三次握手和四次挥手01.png)\n\n#### 2. 每一次握手的作用\n\n1. 第一次握手\n\n```\n客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的发送能力是正常的。\n```\n\n2. 第二次握手\n\n```\n服务端发送数据包，客户端接收到了。\n这样对客户端来说，就可以得出结论：服务端的接收数据和发送数据的能力是正常的。\n```\n\n3. 第三次握手\n\n```\n客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的接收数据的能力是正常的。\n```\n\n因此，通过tcp的三次握手：\n1. 对于客户端来说，它就知道了服务端发送数据和接收数据的能力是正常的（在第二次握手时）\n2. 对于服务端来说，它就知道了客户端发送数据（第一次握手）和接收数据（第三次握手）的能力是正常的\n\n## tcp的四次挥手\n\n#### 1. 过程描述\n\n能够使已经成功建立连接的客户端和服务端安全断开连接。\n\n此时客户端和服务端都处于established状态。\n\n\n在这里，假设客户端主动向服务端断开连接\n1. 第一次挥手：客户端发送一个FIN报文，报文中指定一个ISN(c)。此时客户端就处于FIN_WAIT的状态\n2. 第二次挥手：服务端接收到FIN之后，会发送ACK报文。ACK报文的值为ISN(c)+1。发送给客户端表示服务端已经接收到客户端发送的FIN。此时服务端处于CLOSE_WAIT状态。\n3. 第三次挥手：如果服务端表示同意断开连接，则服务端再发一个FIN报文给客户端，报文中指定一个ISN(s)。此时服务端的状态为LAST_ACK状态。\n4. 第四次挥手：客户端收到服务端发送过来的FIN报文后，一样发送一个ACK报文给服务端表示客户端已经接收到了。而ACK的值为ISN(s)+1。此时客户端处于TIME_WAIT状态。需要过2个发送周期以确保服务端接收到客户端发送的ACK报文之后才进入到CLOSE状态。\n5. 服务端接收到客户端发送的ACK报文后，就关闭连接，处于CLOSED状态\n\n\n**过程图**\n\n![tcp的三次握手和四次挥手02](https://gitee.com/trueLoving/cdn/raw/master/img/tcp的三次握手和四次挥手02.png)\n\n#### 2. 为什么客户端在第四次挥手不直接关闭连接\n\n\n是为了确保服务端已经接收到了客户端发送的ACK报文。\n如果服务端没有接收到该ACK报文，会重新发送一个FIN报文给客户端。客户端再次收到服务端的FIN报文之后，就知道了之前发送的ACK报文已经丢失了，就会重新发送一个ACK报文。\n至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。\n\n\n## 相关概念\n\n1. Syn\nSYN的全称是Synchronize Sequence Numbers，中文名叫做同步序列编号。\n2. ISN\nISN的全称是Initial Sequence Number,中文名叫做初始化序列号。\n让对方知道接下来接收数据的时候如何按序列号组装数据\n3. ACK\nACK的全称是Acknowledge character，中文名称叫做确认字符。\n表示发来的数据已确认接收无误。\n4. FIN\nFIN是tcp包中的一个标识字段，表示关闭连接\n","source":"_posts/前端/网络基础 tcp的三次握手和四次挥手.md","raw":"---\ntitle: tcp的三次握手和四次挥手\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - 网络基础\nkeywords: 网络基础\ndate: 2019-06-23\ncomments: false\ndescription: 网络基础\nphotos: https://ae01.alicdn.com/kf/H3137199903e545088863b23a32bac75cd.jpg\n---\n\n## 前言\n\n1. tcp的三次握手是用于实现客户端和服务端的安全建立连接\n2. tcp的四次挥手是用于实现客户端和服务端的安全断开连接\n3. tcp的三次握手和四次挥手最终是为了确定客户端和服务端双方的接收和发送数据的能力是否正常\n\n## tcp的三次握手\n\n#### 1. 过程描述\n\n刚开始的时候，客户端是处于close状态，而服务端处理listen状态。接下来就是双方开始进行tcp的三次握手（即建立连接）\n\n\n![网络基础 tcp的三次握手和四次挥手01](images/网络基础 tcp的三次握手和四次挥手01.png)\n\n1. 第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始值序列号ISN(c),此时客户端的状态由最初的close状态变为SYN_Send状态\n2. 第二次握手：服务端接收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定自己的初始化序列号ISN(s)。同时把客户端的ISN+1作为ACK的值，表示自己已经接收到客户端的SYN。此时服务端的状态由listen状态变为SYN_Recevied状态\n3. 第三次握手：客户端收到服务端发送过来的SYN报文后，会发送一个ACK报文。该ACK报文的值为服务端的ISN值+1。发送该ACK报文给服务端，告诉服务端客户端已经接收到此报文。此时客户端的状态变为establised状态。\n4. 服务端接收到ACK报文之后，也变成了establised状态。此时双方就建立起了连接\n\n\n**过程图**\n\n![tcp的三次握手和四次挥手01](https://gitee.com/trueLoving/cdn/raw/master/img/tcp的三次握手和四次挥手01.png)\n\n#### 2. 每一次握手的作用\n\n1. 第一次握手\n\n```\n客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的发送能力是正常的。\n```\n\n2. 第二次握手\n\n```\n服务端发送数据包，客户端接收到了。\n这样对客户端来说，就可以得出结论：服务端的接收数据和发送数据的能力是正常的。\n```\n\n3. 第三次握手\n\n```\n客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的接收数据的能力是正常的。\n```\n\n因此，通过tcp的三次握手：\n1. 对于客户端来说，它就知道了服务端发送数据和接收数据的能力是正常的（在第二次握手时）\n2. 对于服务端来说，它就知道了客户端发送数据（第一次握手）和接收数据（第三次握手）的能力是正常的\n\n## tcp的四次挥手\n\n#### 1. 过程描述\n\n能够使已经成功建立连接的客户端和服务端安全断开连接。\n\n此时客户端和服务端都处于established状态。\n\n\n在这里，假设客户端主动向服务端断开连接\n1. 第一次挥手：客户端发送一个FIN报文，报文中指定一个ISN(c)。此时客户端就处于FIN_WAIT的状态\n2. 第二次挥手：服务端接收到FIN之后，会发送ACK报文。ACK报文的值为ISN(c)+1。发送给客户端表示服务端已经接收到客户端发送的FIN。此时服务端处于CLOSE_WAIT状态。\n3. 第三次挥手：如果服务端表示同意断开连接，则服务端再发一个FIN报文给客户端，报文中指定一个ISN(s)。此时服务端的状态为LAST_ACK状态。\n4. 第四次挥手：客户端收到服务端发送过来的FIN报文后，一样发送一个ACK报文给服务端表示客户端已经接收到了。而ACK的值为ISN(s)+1。此时客户端处于TIME_WAIT状态。需要过2个发送周期以确保服务端接收到客户端发送的ACK报文之后才进入到CLOSE状态。\n5. 服务端接收到客户端发送的ACK报文后，就关闭连接，处于CLOSED状态\n\n\n**过程图**\n\n![tcp的三次握手和四次挥手02](https://gitee.com/trueLoving/cdn/raw/master/img/tcp的三次握手和四次挥手02.png)\n\n#### 2. 为什么客户端在第四次挥手不直接关闭连接\n\n\n是为了确保服务端已经接收到了客户端发送的ACK报文。\n如果服务端没有接收到该ACK报文，会重新发送一个FIN报文给客户端。客户端再次收到服务端的FIN报文之后，就知道了之前发送的ACK报文已经丢失了，就会重新发送一个ACK报文。\n至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。\n\n\n## 相关概念\n\n1. Syn\nSYN的全称是Synchronize Sequence Numbers，中文名叫做同步序列编号。\n2. ISN\nISN的全称是Initial Sequence Number,中文名叫做初始化序列号。\n让对方知道接下来接收数据的时候如何按序列号组装数据\n3. ACK\nACK的全称是Acknowledge character，中文名称叫做确认字符。\n表示发来的数据已确认接收无误。\n4. FIN\nFIN是tcp包中的一个标识字段，表示关闭连接\n","slug":"前端/网络基础 tcp的三次握手和四次挥手","published":1,"updated":"2023-05-12T23:28:10.997Z","layout":"post","link":"","_id":"clhws1t2700012h178o413jz1","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li>tcp的三次握手是用于实现客户端和服务端的安全建立连接</li>\n<li>tcp的四次挥手是用于实现客户端和服务端的安全断开连接</li>\n<li>tcp的三次握手和四次挥手最终是为了确定客户端和服务端双方的接收和发送数据的能力是否正常</li>\n</ol>\n<h2 id=\"tcp的三次握手\"><a href=\"#tcp的三次握手\" class=\"headerlink\" title=\"tcp的三次握手\"></a>tcp的三次握手</h2><h4 id=\"1-过程描述\"><a href=\"#1-过程描述\" class=\"headerlink\" title=\"1. 过程描述\"></a>1. 过程描述</h4><p>刚开始的时候，客户端是处于close状态，而服务端处理listen状态。接下来就是双方开始进行tcp的三次握手（即建立连接）</p>\n<p>![网络基础 tcp的三次握手和四次挥手01](images&#x2F;网络基础 tcp的三次握手和四次挥手01.png)</p>\n<ol>\n<li>第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始值序列号ISN(c),此时客户端的状态由最初的close状态变为SYN_Send状态</li>\n<li>第二次握手：服务端接收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定自己的初始化序列号ISN(s)。同时把客户端的ISN+1作为ACK的值，表示自己已经接收到客户端的SYN。此时服务端的状态由listen状态变为SYN_Recevied状态</li>\n<li>第三次握手：客户端收到服务端发送过来的SYN报文后，会发送一个ACK报文。该ACK报文的值为服务端的ISN值+1。发送该ACK报文给服务端，告诉服务端客户端已经接收到此报文。此时客户端的状态变为establised状态。</li>\n<li>服务端接收到ACK报文之后，也变成了establised状态。此时双方就建立起了连接</li>\n</ol>\n<p><strong>过程图</strong></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B01.png\" alt=\"tcp的三次握手和四次挥手01\"></p>\n<h4 id=\"2-每一次握手的作用\"><a href=\"#2-每一次握手的作用\" class=\"headerlink\" title=\"2. 每一次握手的作用\"></a>2. 每一次握手的作用</h4><ol>\n<li>第一次握手</li>\n</ol>\n<pre><code>客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的发送能力是正常的。\n</code></pre>\n<ol start=\"2\">\n<li>第二次握手</li>\n</ol>\n<pre><code>服务端发送数据包，客户端接收到了。\n这样对客户端来说，就可以得出结论：服务端的接收数据和发送数据的能力是正常的。\n</code></pre>\n<ol start=\"3\">\n<li>第三次握手</li>\n</ol>\n<pre><code>客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的接收数据的能力是正常的。\n</code></pre>\n<p>因此，通过tcp的三次握手：</p>\n<ol>\n<li>对于客户端来说，它就知道了服务端发送数据和接收数据的能力是正常的（在第二次握手时）</li>\n<li>对于服务端来说，它就知道了客户端发送数据（第一次握手）和接收数据（第三次握手）的能力是正常的</li>\n</ol>\n<h2 id=\"tcp的四次挥手\"><a href=\"#tcp的四次挥手\" class=\"headerlink\" title=\"tcp的四次挥手\"></a>tcp的四次挥手</h2><h4 id=\"1-过程描述-1\"><a href=\"#1-过程描述-1\" class=\"headerlink\" title=\"1. 过程描述\"></a>1. 过程描述</h4><p>能够使已经成功建立连接的客户端和服务端安全断开连接。</p>\n<p>此时客户端和服务端都处于established状态。</p>\n<p>在这里，假设客户端主动向服务端断开连接</p>\n<ol>\n<li>第一次挥手：客户端发送一个FIN报文，报文中指定一个ISN(c)。此时客户端就处于FIN_WAIT的状态</li>\n<li>第二次挥手：服务端接收到FIN之后，会发送ACK报文。ACK报文的值为ISN(c)+1。发送给客户端表示服务端已经接收到客户端发送的FIN。此时服务端处于CLOSE_WAIT状态。</li>\n<li>第三次挥手：如果服务端表示同意断开连接，则服务端再发一个FIN报文给客户端，报文中指定一个ISN(s)。此时服务端的状态为LAST_ACK状态。</li>\n<li>第四次挥手：客户端收到服务端发送过来的FIN报文后，一样发送一个ACK报文给服务端表示客户端已经接收到了。而ACK的值为ISN(s)+1。此时客户端处于TIME_WAIT状态。需要过2个发送周期以确保服务端接收到客户端发送的ACK报文之后才进入到CLOSE状态。</li>\n<li>服务端接收到客户端发送的ACK报文后，就关闭连接，处于CLOSED状态</li>\n</ol>\n<p><strong>过程图</strong></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B02.png\" alt=\"tcp的三次握手和四次挥手02\"></p>\n<h4 id=\"2-为什么客户端在第四次挥手不直接关闭连接\"><a href=\"#2-为什么客户端在第四次挥手不直接关闭连接\" class=\"headerlink\" title=\"2. 为什么客户端在第四次挥手不直接关闭连接\"></a>2. 为什么客户端在第四次挥手不直接关闭连接</h4><p>是为了确保服务端已经接收到了客户端发送的ACK报文。<br>如果服务端没有接收到该ACK报文，会重新发送一个FIN报文给客户端。客户端再次收到服务端的FIN报文之后，就知道了之前发送的ACK报文已经丢失了，就会重新发送一个ACK报文。<br>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ol>\n<li>Syn<br>SYN的全称是Synchronize Sequence Numbers，中文名叫做同步序列编号。</li>\n<li>ISN<br>ISN的全称是Initial Sequence Number,中文名叫做初始化序列号。<br>让对方知道接下来接收数据的时候如何按序列号组装数据</li>\n<li>ACK<br>ACK的全称是Acknowledge character，中文名称叫做确认字符。<br>表示发来的数据已确认接收无误。</li>\n<li>FIN<br>FIN是tcp包中的一个标识字段，表示关闭连接</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li>tcp的三次握手是用于实现客户端和服务端的安全建立连接</li>\n<li>tcp的四次挥手是用于实现客户端和服务端的安全断开连接</li>\n<li>tcp的三次握手和四次挥手最终是为了确定客户端和服务端双方的接收和发送数据的能力是否正常</li>\n</ol>\n<h2 id=\"tcp的三次握手\"><a href=\"#tcp的三次握手\" class=\"headerlink\" title=\"tcp的三次握手\"></a>tcp的三次握手</h2><h4 id=\"1-过程描述\"><a href=\"#1-过程描述\" class=\"headerlink\" title=\"1. 过程描述\"></a>1. 过程描述</h4><p>刚开始的时候，客户端是处于close状态，而服务端处理listen状态。接下来就是双方开始进行tcp的三次握手（即建立连接）</p>\n<p>![网络基础 tcp的三次握手和四次挥手01](images&#x2F;网络基础 tcp的三次握手和四次挥手01.png)</p>\n<ol>\n<li>第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始值序列号ISN(c),此时客户端的状态由最初的close状态变为SYN_Send状态</li>\n<li>第二次握手：服务端接收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定自己的初始化序列号ISN(s)。同时把客户端的ISN+1作为ACK的值，表示自己已经接收到客户端的SYN。此时服务端的状态由listen状态变为SYN_Recevied状态</li>\n<li>第三次握手：客户端收到服务端发送过来的SYN报文后，会发送一个ACK报文。该ACK报文的值为服务端的ISN值+1。发送该ACK报文给服务端，告诉服务端客户端已经接收到此报文。此时客户端的状态变为establised状态。</li>\n<li>服务端接收到ACK报文之后，也变成了establised状态。此时双方就建立起了连接</li>\n</ol>\n<p><strong>过程图</strong></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B01.png\" alt=\"tcp的三次握手和四次挥手01\"></p>\n<h4 id=\"2-每一次握手的作用\"><a href=\"#2-每一次握手的作用\" class=\"headerlink\" title=\"2. 每一次握手的作用\"></a>2. 每一次握手的作用</h4><ol>\n<li>第一次握手</li>\n</ol>\n<pre><code>客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的发送能力是正常的。\n</code></pre>\n<ol start=\"2\">\n<li>第二次握手</li>\n</ol>\n<pre><code>服务端发送数据包，客户端接收到了。\n这样对客户端来说，就可以得出结论：服务端的接收数据和发送数据的能力是正常的。\n</code></pre>\n<ol start=\"3\">\n<li>第三次握手</li>\n</ol>\n<pre><code>客户端发送数据包，服务端接收到了。\n这样对服务端来说，就可以得出结论：客户端的接收数据的能力是正常的。\n</code></pre>\n<p>因此，通过tcp的三次握手：</p>\n<ol>\n<li>对于客户端来说，它就知道了服务端发送数据和接收数据的能力是正常的（在第二次握手时）</li>\n<li>对于服务端来说，它就知道了客户端发送数据（第一次握手）和接收数据（第三次握手）的能力是正常的</li>\n</ol>\n<h2 id=\"tcp的四次挥手\"><a href=\"#tcp的四次挥手\" class=\"headerlink\" title=\"tcp的四次挥手\"></a>tcp的四次挥手</h2><h4 id=\"1-过程描述-1\"><a href=\"#1-过程描述-1\" class=\"headerlink\" title=\"1. 过程描述\"></a>1. 过程描述</h4><p>能够使已经成功建立连接的客户端和服务端安全断开连接。</p>\n<p>此时客户端和服务端都处于established状态。</p>\n<p>在这里，假设客户端主动向服务端断开连接</p>\n<ol>\n<li>第一次挥手：客户端发送一个FIN报文，报文中指定一个ISN(c)。此时客户端就处于FIN_WAIT的状态</li>\n<li>第二次挥手：服务端接收到FIN之后，会发送ACK报文。ACK报文的值为ISN(c)+1。发送给客户端表示服务端已经接收到客户端发送的FIN。此时服务端处于CLOSE_WAIT状态。</li>\n<li>第三次挥手：如果服务端表示同意断开连接，则服务端再发一个FIN报文给客户端，报文中指定一个ISN(s)。此时服务端的状态为LAST_ACK状态。</li>\n<li>第四次挥手：客户端收到服务端发送过来的FIN报文后，一样发送一个ACK报文给服务端表示客户端已经接收到了。而ACK的值为ISN(s)+1。此时客户端处于TIME_WAIT状态。需要过2个发送周期以确保服务端接收到客户端发送的ACK报文之后才进入到CLOSE状态。</li>\n<li>服务端接收到客户端发送的ACK报文后，就关闭连接，处于CLOSED状态</li>\n</ol>\n<p><strong>过程图</strong></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B02.png\" alt=\"tcp的三次握手和四次挥手02\"></p>\n<h4 id=\"2-为什么客户端在第四次挥手不直接关闭连接\"><a href=\"#2-为什么客户端在第四次挥手不直接关闭连接\" class=\"headerlink\" title=\"2. 为什么客户端在第四次挥手不直接关闭连接\"></a>2. 为什么客户端在第四次挥手不直接关闭连接</h4><p>是为了确保服务端已经接收到了客户端发送的ACK报文。<br>如果服务端没有接收到该ACK报文，会重新发送一个FIN报文给客户端。客户端再次收到服务端的FIN报文之后，就知道了之前发送的ACK报文已经丢失了，就会重新发送一个ACK报文。<br>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ol>\n<li>Syn<br>SYN的全称是Synchronize Sequence Numbers，中文名叫做同步序列编号。</li>\n<li>ISN<br>ISN的全称是Initial Sequence Number,中文名叫做初始化序列号。<br>让对方知道接下来接收数据的时候如何按序列号组装数据</li>\n<li>ACK<br>ACK的全称是Acknowledge character，中文名称叫做确认字符。<br>表示发来的数据已确认接收无误。</li>\n<li>FIN<br>FIN是tcp包中的一个标识字段，表示关闭连接</li>\n</ol>\n"},{"title":"Widgets生命周期","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"笔记","date":"2020-06-09T16:00:00.000Z","comments":0,"description":"Widgets生命周期","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识_bg.jpg"],"_content":"\n\n## 前言 Widget & Element\n\nFlutter许多设计思路都是借鉴于React的,因此我们可以通过两者的对比来学习Flutter\n\nWidget:用于描述一个UI元素的配置数据,类似于React的VNode\n\nElement:真正显示在设备屏幕上的元素,类似于DOM\n\nFlutter通过控制Widget数来控制屏幕显示的元素树,当Widget树发生变化时,Flutter会以最小的代价来更新元素树,这样就使得性能得到很高的提升(参考React的DOM diff算法)。Widget树和Element树之间有对应关系。\n\n一般来说，一个Widget对象可以对应多个Element元素对象\n\n\n## StatefulWidget\n\n\n在Flutter中,我们最常用的两个类就是继承于Widget的`StatelessWidge`t和`StatefulWidget`\n\n至于什么时候使用哪个类,其实最关键的点就是要考虑当前的Widget是否需要维护数据,如果需要就是使用StatefulWidget类,否则就使用StatelessWidge\n\n至于怎么判断当前Widget是否需要维护数据,其实就是看我们需要当前组件实现怎样的功能,如果就单纯的UI显示,那么毫无疑问就使用StatelessWidge类。\n\n如果我们在该组件中需要数据进行某些操作，\n\n例如常见的用户登录中,我们需要用户输入账号密码向我们后端发送请求,那么我们的表单组件就去需要维护一份用户输入的账号密码数据,就需要跟踪用户的数据情况,在这里一般都是使用onchange事件进行回调监听。当用户的输入发生变化时,重新获取用户的输入，并赋值到当前组件所绑定的状态上。\n\n而这种情况,组件就需要继承StatefulWidget类,来保存状态。\n\n在使用StatefulWidget类时候,我们要搞清楚,哪些数据是从外部来的,哪些数据是需要组件自己去维护的, 这就是使用好StatefulWidget类最关键的一步(类似于React的\"状态机\"概念)\n\n## StatefulWidget的生命周期\n\n\nStatefulWidget的生命周期如下图所示\n\n\n![Widget生命周期](https://gitee.com/trueLoving/cdn/raw/master/img/Widget生命周期 01.jpg)\n\n\n\nStatefulWidget的生命周期和React的组件生命周期其实是差不多的,主要可以分为以下三个阶段\n1. 初始化：初始化组件状态,并插入Widget树中\n2. 状态变化:当状态发生变化时,重新渲染组件\n3. 移除:将组件从Widget树中移除\n\n\n其中每一个阶段所涉及到的具体生命周期函数和在当前生命周期函数应该做什么事情如下\n\n#### 初始化\n\n1. initState\n\n当Widget第一次插入到Widget树时被调用,对于每一个State对象,Flutter Framework只会调用一次该回调函数,所以通常在该回调函数做一些一次性的操作,如状态初始化,订阅子树的事件通知等.\n\n2. didChangeDependencies\n\n当State对象的依赖发生变化时调用.典型的场景是当下图语言Locale或应用主题发生改变时,Flutter Framework就会通知widge调用此回调\n\n3. build\n\n该函数用于构建Widget子树\n一般会在如下场景被调用\n1. 在调用initState()之后\n2. 在调用didUpdateWidget()之后\n3. 在调用setState()之后\n4. 在调用didChangeDependencies()之后\n5. 在State对象从树中的一个位置移除之后(会调用deactivate)又重新插入到树的其它位置之后\n\n\n#### 更新\n\n1. reassumble\n\n此回调是专门为了开发调试而提供的，在热重载 (hot reload) 时会被调用，此回调在 Release 模式下永远不会被调用\n\n2. didUpdateWidget\n\n在widget重新构建时,Flutter framenwork会调用Widget.canupdate来检测Widget树中的同一位置的新旧节点，然后决定是否需要更新，\n如果Widget.canUpdate返回true,则会调用此回调。\n正如之前所述,Widget.canUpdate会在新旧widget的key和runtimeType同时相等时返回true,\n也就是说在在新旧 widget 的 key 和 runtimeType 同时相等时didUpdateWidget()就会被调用\n\n\n#### 移除销毁\n1. deactivate\n\n当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework 会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过 GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法\n\n2. dispose\n\n当 State 对象从树中被永久移除时调用；通常在此回调中释放资源\n","source":"_posts/笔记/Flutter Widgets生命周期.md","raw":"---\ntitle: Widgets生命周期\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 笔记\ntags:\n - 笔记\nkeywords: 笔记\ndate: 2020-06-10\ncomments: false\ndescription: Widgets生命周期\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识_bg.jpg\n---\n\n\n## 前言 Widget & Element\n\nFlutter许多设计思路都是借鉴于React的,因此我们可以通过两者的对比来学习Flutter\n\nWidget:用于描述一个UI元素的配置数据,类似于React的VNode\n\nElement:真正显示在设备屏幕上的元素,类似于DOM\n\nFlutter通过控制Widget数来控制屏幕显示的元素树,当Widget树发生变化时,Flutter会以最小的代价来更新元素树,这样就使得性能得到很高的提升(参考React的DOM diff算法)。Widget树和Element树之间有对应关系。\n\n一般来说，一个Widget对象可以对应多个Element元素对象\n\n\n## StatefulWidget\n\n\n在Flutter中,我们最常用的两个类就是继承于Widget的`StatelessWidge`t和`StatefulWidget`\n\n至于什么时候使用哪个类,其实最关键的点就是要考虑当前的Widget是否需要维护数据,如果需要就是使用StatefulWidget类,否则就使用StatelessWidge\n\n至于怎么判断当前Widget是否需要维护数据,其实就是看我们需要当前组件实现怎样的功能,如果就单纯的UI显示,那么毫无疑问就使用StatelessWidge类。\n\n如果我们在该组件中需要数据进行某些操作，\n\n例如常见的用户登录中,我们需要用户输入账号密码向我们后端发送请求,那么我们的表单组件就去需要维护一份用户输入的账号密码数据,就需要跟踪用户的数据情况,在这里一般都是使用onchange事件进行回调监听。当用户的输入发生变化时,重新获取用户的输入，并赋值到当前组件所绑定的状态上。\n\n而这种情况,组件就需要继承StatefulWidget类,来保存状态。\n\n在使用StatefulWidget类时候,我们要搞清楚,哪些数据是从外部来的,哪些数据是需要组件自己去维护的, 这就是使用好StatefulWidget类最关键的一步(类似于React的\"状态机\"概念)\n\n## StatefulWidget的生命周期\n\n\nStatefulWidget的生命周期如下图所示\n\n\n![Widget生命周期](https://gitee.com/trueLoving/cdn/raw/master/img/Widget生命周期 01.jpg)\n\n\n\nStatefulWidget的生命周期和React的组件生命周期其实是差不多的,主要可以分为以下三个阶段\n1. 初始化：初始化组件状态,并插入Widget树中\n2. 状态变化:当状态发生变化时,重新渲染组件\n3. 移除:将组件从Widget树中移除\n\n\n其中每一个阶段所涉及到的具体生命周期函数和在当前生命周期函数应该做什么事情如下\n\n#### 初始化\n\n1. initState\n\n当Widget第一次插入到Widget树时被调用,对于每一个State对象,Flutter Framework只会调用一次该回调函数,所以通常在该回调函数做一些一次性的操作,如状态初始化,订阅子树的事件通知等.\n\n2. didChangeDependencies\n\n当State对象的依赖发生变化时调用.典型的场景是当下图语言Locale或应用主题发生改变时,Flutter Framework就会通知widge调用此回调\n\n3. build\n\n该函数用于构建Widget子树\n一般会在如下场景被调用\n1. 在调用initState()之后\n2. 在调用didUpdateWidget()之后\n3. 在调用setState()之后\n4. 在调用didChangeDependencies()之后\n5. 在State对象从树中的一个位置移除之后(会调用deactivate)又重新插入到树的其它位置之后\n\n\n#### 更新\n\n1. reassumble\n\n此回调是专门为了开发调试而提供的，在热重载 (hot reload) 时会被调用，此回调在 Release 模式下永远不会被调用\n\n2. didUpdateWidget\n\n在widget重新构建时,Flutter framenwork会调用Widget.canupdate来检测Widget树中的同一位置的新旧节点，然后决定是否需要更新，\n如果Widget.canUpdate返回true,则会调用此回调。\n正如之前所述,Widget.canUpdate会在新旧widget的key和runtimeType同时相等时返回true,\n也就是说在在新旧 widget 的 key 和 runtimeType 同时相等时didUpdateWidget()就会被调用\n\n\n#### 移除销毁\n1. deactivate\n\n当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework 会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过 GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法\n\n2. dispose\n\n当 State 对象从树中被永久移除时调用；通常在此回调中释放资源\n","slug":"笔记/Flutter Widgets生命周期","published":1,"updated":"2023-05-12T23:28:10.998Z","layout":"post","link":"","_id":"clhws1t2b00032h1735o70imh","content":"<h2 id=\"前言-Widget-amp-Element\"><a href=\"#前言-Widget-amp-Element\" class=\"headerlink\" title=\"前言 Widget &amp; Element\"></a>前言 Widget &amp; Element</h2><p>Flutter许多设计思路都是借鉴于React的,因此我们可以通过两者的对比来学习Flutter</p>\n<p>Widget:用于描述一个UI元素的配置数据,类似于React的VNode</p>\n<p>Element:真正显示在设备屏幕上的元素,类似于DOM</p>\n<p>Flutter通过控制Widget数来控制屏幕显示的元素树,当Widget树发生变化时,Flutter会以最小的代价来更新元素树,这样就使得性能得到很高的提升(参考React的DOM diff算法)。Widget树和Element树之间有对应关系。</p>\n<p>一般来说，一个Widget对象可以对应多个Element元素对象</p>\n<h2 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h2><p>在Flutter中,我们最常用的两个类就是继承于Widget的<code>StatelessWidge</code>t和<code>StatefulWidget</code></p>\n<p>至于什么时候使用哪个类,其实最关键的点就是要考虑当前的Widget是否需要维护数据,如果需要就是使用StatefulWidget类,否则就使用StatelessWidge</p>\n<p>至于怎么判断当前Widget是否需要维护数据,其实就是看我们需要当前组件实现怎样的功能,如果就单纯的UI显示,那么毫无疑问就使用StatelessWidge类。</p>\n<p>如果我们在该组件中需要数据进行某些操作，</p>\n<p>例如常见的用户登录中,我们需要用户输入账号密码向我们后端发送请求,那么我们的表单组件就去需要维护一份用户输入的账号密码数据,就需要跟踪用户的数据情况,在这里一般都是使用onchange事件进行回调监听。当用户的输入发生变化时,重新获取用户的输入，并赋值到当前组件所绑定的状态上。</p>\n<p>而这种情况,组件就需要继承StatefulWidget类,来保存状态。</p>\n<p>在使用StatefulWidget类时候,我们要搞清楚,哪些数据是从外部来的,哪些数据是需要组件自己去维护的, 这就是使用好StatefulWidget类最关键的一步(类似于React的”状态机”概念)</p>\n<h2 id=\"StatefulWidget的生命周期\"><a href=\"#StatefulWidget的生命周期\" class=\"headerlink\" title=\"StatefulWidget的生命周期\"></a>StatefulWidget的生命周期</h2><p>StatefulWidget的生命周期如下图所示</p>\n<p>![Widget生命周期](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Widget%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">https://gitee.com/trueLoving/cdn/raw/master/img/Widget生命周期</a> 01.jpg)</p>\n<p>StatefulWidget的生命周期和React的组件生命周期其实是差不多的,主要可以分为以下三个阶段</p>\n<ol>\n<li>初始化：初始化组件状态,并插入Widget树中</li>\n<li>状态变化:当状态发生变化时,重新渲染组件</li>\n<li>移除:将组件从Widget树中移除</li>\n</ol>\n<p>其中每一个阶段所涉及到的具体生命周期函数和在当前生命周期函数应该做什么事情如下</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><ol>\n<li>initState</li>\n</ol>\n<p>当Widget第一次插入到Widget树时被调用,对于每一个State对象,Flutter Framework只会调用一次该回调函数,所以通常在该回调函数做一些一次性的操作,如状态初始化,订阅子树的事件通知等.</p>\n<ol start=\"2\">\n<li>didChangeDependencies</li>\n</ol>\n<p>当State对象的依赖发生变化时调用.典型的场景是当下图语言Locale或应用主题发生改变时,Flutter Framework就会通知widge调用此回调</p>\n<ol start=\"3\">\n<li>build</li>\n</ol>\n<p>该函数用于构建Widget子树<br>一般会在如下场景被调用</p>\n<ol>\n<li>在调用initState()之后</li>\n<li>在调用didUpdateWidget()之后</li>\n<li>在调用setState()之后</li>\n<li>在调用didChangeDependencies()之后</li>\n<li>在State对象从树中的一个位置移除之后(会调用deactivate)又重新插入到树的其它位置之后</li>\n</ol>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><ol>\n<li>reassumble</li>\n</ol>\n<p>此回调是专门为了开发调试而提供的，在热重载 (hot reload) 时会被调用，此回调在 Release 模式下永远不会被调用</p>\n<ol start=\"2\">\n<li>didUpdateWidget</li>\n</ol>\n<p>在widget重新构建时,Flutter framenwork会调用Widget.canupdate来检测Widget树中的同一位置的新旧节点，然后决定是否需要更新，<br>如果Widget.canUpdate返回true,则会调用此回调。<br>正如之前所述,Widget.canUpdate会在新旧widget的key和runtimeType同时相等时返回true,<br>也就是说在在新旧 widget 的 key 和 runtimeType 同时相等时didUpdateWidget()就会被调用</p>\n<h4 id=\"移除销毁\"><a href=\"#移除销毁\" class=\"headerlink\" title=\"移除销毁\"></a>移除销毁</h4><ol>\n<li>deactivate</li>\n</ol>\n<p>当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework 会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过 GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法</p>\n<ol start=\"2\">\n<li>dispose</li>\n</ol>\n<p>当 State 对象从树中被永久移除时调用；通常在此回调中释放资源</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言-Widget-amp-Element\"><a href=\"#前言-Widget-amp-Element\" class=\"headerlink\" title=\"前言 Widget &amp; Element\"></a>前言 Widget &amp; Element</h2><p>Flutter许多设计思路都是借鉴于React的,因此我们可以通过两者的对比来学习Flutter</p>\n<p>Widget:用于描述一个UI元素的配置数据,类似于React的VNode</p>\n<p>Element:真正显示在设备屏幕上的元素,类似于DOM</p>\n<p>Flutter通过控制Widget数来控制屏幕显示的元素树,当Widget树发生变化时,Flutter会以最小的代价来更新元素树,这样就使得性能得到很高的提升(参考React的DOM diff算法)。Widget树和Element树之间有对应关系。</p>\n<p>一般来说，一个Widget对象可以对应多个Element元素对象</p>\n<h2 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h2><p>在Flutter中,我们最常用的两个类就是继承于Widget的<code>StatelessWidge</code>t和<code>StatefulWidget</code></p>\n<p>至于什么时候使用哪个类,其实最关键的点就是要考虑当前的Widget是否需要维护数据,如果需要就是使用StatefulWidget类,否则就使用StatelessWidge</p>\n<p>至于怎么判断当前Widget是否需要维护数据,其实就是看我们需要当前组件实现怎样的功能,如果就单纯的UI显示,那么毫无疑问就使用StatelessWidge类。</p>\n<p>如果我们在该组件中需要数据进行某些操作，</p>\n<p>例如常见的用户登录中,我们需要用户输入账号密码向我们后端发送请求,那么我们的表单组件就去需要维护一份用户输入的账号密码数据,就需要跟踪用户的数据情况,在这里一般都是使用onchange事件进行回调监听。当用户的输入发生变化时,重新获取用户的输入，并赋值到当前组件所绑定的状态上。</p>\n<p>而这种情况,组件就需要继承StatefulWidget类,来保存状态。</p>\n<p>在使用StatefulWidget类时候,我们要搞清楚,哪些数据是从外部来的,哪些数据是需要组件自己去维护的, 这就是使用好StatefulWidget类最关键的一步(类似于React的”状态机”概念)</p>\n<h2 id=\"StatefulWidget的生命周期\"><a href=\"#StatefulWidget的生命周期\" class=\"headerlink\" title=\"StatefulWidget的生命周期\"></a>StatefulWidget的生命周期</h2><p>StatefulWidget的生命周期如下图所示</p>\n<p>![Widget生命周期](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Widget%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">https://gitee.com/trueLoving/cdn/raw/master/img/Widget生命周期</a> 01.jpg)</p>\n<p>StatefulWidget的生命周期和React的组件生命周期其实是差不多的,主要可以分为以下三个阶段</p>\n<ol>\n<li>初始化：初始化组件状态,并插入Widget树中</li>\n<li>状态变化:当状态发生变化时,重新渲染组件</li>\n<li>移除:将组件从Widget树中移除</li>\n</ol>\n<p>其中每一个阶段所涉及到的具体生命周期函数和在当前生命周期函数应该做什么事情如下</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><ol>\n<li>initState</li>\n</ol>\n<p>当Widget第一次插入到Widget树时被调用,对于每一个State对象,Flutter Framework只会调用一次该回调函数,所以通常在该回调函数做一些一次性的操作,如状态初始化,订阅子树的事件通知等.</p>\n<ol start=\"2\">\n<li>didChangeDependencies</li>\n</ol>\n<p>当State对象的依赖发生变化时调用.典型的场景是当下图语言Locale或应用主题发生改变时,Flutter Framework就会通知widge调用此回调</p>\n<ol start=\"3\">\n<li>build</li>\n</ol>\n<p>该函数用于构建Widget子树<br>一般会在如下场景被调用</p>\n<ol>\n<li>在调用initState()之后</li>\n<li>在调用didUpdateWidget()之后</li>\n<li>在调用setState()之后</li>\n<li>在调用didChangeDependencies()之后</li>\n<li>在State对象从树中的一个位置移除之后(会调用deactivate)又重新插入到树的其它位置之后</li>\n</ol>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><ol>\n<li>reassumble</li>\n</ol>\n<p>此回调是专门为了开发调试而提供的，在热重载 (hot reload) 时会被调用，此回调在 Release 模式下永远不会被调用</p>\n<ol start=\"2\">\n<li>didUpdateWidget</li>\n</ol>\n<p>在widget重新构建时,Flutter framenwork会调用Widget.canupdate来检测Widget树中的同一位置的新旧节点，然后决定是否需要更新，<br>如果Widget.canUpdate返回true,则会调用此回调。<br>正如之前所述,Widget.canUpdate会在新旧widget的key和runtimeType同时相等时返回true,<br>也就是说在在新旧 widget 的 key 和 runtimeType 同时相等时didUpdateWidget()就会被调用</p>\n<h4 id=\"移除销毁\"><a href=\"#移除销毁\" class=\"headerlink\" title=\"移除销毁\"></a>移除销毁</h4><ol>\n<li>deactivate</li>\n</ol>\n<p>当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework 会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过 GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法</p>\n<ol start=\"2\">\n<li>dispose</li>\n</ol>\n<p>当 State 对象从树中被永久移除时调用；通常在此回调中释放资源</p>\n"},{"title":"类数组转换为数组的方法","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"笔记","date":"2020-06-05T16:00:00.000Z","comments":0,"description":"类数组转换为数组的方法","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n常见的类数组如下\n1. 用getElementByTagName/ClassName/Name（）获得的HTMLCollection\n2. 用querySlector获得的nodeList\n\n在我们开发过程中,我们经常需要将类数组转换为数组\n\n可以使用的方案如下\n\n1. Array.prototype.slice.call()\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.prototype.slice.call(arguments)\n\n    console.log(args instanceof Array) // true\n\n}\n```\n\n2. Array.from()\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.from(arguments)\n\n    console.log(args instanceof Array) // true\n\n}\n```\n\n3. ES6展开运算符\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [...arguments];\n\n    console.log(args instanceof Array) // true\n\n}\n```\n4. 创建新的数组,将类数组成员直接加入到新的数组中\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [];\n\n    for(let i=0;i<arguments.length;i++){\n        args.push(arguments[i]);\n    }\n\n    console.log(args instanceof Array) // true\n\n}\n```","source":"_posts/笔记/类数组转换为数组方法.md","raw":"---\ntitle: 类数组转换为数组的方法\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 笔记\ntags:\n - 笔记\nkeywords: 笔记\ndate: 2020-06-06\ncomments: false\ndescription: 类数组转换为数组的方法\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n常见的类数组如下\n1. 用getElementByTagName/ClassName/Name（）获得的HTMLCollection\n2. 用querySlector获得的nodeList\n\n在我们开发过程中,我们经常需要将类数组转换为数组\n\n可以使用的方案如下\n\n1. Array.prototype.slice.call()\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.prototype.slice.call(arguments)\n\n    console.log(args instanceof Array) // true\n\n}\n```\n\n2. Array.from()\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.from(arguments)\n\n    console.log(args instanceof Array) // true\n\n}\n```\n\n3. ES6展开运算符\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [...arguments];\n\n    console.log(args instanceof Array) // true\n\n}\n```\n4. 创建新的数组,将类数组成员直接加入到新的数组中\n\n```js\nfunction(){\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [];\n\n    for(let i=0;i<arguments.length;i++){\n        args.push(arguments[i]);\n    }\n\n    console.log(args instanceof Array) // true\n\n}\n```","slug":"笔记/类数组转换为数组方法","published":1,"updated":"2023-05-12T23:28:10.999Z","layout":"post","link":"","_id":"clhws1t2f00072h178wv5714y","content":"<p>常见的类数组如下</p>\n<ol>\n<li>用getElementByTagName&#x2F;ClassName&#x2F;Name（）获得的HTMLCollection</li>\n<li>用querySlector获得的nodeList</li>\n</ol>\n<p>在我们开发过程中,我们经常需要将类数组转换为数组</p>\n<p>可以使用的方案如下</p>\n<ol>\n<li>Array.prototype.slice.call()</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.prototype.slice.call(arguments)\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>Array.from()</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.from(arguments)\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>ES6展开运算符</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [...arguments];\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>创建新的数组,将类数组成员直接加入到新的数组中</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [];\n\n    for(let i=0;i&lt;arguments.length;i++)&#123;\n        args.push(arguments[i]);\n    &#125;\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>常见的类数组如下</p>\n<ol>\n<li>用getElementByTagName&#x2F;ClassName&#x2F;Name（）获得的HTMLCollection</li>\n<li>用querySlector获得的nodeList</li>\n</ol>\n<p>在我们开发过程中,我们经常需要将类数组转换为数组</p>\n<p>可以使用的方案如下</p>\n<ol>\n<li>Array.prototype.slice.call()</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.prototype.slice.call(arguments)\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>Array.from()</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = Array.from(arguments)\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>ES6展开运算符</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [...arguments];\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li>创建新的数组,将类数组成员直接加入到新的数组中</li>\n</ol>\n<pre><code class=\"js\">function()&#123;\n    \n    console.log(arguments instanceof Array) // false\n\n    let args = [];\n\n    for(let i=0;i&lt;arguments.length;i++)&#123;\n        args.push(arguments[i]);\n    &#125;\n\n    console.log(args instanceof Array) // true\n\n&#125;\n</code></pre>\n"},{"title":"Virtual DOM","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"笔记","date":"2020-06-25T16:00:00.000Z","comments":0,"description":"Virtual DOM","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Virtual_DOM_bg.jpg"],"_content":"\n\n## 前言\n\nVirtual DOM,虚拟DOM,其实是对页面真实DOM的一种简单描述对象,我们可以通过这个虚拟DOM,使用浏览器提供的API(document.createElement()...等)来创建出与其对应的真实DOM。\n\n这样,我们就可以通过操作虚拟DOM,来间接操作DOM,而由于虚拟DOM的对象比真实DOM的对象要小得多,这样我们就可以降低在操作DOM对象上的一些开销,以此来提升页面的性能。\n\n像目前的React,Vue框架都借助了虚拟DOM来完成对真实DOM的操作,将DOM树写到内存中,然后在内存中完成对DOM树的操作(插入,修改,删除,添加.....),最后当完成了对DOM树的所有操作后,一次性将DOM树插回到页面中,这样就大大减少了浏览器页面的重绘工作量,提升了网页性能。\n\n我们其实可以使用js来创建自己的虚拟DOM,`虚拟DOM的本质其实就是一个JS对象`。\n\n所以,定义一个属于自己的虚拟DOM,可以分为以下几步\n1. 创建vNode\n2. 渲染vNode\n3. 挂载vNode\n4. 更新vNode\n\n下面就是将如何通过使用JS代码来实现自己的虚拟DOM\n\n## 确定虚拟DOM对象\n\n首先,我们要确定虚拟DOM对象的属性名和属性值,在这里,虚拟DOM对象的属性名和属性值如下\n```js\nclass VDOM{\n    tagName='tagName', // 类型:字符串   含义:VDOM对应DOM的标签名称\n    attrs:{},          // 类型:对象     含义:VDOM对于DOM的属性节点\n    children:[]        // 类型:数组     含义:该VDOM下的子VDOM对象\n}\n```\n\n## 创建虚拟DOM对象\n\n我们需要一个函数,只要我们传入相关参数,就会帮我们生成相对应的VDOM对象\n```js\n/**\n * \n *  @tagName    {String} VDOM的标签名称\n *  @attrs      {Object} VDOM的属性节点\n *  @childrem   {Array}  VDOM的后代VDOM\n */\nfunction createElement(tagName,{attrs={},children=[]}={}){\n    return{\n        tagName,\n        attrs,\n        children\n    }\n}\n```\n\n## 渲染虚拟DOM对象\n\n当我们手中有一个虚拟DOM时,我们需要一个函数来帮助我们将该虚拟DOM转换为真实DOM\n```js\n// 如果VDOM为\nfunction renderElement({tagName,attrs,children}){\n\n    const $el = document.createElement(tagName);\n\n    // set attribute\n    for(const [k,v] of attrs){\n        $el.setAttribute(k,v);\n    }\n\n    // render child\n    // 当存在子VDOM时,递归调用render方法,然后将render方法的返回值添加到$el的后代中\n    for(const child of children){\n        const $child = render(child);\n        $el.appendChild($child);\n    }\n\n    return $el;\n}\n\nfunction render(VDOM){\n    // 如果VDOM是字符串,说明此VDOM为文本节点\n    if(typeof VDOM === \"string\"){\n        return document.createTextContent(VDOM);\n    }\n    return renderElement(VDOM);\n}\n\n```\n\n## 挂载虚拟DOM对象\n\n现在,我们手中有真实DOM,然后就需要将其挂载在我们指定的DOM后面\n```js\n/**\n * @$node   {DOM} 由VDOM得到的DOM\n * @target  {DOM} 要被插入$node的父元素DOM\n */\nfunction mount($node,$target){\n    $target.replaceWith($node);\n    return $node;\n}\n```\n\n## 更新虚拟DOM对象\n当我们去更新，插入或者删除一个VDOM时,我们需要一个方法来帮助我们以最小的代价来更新VDOM树对应的DOM树,这个方法就是diff算法\n\ndiff算法的可以分为以下三个部分\n1. 比较传入的节点(diff函数)\n2. 比较传入节点的属性(diffAttrs函数)\n3. 比较节点的子节点(diffChildren函数)\n\n\n#### diff函数实现\n\n对于diff函数,需要考虑四种情况\n1. 传入的新节点为undefined,是因为该节点是要被删除的节点，所以回传的回调函数patch要调用Node.remove()方法\n2. 传入的旧节点或者新节点可以是字符串,此时可以直接比较新旧两个节点,如果不一样,则用新节点取代旧节点\n3. 旧节点与新节点的标签不一样,则用新节点去取代旧节点\n4. 旧节点与新节点的标签一样，则继续往下比较标签上的属性节点以及其子节点\n\n`函数实现`\n```js\nconst diff = (vOldNode,vNewNode) =>{\n    if(vNewNode===undefined){\n        return ($node)=>{\n            $node.remove();\n            return undefined;\n        }\n    }\n    if(typeof vOldNode === \"string\" || typeof vNewNode === \"string\"){\n        if(vNewNode!==vOldNode){\n            return ($node)=>{\n                const $newNode = render(vNewNode);\n                return mount($newNode,$node);\n            }\n        }\n    }\n    if(vOldNode.tagName!==vNewNode.tagName){\n        return ($node)=>{\n            const $newNode = render(vNewNode);\n            return mount($newNode,$node);\n        };\n    }\n    \n    // 比较属性节点,diffAttrs后面会实现\n    const patchAttrs = diffAttrs(vOldNode.attrs.vNewNode.attrs);\n    // 比较其子节点,diffChildren后面会实现\n    const pathChildren = diffChildren(vOldNode.children,vNewOlde,children);\n    return ($node)=>{\n        patchAttrs($node);\n        patchChildren($node.children);\n        return $node;\n    }\n}\n```\n\n#### diffAttrs函数实现\n\ndiffAttrs函数主要是在标签上设置属性和删除属性\n\n函数patches用于存储属性变动的patch函数\n\n比较完所有的属性节点后,会在diff函数呼叫patchAttrs($node),将节点传进来并批量更新标签上的属性\n\n`函数实现`\n```js\nconst diffAttrs = (oldAttrs,newAttrs)=>{\n\n    // 更新节点的回调函数\n    const patches = [];\n\n    // 遍历新的节点属性\n    for(const [k,v] of Object.entries(newAttrs)){\n        patches.push($node=>{\n            $node.setAttribute(k,v);\n            return $node;\n        })\n    }\n\n    // 遍历旧的节点属性\n    for(const key of oldAttrs){\n        // 如果一个新的属性节点，在旧的存在，但是在新的不存在，则$node需要移除该属性节点\n        if(!(key in newAttrs)){\n            patches.push($node=>{\n                $node.removeAttribute(key);\n                return $node;\n            })\n        }\n    }\n\n    // 返回可调用用于更新属性节点的回调函数\n    return ($node)=>{\n        patches.forEach(patch=>{\n            patch($node);\n        })\n    }\n\n}\n```\n\n#### diffChildren函数实现\n\ndiffChildren的任务就是更新变得的子节点/删除子节点/插入新的子节点/.....\n\n\n`函数实现`\n```js\n\n\nconst zip = (xs,ys) =>{\n    cosnt zipped = [];\n    for(let i=0;i<Math.min(xs.length,ys.length);i++){\n        zipped.push([xs[i],ys[i]]);\n    }\n    return zipped;\n}\n\nconst diffChildren = (oldVChildren,newVChildren) =>{\n\n    const childPatches = [];\n    \n\n    for(const [oldChild,newChild] of zip(oldVChildren,newVChildren)){\n        childPatches.push(diff(oldChild,newChild));\n    }\n\n\n    const additionalPatches = [];\n    newVChildren.slice(oldVChildren.length).forEach(additionalVChild=>{\n        additionalPatches.push(($node)=>{\n            $node.appendChild(render(additionalVChild));\n            return $node;\n        });\n    });\n\n    return ($node)=>{\n        for(let i=childPatches.length-1;i>=0;i--){\n            const $child = $node.children[i];\n            const patch = childPatches[i];\n            patch($child);\n        }\n        additionalPatches.forEach(patch=>{\n            patch($node);\n        })\n        return $node;\n    }\n\n}\n\n```\n\n## 测试虚拟DOM对象\n\n`main.js`\n```js\n// 引入相关函数\nimport createElement from \"./vdom/createElement\";\nimport render from \"./vdom/render\";\nimport mount from \"./vdom/mount\";\nimport diff from './vdom/diff';\n\nconst createApp = (count) => createElement(\n    'div',\n    {\n        attrs: {\n            dataCount: count\n        },\n        children: [\n            createElement('input'),\n            String(`Current count:${count}`),\n            ...Array.from({ length: count }, () => {\n                return createElement('img', {\n                    attrs: {\n                        src: 'https://media.giphy.com/media/4Zo41lhzKt6iZ8xff9/giphy.gif'\n                    }\n                })\n            })\n        ]\n    }\n)\n\n\nlet count = 1;\n// 创建VDOM\nlet vApp = createApp(count);\n// 渲染VDOM\nconst $app = render(vApp);\n// 挂载VDOM\nlet $rootEl = mount($app, document.getElementById('app'));\n\nsetInterval(() => {\n    count++; //数据发生变化\n    const vNewApp = createApp(count); // 重新创建一个新的VDOM\n    const patch = diff(vApp, vNewApp); // 比较新旧VDOM之间的差别,并返回更新DOM的函数\n    patch($rootEl); //  更新DOM\n    vApp = vNewApp; // 重新替换\n}, 1000);\n\n```\n\n\n![效果动态](https://gitee.com/trueLoving/cdn/raw/master/img/Virtual DOM.gif)\n","source":"_posts/笔记/Virtual DOM.md","raw":"---\ntitle: Virtual DOM\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 笔记\ntags:\n - 笔记\nkeywords: 笔记\ndate: 2020-06-26\ncomments: false\ndescription: Virtual DOM\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Virtual_DOM_bg.jpg\n---\n\n\n## 前言\n\nVirtual DOM,虚拟DOM,其实是对页面真实DOM的一种简单描述对象,我们可以通过这个虚拟DOM,使用浏览器提供的API(document.createElement()...等)来创建出与其对应的真实DOM。\n\n这样,我们就可以通过操作虚拟DOM,来间接操作DOM,而由于虚拟DOM的对象比真实DOM的对象要小得多,这样我们就可以降低在操作DOM对象上的一些开销,以此来提升页面的性能。\n\n像目前的React,Vue框架都借助了虚拟DOM来完成对真实DOM的操作,将DOM树写到内存中,然后在内存中完成对DOM树的操作(插入,修改,删除,添加.....),最后当完成了对DOM树的所有操作后,一次性将DOM树插回到页面中,这样就大大减少了浏览器页面的重绘工作量,提升了网页性能。\n\n我们其实可以使用js来创建自己的虚拟DOM,`虚拟DOM的本质其实就是一个JS对象`。\n\n所以,定义一个属于自己的虚拟DOM,可以分为以下几步\n1. 创建vNode\n2. 渲染vNode\n3. 挂载vNode\n4. 更新vNode\n\n下面就是将如何通过使用JS代码来实现自己的虚拟DOM\n\n## 确定虚拟DOM对象\n\n首先,我们要确定虚拟DOM对象的属性名和属性值,在这里,虚拟DOM对象的属性名和属性值如下\n```js\nclass VDOM{\n    tagName='tagName', // 类型:字符串   含义:VDOM对应DOM的标签名称\n    attrs:{},          // 类型:对象     含义:VDOM对于DOM的属性节点\n    children:[]        // 类型:数组     含义:该VDOM下的子VDOM对象\n}\n```\n\n## 创建虚拟DOM对象\n\n我们需要一个函数,只要我们传入相关参数,就会帮我们生成相对应的VDOM对象\n```js\n/**\n * \n *  @tagName    {String} VDOM的标签名称\n *  @attrs      {Object} VDOM的属性节点\n *  @childrem   {Array}  VDOM的后代VDOM\n */\nfunction createElement(tagName,{attrs={},children=[]}={}){\n    return{\n        tagName,\n        attrs,\n        children\n    }\n}\n```\n\n## 渲染虚拟DOM对象\n\n当我们手中有一个虚拟DOM时,我们需要一个函数来帮助我们将该虚拟DOM转换为真实DOM\n```js\n// 如果VDOM为\nfunction renderElement({tagName,attrs,children}){\n\n    const $el = document.createElement(tagName);\n\n    // set attribute\n    for(const [k,v] of attrs){\n        $el.setAttribute(k,v);\n    }\n\n    // render child\n    // 当存在子VDOM时,递归调用render方法,然后将render方法的返回值添加到$el的后代中\n    for(const child of children){\n        const $child = render(child);\n        $el.appendChild($child);\n    }\n\n    return $el;\n}\n\nfunction render(VDOM){\n    // 如果VDOM是字符串,说明此VDOM为文本节点\n    if(typeof VDOM === \"string\"){\n        return document.createTextContent(VDOM);\n    }\n    return renderElement(VDOM);\n}\n\n```\n\n## 挂载虚拟DOM对象\n\n现在,我们手中有真实DOM,然后就需要将其挂载在我们指定的DOM后面\n```js\n/**\n * @$node   {DOM} 由VDOM得到的DOM\n * @target  {DOM} 要被插入$node的父元素DOM\n */\nfunction mount($node,$target){\n    $target.replaceWith($node);\n    return $node;\n}\n```\n\n## 更新虚拟DOM对象\n当我们去更新，插入或者删除一个VDOM时,我们需要一个方法来帮助我们以最小的代价来更新VDOM树对应的DOM树,这个方法就是diff算法\n\ndiff算法的可以分为以下三个部分\n1. 比较传入的节点(diff函数)\n2. 比较传入节点的属性(diffAttrs函数)\n3. 比较节点的子节点(diffChildren函数)\n\n\n#### diff函数实现\n\n对于diff函数,需要考虑四种情况\n1. 传入的新节点为undefined,是因为该节点是要被删除的节点，所以回传的回调函数patch要调用Node.remove()方法\n2. 传入的旧节点或者新节点可以是字符串,此时可以直接比较新旧两个节点,如果不一样,则用新节点取代旧节点\n3. 旧节点与新节点的标签不一样,则用新节点去取代旧节点\n4. 旧节点与新节点的标签一样，则继续往下比较标签上的属性节点以及其子节点\n\n`函数实现`\n```js\nconst diff = (vOldNode,vNewNode) =>{\n    if(vNewNode===undefined){\n        return ($node)=>{\n            $node.remove();\n            return undefined;\n        }\n    }\n    if(typeof vOldNode === \"string\" || typeof vNewNode === \"string\"){\n        if(vNewNode!==vOldNode){\n            return ($node)=>{\n                const $newNode = render(vNewNode);\n                return mount($newNode,$node);\n            }\n        }\n    }\n    if(vOldNode.tagName!==vNewNode.tagName){\n        return ($node)=>{\n            const $newNode = render(vNewNode);\n            return mount($newNode,$node);\n        };\n    }\n    \n    // 比较属性节点,diffAttrs后面会实现\n    const patchAttrs = diffAttrs(vOldNode.attrs.vNewNode.attrs);\n    // 比较其子节点,diffChildren后面会实现\n    const pathChildren = diffChildren(vOldNode.children,vNewOlde,children);\n    return ($node)=>{\n        patchAttrs($node);\n        patchChildren($node.children);\n        return $node;\n    }\n}\n```\n\n#### diffAttrs函数实现\n\ndiffAttrs函数主要是在标签上设置属性和删除属性\n\n函数patches用于存储属性变动的patch函数\n\n比较完所有的属性节点后,会在diff函数呼叫patchAttrs($node),将节点传进来并批量更新标签上的属性\n\n`函数实现`\n```js\nconst diffAttrs = (oldAttrs,newAttrs)=>{\n\n    // 更新节点的回调函数\n    const patches = [];\n\n    // 遍历新的节点属性\n    for(const [k,v] of Object.entries(newAttrs)){\n        patches.push($node=>{\n            $node.setAttribute(k,v);\n            return $node;\n        })\n    }\n\n    // 遍历旧的节点属性\n    for(const key of oldAttrs){\n        // 如果一个新的属性节点，在旧的存在，但是在新的不存在，则$node需要移除该属性节点\n        if(!(key in newAttrs)){\n            patches.push($node=>{\n                $node.removeAttribute(key);\n                return $node;\n            })\n        }\n    }\n\n    // 返回可调用用于更新属性节点的回调函数\n    return ($node)=>{\n        patches.forEach(patch=>{\n            patch($node);\n        })\n    }\n\n}\n```\n\n#### diffChildren函数实现\n\ndiffChildren的任务就是更新变得的子节点/删除子节点/插入新的子节点/.....\n\n\n`函数实现`\n```js\n\n\nconst zip = (xs,ys) =>{\n    cosnt zipped = [];\n    for(let i=0;i<Math.min(xs.length,ys.length);i++){\n        zipped.push([xs[i],ys[i]]);\n    }\n    return zipped;\n}\n\nconst diffChildren = (oldVChildren,newVChildren) =>{\n\n    const childPatches = [];\n    \n\n    for(const [oldChild,newChild] of zip(oldVChildren,newVChildren)){\n        childPatches.push(diff(oldChild,newChild));\n    }\n\n\n    const additionalPatches = [];\n    newVChildren.slice(oldVChildren.length).forEach(additionalVChild=>{\n        additionalPatches.push(($node)=>{\n            $node.appendChild(render(additionalVChild));\n            return $node;\n        });\n    });\n\n    return ($node)=>{\n        for(let i=childPatches.length-1;i>=0;i--){\n            const $child = $node.children[i];\n            const patch = childPatches[i];\n            patch($child);\n        }\n        additionalPatches.forEach(patch=>{\n            patch($node);\n        })\n        return $node;\n    }\n\n}\n\n```\n\n## 测试虚拟DOM对象\n\n`main.js`\n```js\n// 引入相关函数\nimport createElement from \"./vdom/createElement\";\nimport render from \"./vdom/render\";\nimport mount from \"./vdom/mount\";\nimport diff from './vdom/diff';\n\nconst createApp = (count) => createElement(\n    'div',\n    {\n        attrs: {\n            dataCount: count\n        },\n        children: [\n            createElement('input'),\n            String(`Current count:${count}`),\n            ...Array.from({ length: count }, () => {\n                return createElement('img', {\n                    attrs: {\n                        src: 'https://media.giphy.com/media/4Zo41lhzKt6iZ8xff9/giphy.gif'\n                    }\n                })\n            })\n        ]\n    }\n)\n\n\nlet count = 1;\n// 创建VDOM\nlet vApp = createApp(count);\n// 渲染VDOM\nconst $app = render(vApp);\n// 挂载VDOM\nlet $rootEl = mount($app, document.getElementById('app'));\n\nsetInterval(() => {\n    count++; //数据发生变化\n    const vNewApp = createApp(count); // 重新创建一个新的VDOM\n    const patch = diff(vApp, vNewApp); // 比较新旧VDOM之间的差别,并返回更新DOM的函数\n    patch($rootEl); //  更新DOM\n    vApp = vNewApp; // 重新替换\n}, 1000);\n\n```\n\n\n![效果动态](https://gitee.com/trueLoving/cdn/raw/master/img/Virtual DOM.gif)\n","slug":"笔记/Virtual DOM","published":1,"updated":"2023-05-12T23:28:10.998Z","layout":"post","link":"","_id":"clhws1t2g00092h17djwh8bs3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Virtual DOM,虚拟DOM,其实是对页面真实DOM的一种简单描述对象,我们可以通过这个虚拟DOM,使用浏览器提供的API(document.createElement()…等)来创建出与其对应的真实DOM。</p>\n<p>这样,我们就可以通过操作虚拟DOM,来间接操作DOM,而由于虚拟DOM的对象比真实DOM的对象要小得多,这样我们就可以降低在操作DOM对象上的一些开销,以此来提升页面的性能。</p>\n<p>像目前的React,Vue框架都借助了虚拟DOM来完成对真实DOM的操作,将DOM树写到内存中,然后在内存中完成对DOM树的操作(插入,修改,删除,添加…..),最后当完成了对DOM树的所有操作后,一次性将DOM树插回到页面中,这样就大大减少了浏览器页面的重绘工作量,提升了网页性能。</p>\n<p>我们其实可以使用js来创建自己的虚拟DOM,<code>虚拟DOM的本质其实就是一个JS对象</code>。</p>\n<p>所以,定义一个属于自己的虚拟DOM,可以分为以下几步</p>\n<ol>\n<li>创建vNode</li>\n<li>渲染vNode</li>\n<li>挂载vNode</li>\n<li>更新vNode</li>\n</ol>\n<p>下面就是将如何通过使用JS代码来实现自己的虚拟DOM</p>\n<h2 id=\"确定虚拟DOM对象\"><a href=\"#确定虚拟DOM对象\" class=\"headerlink\" title=\"确定虚拟DOM对象\"></a>确定虚拟DOM对象</h2><p>首先,我们要确定虚拟DOM对象的属性名和属性值,在这里,虚拟DOM对象的属性名和属性值如下</p>\n<pre><code class=\"js\">class VDOM&#123;\n    tagName=&#39;tagName&#39;, // 类型:字符串   含义:VDOM对应DOM的标签名称\n    attrs:&#123;&#125;,          // 类型:对象     含义:VDOM对于DOM的属性节点\n    children:[]        // 类型:数组     含义:该VDOM下的子VDOM对象\n&#125;\n</code></pre>\n<h2 id=\"创建虚拟DOM对象\"><a href=\"#创建虚拟DOM对象\" class=\"headerlink\" title=\"创建虚拟DOM对象\"></a>创建虚拟DOM对象</h2><p>我们需要一个函数,只要我们传入相关参数,就会帮我们生成相对应的VDOM对象</p>\n<pre><code class=\"js\">/**\n * \n *  @tagName    &#123;String&#125; VDOM的标签名称\n *  @attrs      &#123;Object&#125; VDOM的属性节点\n *  @childrem   &#123;Array&#125;  VDOM的后代VDOM\n */\nfunction createElement(tagName,&#123;attrs=&#123;&#125;,children=[]&#125;=&#123;&#125;)&#123;\n    return&#123;\n        tagName,\n        attrs,\n        children\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"渲染虚拟DOM对象\"><a href=\"#渲染虚拟DOM对象\" class=\"headerlink\" title=\"渲染虚拟DOM对象\"></a>渲染虚拟DOM对象</h2><p>当我们手中有一个虚拟DOM时,我们需要一个函数来帮助我们将该虚拟DOM转换为真实DOM</p>\n<pre><code class=\"js\">// 如果VDOM为\nfunction renderElement(&#123;tagName,attrs,children&#125;)&#123;\n\n    const $el = document.createElement(tagName);\n\n    // set attribute\n    for(const [k,v] of attrs)&#123;\n        $el.setAttribute(k,v);\n    &#125;\n\n    // render child\n    // 当存在子VDOM时,递归调用render方法,然后将render方法的返回值添加到$el的后代中\n    for(const child of children)&#123;\n        const $child = render(child);\n        $el.appendChild($child);\n    &#125;\n\n    return $el;\n&#125;\n\nfunction render(VDOM)&#123;\n    // 如果VDOM是字符串,说明此VDOM为文本节点\n    if(typeof VDOM === &quot;string&quot;)&#123;\n        return document.createTextContent(VDOM);\n    &#125;\n    return renderElement(VDOM);\n&#125;\n</code></pre>\n<h2 id=\"挂载虚拟DOM对象\"><a href=\"#挂载虚拟DOM对象\" class=\"headerlink\" title=\"挂载虚拟DOM对象\"></a>挂载虚拟DOM对象</h2><p>现在,我们手中有真实DOM,然后就需要将其挂载在我们指定的DOM后面</p>\n<pre><code class=\"js\">/**\n * @$node   &#123;DOM&#125; 由VDOM得到的DOM\n * @target  &#123;DOM&#125; 要被插入$node的父元素DOM\n */\nfunction mount($node,$target)&#123;\n    $target.replaceWith($node);\n    return $node;\n&#125;\n</code></pre>\n<h2 id=\"更新虚拟DOM对象\"><a href=\"#更新虚拟DOM对象\" class=\"headerlink\" title=\"更新虚拟DOM对象\"></a>更新虚拟DOM对象</h2><p>当我们去更新，插入或者删除一个VDOM时,我们需要一个方法来帮助我们以最小的代价来更新VDOM树对应的DOM树,这个方法就是diff算法</p>\n<p>diff算法的可以分为以下三个部分</p>\n<ol>\n<li>比较传入的节点(diff函数)</li>\n<li>比较传入节点的属性(diffAttrs函数)</li>\n<li>比较节点的子节点(diffChildren函数)</li>\n</ol>\n<h4 id=\"diff函数实现\"><a href=\"#diff函数实现\" class=\"headerlink\" title=\"diff函数实现\"></a>diff函数实现</h4><p>对于diff函数,需要考虑四种情况</p>\n<ol>\n<li>传入的新节点为undefined,是因为该节点是要被删除的节点，所以回传的回调函数patch要调用Node.remove()方法</li>\n<li>传入的旧节点或者新节点可以是字符串,此时可以直接比较新旧两个节点,如果不一样,则用新节点取代旧节点</li>\n<li>旧节点与新节点的标签不一样,则用新节点去取代旧节点</li>\n<li>旧节点与新节点的标签一样，则继续往下比较标签上的属性节点以及其子节点</li>\n</ol>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">const diff = (vOldNode,vNewNode) =&gt;&#123;\n    if(vNewNode===undefined)&#123;\n        return ($node)=&gt;&#123;\n            $node.remove();\n            return undefined;\n        &#125;\n    &#125;\n    if(typeof vOldNode === &quot;string&quot; || typeof vNewNode === &quot;string&quot;)&#123;\n        if(vNewNode!==vOldNode)&#123;\n            return ($node)=&gt;&#123;\n                const $newNode = render(vNewNode);\n                return mount($newNode,$node);\n            &#125;\n        &#125;\n    &#125;\n    if(vOldNode.tagName!==vNewNode.tagName)&#123;\n        return ($node)=&gt;&#123;\n            const $newNode = render(vNewNode);\n            return mount($newNode,$node);\n        &#125;;\n    &#125;\n    \n    // 比较属性节点,diffAttrs后面会实现\n    const patchAttrs = diffAttrs(vOldNode.attrs.vNewNode.attrs);\n    // 比较其子节点,diffChildren后面会实现\n    const pathChildren = diffChildren(vOldNode.children,vNewOlde,children);\n    return ($node)=&gt;&#123;\n        patchAttrs($node);\n        patchChildren($node.children);\n        return $node;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"diffAttrs函数实现\"><a href=\"#diffAttrs函数实现\" class=\"headerlink\" title=\"diffAttrs函数实现\"></a>diffAttrs函数实现</h4><p>diffAttrs函数主要是在标签上设置属性和删除属性</p>\n<p>函数patches用于存储属性变动的patch函数</p>\n<p>比较完所有的属性节点后,会在diff函数呼叫patchAttrs($node),将节点传进来并批量更新标签上的属性</p>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">const diffAttrs = (oldAttrs,newAttrs)=&gt;&#123;\n\n    // 更新节点的回调函数\n    const patches = [];\n\n    // 遍历新的节点属性\n    for(const [k,v] of Object.entries(newAttrs))&#123;\n        patches.push($node=&gt;&#123;\n            $node.setAttribute(k,v);\n            return $node;\n        &#125;)\n    &#125;\n\n    // 遍历旧的节点属性\n    for(const key of oldAttrs)&#123;\n        // 如果一个新的属性节点，在旧的存在，但是在新的不存在，则$node需要移除该属性节点\n        if(!(key in newAttrs))&#123;\n            patches.push($node=&gt;&#123;\n                $node.removeAttribute(key);\n                return $node;\n            &#125;)\n        &#125;\n    &#125;\n\n    // 返回可调用用于更新属性节点的回调函数\n    return ($node)=&gt;&#123;\n        patches.forEach(patch=&gt;&#123;\n            patch($node);\n        &#125;)\n    &#125;\n\n&#125;\n</code></pre>\n<h4 id=\"diffChildren函数实现\"><a href=\"#diffChildren函数实现\" class=\"headerlink\" title=\"diffChildren函数实现\"></a>diffChildren函数实现</h4><p>diffChildren的任务就是更新变得的子节点&#x2F;删除子节点&#x2F;插入新的子节点&#x2F;…..</p>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">\n\nconst zip = (xs,ys) =&gt;&#123;\n    cosnt zipped = [];\n    for(let i=0;i&lt;Math.min(xs.length,ys.length);i++)&#123;\n        zipped.push([xs[i],ys[i]]);\n    &#125;\n    return zipped;\n&#125;\n\nconst diffChildren = (oldVChildren,newVChildren) =&gt;&#123;\n\n    const childPatches = [];\n    \n\n    for(const [oldChild,newChild] of zip(oldVChildren,newVChildren))&#123;\n        childPatches.push(diff(oldChild,newChild));\n    &#125;\n\n\n    const additionalPatches = [];\n    newVChildren.slice(oldVChildren.length).forEach(additionalVChild=&gt;&#123;\n        additionalPatches.push(($node)=&gt;&#123;\n            $node.appendChild(render(additionalVChild));\n            return $node;\n        &#125;);\n    &#125;);\n\n    return ($node)=&gt;&#123;\n        for(let i=childPatches.length-1;i&gt;=0;i--)&#123;\n            const $child = $node.children[i];\n            const patch = childPatches[i];\n            patch($child);\n        &#125;\n        additionalPatches.forEach(patch=&gt;&#123;\n            patch($node);\n        &#125;)\n        return $node;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"测试虚拟DOM对象\"><a href=\"#测试虚拟DOM对象\" class=\"headerlink\" title=\"测试虚拟DOM对象\"></a>测试虚拟DOM对象</h2><p><code>main.js</code></p>\n<pre><code class=\"js\">// 引入相关函数\nimport createElement from &quot;./vdom/createElement&quot;;\nimport render from &quot;./vdom/render&quot;;\nimport mount from &quot;./vdom/mount&quot;;\nimport diff from &#39;./vdom/diff&#39;;\n\nconst createApp = (count) =&gt; createElement(\n    &#39;div&#39;,\n    &#123;\n        attrs: &#123;\n            dataCount: count\n        &#125;,\n        children: [\n            createElement(&#39;input&#39;),\n            String(`Current count:$&#123;count&#125;`),\n            ...Array.from(&#123; length: count &#125;, () =&gt; &#123;\n                return createElement(&#39;img&#39;, &#123;\n                    attrs: &#123;\n                        src: &#39;https://media.giphy.com/media/4Zo41lhzKt6iZ8xff9/giphy.gif&#39;\n                    &#125;\n                &#125;)\n            &#125;)\n        ]\n    &#125;\n)\n\n\nlet count = 1;\n// 创建VDOM\nlet vApp = createApp(count);\n// 渲染VDOM\nconst $app = render(vApp);\n// 挂载VDOM\nlet $rootEl = mount($app, document.getElementById(&#39;app&#39;));\n\nsetInterval(() =&gt; &#123;\n    count++; //数据发生变化\n    const vNewApp = createApp(count); // 重新创建一个新的VDOM\n    const patch = diff(vApp, vNewApp); // 比较新旧VDOM之间的差别,并返回更新DOM的函数\n    patch($rootEl); //  更新DOM\n    vApp = vNewApp; // 重新替换\n&#125;, 1000);\n</code></pre>\n<p>![效果动态](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Virtual\">https://gitee.com/trueLoving/cdn/raw/master/img/Virtual</a> DOM.gif)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Virtual DOM,虚拟DOM,其实是对页面真实DOM的一种简单描述对象,我们可以通过这个虚拟DOM,使用浏览器提供的API(document.createElement()…等)来创建出与其对应的真实DOM。</p>\n<p>这样,我们就可以通过操作虚拟DOM,来间接操作DOM,而由于虚拟DOM的对象比真实DOM的对象要小得多,这样我们就可以降低在操作DOM对象上的一些开销,以此来提升页面的性能。</p>\n<p>像目前的React,Vue框架都借助了虚拟DOM来完成对真实DOM的操作,将DOM树写到内存中,然后在内存中完成对DOM树的操作(插入,修改,删除,添加…..),最后当完成了对DOM树的所有操作后,一次性将DOM树插回到页面中,这样就大大减少了浏览器页面的重绘工作量,提升了网页性能。</p>\n<p>我们其实可以使用js来创建自己的虚拟DOM,<code>虚拟DOM的本质其实就是一个JS对象</code>。</p>\n<p>所以,定义一个属于自己的虚拟DOM,可以分为以下几步</p>\n<ol>\n<li>创建vNode</li>\n<li>渲染vNode</li>\n<li>挂载vNode</li>\n<li>更新vNode</li>\n</ol>\n<p>下面就是将如何通过使用JS代码来实现自己的虚拟DOM</p>\n<h2 id=\"确定虚拟DOM对象\"><a href=\"#确定虚拟DOM对象\" class=\"headerlink\" title=\"确定虚拟DOM对象\"></a>确定虚拟DOM对象</h2><p>首先,我们要确定虚拟DOM对象的属性名和属性值,在这里,虚拟DOM对象的属性名和属性值如下</p>\n<pre><code class=\"js\">class VDOM&#123;\n    tagName=&#39;tagName&#39;, // 类型:字符串   含义:VDOM对应DOM的标签名称\n    attrs:&#123;&#125;,          // 类型:对象     含义:VDOM对于DOM的属性节点\n    children:[]        // 类型:数组     含义:该VDOM下的子VDOM对象\n&#125;\n</code></pre>\n<h2 id=\"创建虚拟DOM对象\"><a href=\"#创建虚拟DOM对象\" class=\"headerlink\" title=\"创建虚拟DOM对象\"></a>创建虚拟DOM对象</h2><p>我们需要一个函数,只要我们传入相关参数,就会帮我们生成相对应的VDOM对象</p>\n<pre><code class=\"js\">/**\n * \n *  @tagName    &#123;String&#125; VDOM的标签名称\n *  @attrs      &#123;Object&#125; VDOM的属性节点\n *  @childrem   &#123;Array&#125;  VDOM的后代VDOM\n */\nfunction createElement(tagName,&#123;attrs=&#123;&#125;,children=[]&#125;=&#123;&#125;)&#123;\n    return&#123;\n        tagName,\n        attrs,\n        children\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"渲染虚拟DOM对象\"><a href=\"#渲染虚拟DOM对象\" class=\"headerlink\" title=\"渲染虚拟DOM对象\"></a>渲染虚拟DOM对象</h2><p>当我们手中有一个虚拟DOM时,我们需要一个函数来帮助我们将该虚拟DOM转换为真实DOM</p>\n<pre><code class=\"js\">// 如果VDOM为\nfunction renderElement(&#123;tagName,attrs,children&#125;)&#123;\n\n    const $el = document.createElement(tagName);\n\n    // set attribute\n    for(const [k,v] of attrs)&#123;\n        $el.setAttribute(k,v);\n    &#125;\n\n    // render child\n    // 当存在子VDOM时,递归调用render方法,然后将render方法的返回值添加到$el的后代中\n    for(const child of children)&#123;\n        const $child = render(child);\n        $el.appendChild($child);\n    &#125;\n\n    return $el;\n&#125;\n\nfunction render(VDOM)&#123;\n    // 如果VDOM是字符串,说明此VDOM为文本节点\n    if(typeof VDOM === &quot;string&quot;)&#123;\n        return document.createTextContent(VDOM);\n    &#125;\n    return renderElement(VDOM);\n&#125;\n</code></pre>\n<h2 id=\"挂载虚拟DOM对象\"><a href=\"#挂载虚拟DOM对象\" class=\"headerlink\" title=\"挂载虚拟DOM对象\"></a>挂载虚拟DOM对象</h2><p>现在,我们手中有真实DOM,然后就需要将其挂载在我们指定的DOM后面</p>\n<pre><code class=\"js\">/**\n * @$node   &#123;DOM&#125; 由VDOM得到的DOM\n * @target  &#123;DOM&#125; 要被插入$node的父元素DOM\n */\nfunction mount($node,$target)&#123;\n    $target.replaceWith($node);\n    return $node;\n&#125;\n</code></pre>\n<h2 id=\"更新虚拟DOM对象\"><a href=\"#更新虚拟DOM对象\" class=\"headerlink\" title=\"更新虚拟DOM对象\"></a>更新虚拟DOM对象</h2><p>当我们去更新，插入或者删除一个VDOM时,我们需要一个方法来帮助我们以最小的代价来更新VDOM树对应的DOM树,这个方法就是diff算法</p>\n<p>diff算法的可以分为以下三个部分</p>\n<ol>\n<li>比较传入的节点(diff函数)</li>\n<li>比较传入节点的属性(diffAttrs函数)</li>\n<li>比较节点的子节点(diffChildren函数)</li>\n</ol>\n<h4 id=\"diff函数实现\"><a href=\"#diff函数实现\" class=\"headerlink\" title=\"diff函数实现\"></a>diff函数实现</h4><p>对于diff函数,需要考虑四种情况</p>\n<ol>\n<li>传入的新节点为undefined,是因为该节点是要被删除的节点，所以回传的回调函数patch要调用Node.remove()方法</li>\n<li>传入的旧节点或者新节点可以是字符串,此时可以直接比较新旧两个节点,如果不一样,则用新节点取代旧节点</li>\n<li>旧节点与新节点的标签不一样,则用新节点去取代旧节点</li>\n<li>旧节点与新节点的标签一样，则继续往下比较标签上的属性节点以及其子节点</li>\n</ol>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">const diff = (vOldNode,vNewNode) =&gt;&#123;\n    if(vNewNode===undefined)&#123;\n        return ($node)=&gt;&#123;\n            $node.remove();\n            return undefined;\n        &#125;\n    &#125;\n    if(typeof vOldNode === &quot;string&quot; || typeof vNewNode === &quot;string&quot;)&#123;\n        if(vNewNode!==vOldNode)&#123;\n            return ($node)=&gt;&#123;\n                const $newNode = render(vNewNode);\n                return mount($newNode,$node);\n            &#125;\n        &#125;\n    &#125;\n    if(vOldNode.tagName!==vNewNode.tagName)&#123;\n        return ($node)=&gt;&#123;\n            const $newNode = render(vNewNode);\n            return mount($newNode,$node);\n        &#125;;\n    &#125;\n    \n    // 比较属性节点,diffAttrs后面会实现\n    const patchAttrs = diffAttrs(vOldNode.attrs.vNewNode.attrs);\n    // 比较其子节点,diffChildren后面会实现\n    const pathChildren = diffChildren(vOldNode.children,vNewOlde,children);\n    return ($node)=&gt;&#123;\n        patchAttrs($node);\n        patchChildren($node.children);\n        return $node;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"diffAttrs函数实现\"><a href=\"#diffAttrs函数实现\" class=\"headerlink\" title=\"diffAttrs函数实现\"></a>diffAttrs函数实现</h4><p>diffAttrs函数主要是在标签上设置属性和删除属性</p>\n<p>函数patches用于存储属性变动的patch函数</p>\n<p>比较完所有的属性节点后,会在diff函数呼叫patchAttrs($node),将节点传进来并批量更新标签上的属性</p>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">const diffAttrs = (oldAttrs,newAttrs)=&gt;&#123;\n\n    // 更新节点的回调函数\n    const patches = [];\n\n    // 遍历新的节点属性\n    for(const [k,v] of Object.entries(newAttrs))&#123;\n        patches.push($node=&gt;&#123;\n            $node.setAttribute(k,v);\n            return $node;\n        &#125;)\n    &#125;\n\n    // 遍历旧的节点属性\n    for(const key of oldAttrs)&#123;\n        // 如果一个新的属性节点，在旧的存在，但是在新的不存在，则$node需要移除该属性节点\n        if(!(key in newAttrs))&#123;\n            patches.push($node=&gt;&#123;\n                $node.removeAttribute(key);\n                return $node;\n            &#125;)\n        &#125;\n    &#125;\n\n    // 返回可调用用于更新属性节点的回调函数\n    return ($node)=&gt;&#123;\n        patches.forEach(patch=&gt;&#123;\n            patch($node);\n        &#125;)\n    &#125;\n\n&#125;\n</code></pre>\n<h4 id=\"diffChildren函数实现\"><a href=\"#diffChildren函数实现\" class=\"headerlink\" title=\"diffChildren函数实现\"></a>diffChildren函数实现</h4><p>diffChildren的任务就是更新变得的子节点&#x2F;删除子节点&#x2F;插入新的子节点&#x2F;…..</p>\n<p><code>函数实现</code></p>\n<pre><code class=\"js\">\n\nconst zip = (xs,ys) =&gt;&#123;\n    cosnt zipped = [];\n    for(let i=0;i&lt;Math.min(xs.length,ys.length);i++)&#123;\n        zipped.push([xs[i],ys[i]]);\n    &#125;\n    return zipped;\n&#125;\n\nconst diffChildren = (oldVChildren,newVChildren) =&gt;&#123;\n\n    const childPatches = [];\n    \n\n    for(const [oldChild,newChild] of zip(oldVChildren,newVChildren))&#123;\n        childPatches.push(diff(oldChild,newChild));\n    &#125;\n\n\n    const additionalPatches = [];\n    newVChildren.slice(oldVChildren.length).forEach(additionalVChild=&gt;&#123;\n        additionalPatches.push(($node)=&gt;&#123;\n            $node.appendChild(render(additionalVChild));\n            return $node;\n        &#125;);\n    &#125;);\n\n    return ($node)=&gt;&#123;\n        for(let i=childPatches.length-1;i&gt;=0;i--)&#123;\n            const $child = $node.children[i];\n            const patch = childPatches[i];\n            patch($child);\n        &#125;\n        additionalPatches.forEach(patch=&gt;&#123;\n            patch($node);\n        &#125;)\n        return $node;\n    &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"测试虚拟DOM对象\"><a href=\"#测试虚拟DOM对象\" class=\"headerlink\" title=\"测试虚拟DOM对象\"></a>测试虚拟DOM对象</h2><p><code>main.js</code></p>\n<pre><code class=\"js\">// 引入相关函数\nimport createElement from &quot;./vdom/createElement&quot;;\nimport render from &quot;./vdom/render&quot;;\nimport mount from &quot;./vdom/mount&quot;;\nimport diff from &#39;./vdom/diff&#39;;\n\nconst createApp = (count) =&gt; createElement(\n    &#39;div&#39;,\n    &#123;\n        attrs: &#123;\n            dataCount: count\n        &#125;,\n        children: [\n            createElement(&#39;input&#39;),\n            String(`Current count:$&#123;count&#125;`),\n            ...Array.from(&#123; length: count &#125;, () =&gt; &#123;\n                return createElement(&#39;img&#39;, &#123;\n                    attrs: &#123;\n                        src: &#39;https://media.giphy.com/media/4Zo41lhzKt6iZ8xff9/giphy.gif&#39;\n                    &#125;\n                &#125;)\n            &#125;)\n        ]\n    &#125;\n)\n\n\nlet count = 1;\n// 创建VDOM\nlet vApp = createApp(count);\n// 渲染VDOM\nconst $app = render(vApp);\n// 挂载VDOM\nlet $rootEl = mount($app, document.getElementById(&#39;app&#39;));\n\nsetInterval(() =&gt; &#123;\n    count++; //数据发生变化\n    const vNewApp = createApp(count); // 重新创建一个新的VDOM\n    const patch = diff(vApp, vNewApp); // 比较新旧VDOM之间的差别,并返回更新DOM的函数\n    patch($rootEl); //  更新DOM\n    vApp = vNewApp; // 重新替换\n&#125;, 1000);\n</code></pre>\n<p>![效果动态](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Virtual\">https://gitee.com/trueLoving/cdn/raw/master/img/Virtual</a> DOM.gif)</p>\n"},{"title":"XHR的基本认识","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"笔记","date":"2020-05-24T16:00:00.000Z","comments":0,"description":"XHR的基本认识","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识_bg.jpg"],"_content":"\n## 文章的思维导图\n\n\n![文章思维导图](https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识 01.jpg)\n\n\n\n## what\n\nxhr，全称XMLHttpRequest，是一种创建ajax的JavaScript API。该对象的方法提供了在浏览器和服务器之间发送请求的能力\n\n我们通过xhr可以在不刷新页面的情况下请求特定的url,获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容\n\n## how\n\n一般我们使用xhr要通过浏览器内置的XMLHttpRequest构造函数来生成一个xhr实例对象，然后我们通过调用该实例对象的属性和方法来完成ajax请求\n\n### 构造函数\n\n- XMLHttpRequest()\n\n  该构造函数用于初始化一个XMLHttpRequest实例对象\n\n### 实例属性\n\n- status | 只读\n\n  请求的响应状态码\n\n- statusText | 只读\n\n  请求的响应状态描述文本\n\n- readyState\n\n  请求的状态码\n\n- onreadystatechange\n\n  当请求状态发送变化时会触发的回调函数\n  该属性名的值为一个函数\n\n- responseType\n\n  一个用于定义响应类型的枚举值\n\n- response | 只读\n\n  返回请求后的响应数据，可以是二进制文本，字符串或者文本等....\n  具体类型由responseType决定\n\n- timeout\n\n  设置请求的最大时间\n\n- ontimeout\n\n  若请求超时，所会触发的回调函数\n\n- onerror\n\n  若请求出现异常，所会触发的回调函数\n\n### 实例方法\n\n- open(method,url,[async])\n\n  初始化一个请求\n  参数类型为(string,string,boolean)\n  参数含义为(请求方式,请求路径,是否为异步)\n\n- send(data)\n\n  发送请求\n  参数为请求实体中的参数\n  \n  若请求实体的数据为json格式,那么需要手动将参数从对象转换为json\n  \n  方法:JSON.stringify(data)\n\n- abort()\n\n  中断请求\n\n- getResponseHeader(name)\n\n  根据name获取响应头对应的值\n\n- getAllResponseHeaders()\n\n  以字符串的形式返回所有用 CRLF 分隔的响应头，如果没有收到响应，则返回 null\n\n- setRequestHeaders(name,value)\n\n  设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法\n\n## xhr的简单封装\n\n要求:\n1. 封装一个函数，函数的返回值为promise,成功的结果为response,异常的结果为error\n2. 能处理多种类型的请求:GEI/POST/PUT/DELETE\n3. 函数的参数为一个配置对象\n\n\n代码\n\n```js\nfunction axios({\n    url,\n    method = 'GET',\n    params = {},\n    data = {}\n}) {\n    return new Promise((resolve, reject) => {\n        // 处理method\n        method = method.toUpperCase();\n        \n        // 处理query参数(拼接到url上)\n        let queryString = '';\n        Object.keys(params).forEach(key => {\n            queryString += `${key}=${params[key]}&`;\n        })\n        if (queryString) {\n            // 去除最后的&\n            queryString = queryString.substring(0, queryString.length - 1);\n            // 接到url\n            url += '?' + queryString;\n        }\n\n\n        // 1. 执行异步任务,进行ajax请求\n        // 创建xhr对象\n        const request = new XMLHttpRequest();\n        // 打开连接(初始化请求)\n        request.open(method, url, true);\n        // 发送请求\n        if (method === 'GET'||method==='DELETE') {\n            request.send(null);\n        } else if(method==='POST'||method==='PUT'){\n            // 告诉服务器请求数据的格式为json格式\n            request.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n            request.send(JSON.stringify(data));\n        }\n\n        // 绑定状态改变的监听\n        request.onreadystatechange = function () {\n            // 如果请求没有完成，直接结束\n            if (request.readyState !== 4) {\n                return\n            }\n            // 如果响应状态码在[200,300)之间代表成功。否则失败\n            const { status, statusText } = request;\n            // 2.1 如果请求成功，调用resolve\n            if (status >= 200 && status < 299) {\n                // 准备结果数据对象response\n                const response = {\n                    data: JSON.parse(request.response),\n                    status,\n                    statusText\n                }\n                resolve(response)\n            } else {  // 2.2 如果请求失败，调用reject\n                reject(new Error(`request error status is ${status}`))\n            }\n        }\n    })\n\n}\n```","source":"_posts/笔记/XHR的基本认识.md","raw":"---\ntitle: XHR的基本认识\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 笔记\ntags:\n - 笔记\nkeywords: 笔记\ndate: 2020-05-25\ncomments: false\ndescription: XHR的基本认识\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识_bg.jpg\n---\n\n## 文章的思维导图\n\n\n![文章思维导图](https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识 01.jpg)\n\n\n\n## what\n\nxhr，全称XMLHttpRequest，是一种创建ajax的JavaScript API。该对象的方法提供了在浏览器和服务器之间发送请求的能力\n\n我们通过xhr可以在不刷新页面的情况下请求特定的url,获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容\n\n## how\n\n一般我们使用xhr要通过浏览器内置的XMLHttpRequest构造函数来生成一个xhr实例对象，然后我们通过调用该实例对象的属性和方法来完成ajax请求\n\n### 构造函数\n\n- XMLHttpRequest()\n\n  该构造函数用于初始化一个XMLHttpRequest实例对象\n\n### 实例属性\n\n- status | 只读\n\n  请求的响应状态码\n\n- statusText | 只读\n\n  请求的响应状态描述文本\n\n- readyState\n\n  请求的状态码\n\n- onreadystatechange\n\n  当请求状态发送变化时会触发的回调函数\n  该属性名的值为一个函数\n\n- responseType\n\n  一个用于定义响应类型的枚举值\n\n- response | 只读\n\n  返回请求后的响应数据，可以是二进制文本，字符串或者文本等....\n  具体类型由responseType决定\n\n- timeout\n\n  设置请求的最大时间\n\n- ontimeout\n\n  若请求超时，所会触发的回调函数\n\n- onerror\n\n  若请求出现异常，所会触发的回调函数\n\n### 实例方法\n\n- open(method,url,[async])\n\n  初始化一个请求\n  参数类型为(string,string,boolean)\n  参数含义为(请求方式,请求路径,是否为异步)\n\n- send(data)\n\n  发送请求\n  参数为请求实体中的参数\n  \n  若请求实体的数据为json格式,那么需要手动将参数从对象转换为json\n  \n  方法:JSON.stringify(data)\n\n- abort()\n\n  中断请求\n\n- getResponseHeader(name)\n\n  根据name获取响应头对应的值\n\n- getAllResponseHeaders()\n\n  以字符串的形式返回所有用 CRLF 分隔的响应头，如果没有收到响应，则返回 null\n\n- setRequestHeaders(name,value)\n\n  设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法\n\n## xhr的简单封装\n\n要求:\n1. 封装一个函数，函数的返回值为promise,成功的结果为response,异常的结果为error\n2. 能处理多种类型的请求:GEI/POST/PUT/DELETE\n3. 函数的参数为一个配置对象\n\n\n代码\n\n```js\nfunction axios({\n    url,\n    method = 'GET',\n    params = {},\n    data = {}\n}) {\n    return new Promise((resolve, reject) => {\n        // 处理method\n        method = method.toUpperCase();\n        \n        // 处理query参数(拼接到url上)\n        let queryString = '';\n        Object.keys(params).forEach(key => {\n            queryString += `${key}=${params[key]}&`;\n        })\n        if (queryString) {\n            // 去除最后的&\n            queryString = queryString.substring(0, queryString.length - 1);\n            // 接到url\n            url += '?' + queryString;\n        }\n\n\n        // 1. 执行异步任务,进行ajax请求\n        // 创建xhr对象\n        const request = new XMLHttpRequest();\n        // 打开连接(初始化请求)\n        request.open(method, url, true);\n        // 发送请求\n        if (method === 'GET'||method==='DELETE') {\n            request.send(null);\n        } else if(method==='POST'||method==='PUT'){\n            // 告诉服务器请求数据的格式为json格式\n            request.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n            request.send(JSON.stringify(data));\n        }\n\n        // 绑定状态改变的监听\n        request.onreadystatechange = function () {\n            // 如果请求没有完成，直接结束\n            if (request.readyState !== 4) {\n                return\n            }\n            // 如果响应状态码在[200,300)之间代表成功。否则失败\n            const { status, statusText } = request;\n            // 2.1 如果请求成功，调用resolve\n            if (status >= 200 && status < 299) {\n                // 准备结果数据对象response\n                const response = {\n                    data: JSON.parse(request.response),\n                    status,\n                    statusText\n                }\n                resolve(response)\n            } else {  // 2.2 如果请求失败，调用reject\n                reject(new Error(`request error status is ${status}`))\n            }\n        }\n    })\n\n}\n```","slug":"笔记/XHR的基本认识","published":1,"updated":"2023-05-12T23:28:10.998Z","layout":"post","link":"","_id":"clhws1t2h000b2h178e3rd2a9","content":"<h2 id=\"文章的思维导图\"><a href=\"#文章的思维导图\" class=\"headerlink\" title=\"文章的思维导图\"></a>文章的思维导图</h2><p>![文章思维导图](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/XHR%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识</a> 01.jpg)</p>\n<h2 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h2><p>xhr，全称XMLHttpRequest，是一种创建ajax的JavaScript API。该对象的方法提供了在浏览器和服务器之间发送请求的能力</p>\n<p>我们通过xhr可以在不刷新页面的情况下请求特定的url,获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容</p>\n<h2 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h2><p>一般我们使用xhr要通过浏览器内置的XMLHttpRequest构造函数来生成一个xhr实例对象，然后我们通过调用该实例对象的属性和方法来完成ajax请求</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li><p>XMLHttpRequest()</p>\n<p>该构造函数用于初始化一个XMLHttpRequest实例对象</p>\n</li>\n</ul>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><ul>\n<li><p>status | 只读</p>\n<p>请求的响应状态码</p>\n</li>\n<li><p>statusText | 只读</p>\n<p>请求的响应状态描述文本</p>\n</li>\n<li><p>readyState</p>\n<p>请求的状态码</p>\n</li>\n<li><p>onreadystatechange</p>\n<p>当请求状态发送变化时会触发的回调函数<br>该属性名的值为一个函数</p>\n</li>\n<li><p>responseType</p>\n<p>一个用于定义响应类型的枚举值</p>\n</li>\n<li><p>response | 只读</p>\n<p>返回请求后的响应数据，可以是二进制文本，字符串或者文本等….<br>具体类型由responseType决定</p>\n</li>\n<li><p>timeout</p>\n<p>设置请求的最大时间</p>\n</li>\n<li><p>ontimeout</p>\n<p>若请求超时，所会触发的回调函数</p>\n</li>\n<li><p>onerror</p>\n<p>若请求出现异常，所会触发的回调函数</p>\n</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><ul>\n<li><p>open(method,url,[async])</p>\n<p>初始化一个请求<br>参数类型为(string,string,boolean)<br>参数含义为(请求方式,请求路径,是否为异步)</p>\n</li>\n<li><p>send(data)</p>\n<p>发送请求<br>参数为请求实体中的参数</p>\n<p>若请求实体的数据为json格式,那么需要手动将参数从对象转换为json</p>\n<p>方法:JSON.stringify(data)</p>\n</li>\n<li><p>abort()</p>\n<p>中断请求</p>\n</li>\n<li><p>getResponseHeader(name)</p>\n<p>根据name获取响应头对应的值</p>\n</li>\n<li><p>getAllResponseHeaders()</p>\n<p>以字符串的形式返回所有用 CRLF 分隔的响应头，如果没有收到响应，则返回 null</p>\n</li>\n<li><p>setRequestHeaders(name,value)</p>\n<p>设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法</p>\n</li>\n</ul>\n<h2 id=\"xhr的简单封装\"><a href=\"#xhr的简单封装\" class=\"headerlink\" title=\"xhr的简单封装\"></a>xhr的简单封装</h2><p>要求:</p>\n<ol>\n<li>封装一个函数，函数的返回值为promise,成功的结果为response,异常的结果为error</li>\n<li>能处理多种类型的请求:GEI&#x2F;POST&#x2F;PUT&#x2F;DELETE</li>\n<li>函数的参数为一个配置对象</li>\n</ol>\n<p>代码</p>\n<pre><code class=\"js\">function axios(&#123;\n    url,\n    method = &#39;GET&#39;,\n    params = &#123;&#125;,\n    data = &#123;&#125;\n&#125;) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        // 处理method\n        method = method.toUpperCase();\n        \n        // 处理query参数(拼接到url上)\n        let queryString = &#39;&#39;;\n        Object.keys(params).forEach(key =&gt; &#123;\n            queryString += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`;\n        &#125;)\n        if (queryString) &#123;\n            // 去除最后的&amp;\n            queryString = queryString.substring(0, queryString.length - 1);\n            // 接到url\n            url += &#39;?&#39; + queryString;\n        &#125;\n\n\n        // 1. 执行异步任务,进行ajax请求\n        // 创建xhr对象\n        const request = new XMLHttpRequest();\n        // 打开连接(初始化请求)\n        request.open(method, url, true);\n        // 发送请求\n        if (method === &#39;GET&#39;||method===&#39;DELETE&#39;) &#123;\n            request.send(null);\n        &#125; else if(method===&#39;POST&#39;||method===&#39;PUT&#39;)&#123;\n            // 告诉服务器请求数据的格式为json格式\n            request.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json;charset=UTF-8&#39;);\n            request.send(JSON.stringify(data));\n        &#125;\n\n        // 绑定状态改变的监听\n        request.onreadystatechange = function () &#123;\n            // 如果请求没有完成，直接结束\n            if (request.readyState !== 4) &#123;\n                return\n            &#125;\n            // 如果响应状态码在[200,300)之间代表成功。否则失败\n            const &#123; status, statusText &#125; = request;\n            // 2.1 如果请求成功，调用resolve\n            if (status &gt;= 200 &amp;&amp; status &lt; 299) &#123;\n                // 准备结果数据对象response\n                const response = &#123;\n                    data: JSON.parse(request.response),\n                    status,\n                    statusText\n                &#125;\n                resolve(response)\n            &#125; else &#123;  // 2.2 如果请求失败，调用reject\n                reject(new Error(`request error status is $&#123;status&#125;`))\n            &#125;\n        &#125;\n    &#125;)\n\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文章的思维导图\"><a href=\"#文章的思维导图\" class=\"headerlink\" title=\"文章的思维导图\"></a>文章的思维导图</h2><p>![文章思维导图](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/XHR%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/XHR的基本认识</a> 01.jpg)</p>\n<h2 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h2><p>xhr，全称XMLHttpRequest，是一种创建ajax的JavaScript API。该对象的方法提供了在浏览器和服务器之间发送请求的能力</p>\n<p>我们通过xhr可以在不刷新页面的情况下请求特定的url,获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容</p>\n<h2 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h2><p>一般我们使用xhr要通过浏览器内置的XMLHttpRequest构造函数来生成一个xhr实例对象，然后我们通过调用该实例对象的属性和方法来完成ajax请求</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li><p>XMLHttpRequest()</p>\n<p>该构造函数用于初始化一个XMLHttpRequest实例对象</p>\n</li>\n</ul>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><ul>\n<li><p>status | 只读</p>\n<p>请求的响应状态码</p>\n</li>\n<li><p>statusText | 只读</p>\n<p>请求的响应状态描述文本</p>\n</li>\n<li><p>readyState</p>\n<p>请求的状态码</p>\n</li>\n<li><p>onreadystatechange</p>\n<p>当请求状态发送变化时会触发的回调函数<br>该属性名的值为一个函数</p>\n</li>\n<li><p>responseType</p>\n<p>一个用于定义响应类型的枚举值</p>\n</li>\n<li><p>response | 只读</p>\n<p>返回请求后的响应数据，可以是二进制文本，字符串或者文本等….<br>具体类型由responseType决定</p>\n</li>\n<li><p>timeout</p>\n<p>设置请求的最大时间</p>\n</li>\n<li><p>ontimeout</p>\n<p>若请求超时，所会触发的回调函数</p>\n</li>\n<li><p>onerror</p>\n<p>若请求出现异常，所会触发的回调函数</p>\n</li>\n</ul>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><ul>\n<li><p>open(method,url,[async])</p>\n<p>初始化一个请求<br>参数类型为(string,string,boolean)<br>参数含义为(请求方式,请求路径,是否为异步)</p>\n</li>\n<li><p>send(data)</p>\n<p>发送请求<br>参数为请求实体中的参数</p>\n<p>若请求实体的数据为json格式,那么需要手动将参数从对象转换为json</p>\n<p>方法:JSON.stringify(data)</p>\n</li>\n<li><p>abort()</p>\n<p>中断请求</p>\n</li>\n<li><p>getResponseHeader(name)</p>\n<p>根据name获取响应头对应的值</p>\n</li>\n<li><p>getAllResponseHeaders()</p>\n<p>以字符串的形式返回所有用 CRLF 分隔的响应头，如果没有收到响应，则返回 null</p>\n</li>\n<li><p>setRequestHeaders(name,value)</p>\n<p>设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法</p>\n</li>\n</ul>\n<h2 id=\"xhr的简单封装\"><a href=\"#xhr的简单封装\" class=\"headerlink\" title=\"xhr的简单封装\"></a>xhr的简单封装</h2><p>要求:</p>\n<ol>\n<li>封装一个函数，函数的返回值为promise,成功的结果为response,异常的结果为error</li>\n<li>能处理多种类型的请求:GEI&#x2F;POST&#x2F;PUT&#x2F;DELETE</li>\n<li>函数的参数为一个配置对象</li>\n</ol>\n<p>代码</p>\n<pre><code class=\"js\">function axios(&#123;\n    url,\n    method = &#39;GET&#39;,\n    params = &#123;&#125;,\n    data = &#123;&#125;\n&#125;) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        // 处理method\n        method = method.toUpperCase();\n        \n        // 处理query参数(拼接到url上)\n        let queryString = &#39;&#39;;\n        Object.keys(params).forEach(key =&gt; &#123;\n            queryString += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`;\n        &#125;)\n        if (queryString) &#123;\n            // 去除最后的&amp;\n            queryString = queryString.substring(0, queryString.length - 1);\n            // 接到url\n            url += &#39;?&#39; + queryString;\n        &#125;\n\n\n        // 1. 执行异步任务,进行ajax请求\n        // 创建xhr对象\n        const request = new XMLHttpRequest();\n        // 打开连接(初始化请求)\n        request.open(method, url, true);\n        // 发送请求\n        if (method === &#39;GET&#39;||method===&#39;DELETE&#39;) &#123;\n            request.send(null);\n        &#125; else if(method===&#39;POST&#39;||method===&#39;PUT&#39;)&#123;\n            // 告诉服务器请求数据的格式为json格式\n            request.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json;charset=UTF-8&#39;);\n            request.send(JSON.stringify(data));\n        &#125;\n\n        // 绑定状态改变的监听\n        request.onreadystatechange = function () &#123;\n            // 如果请求没有完成，直接结束\n            if (request.readyState !== 4) &#123;\n                return\n            &#125;\n            // 如果响应状态码在[200,300)之间代表成功。否则失败\n            const &#123; status, statusText &#125; = request;\n            // 2.1 如果请求成功，调用resolve\n            if (status &gt;= 200 &amp;&amp; status &lt; 299) &#123;\n                // 准备结果数据对象response\n                const response = &#123;\n                    data: JSON.parse(request.response),\n                    status,\n                    statusText\n                &#125;\n                resolve(response)\n            &#125; else &#123;  // 2.2 如果请求失败，调用reject\n                reject(new Error(`request error status is $&#123;status&#125;`))\n            &#125;\n        &#125;\n    &#125;)\n\n&#125;\n</code></pre>\n"},{"title":"bind/apply/call实现","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"笔记","date":"2020-06-05T16:00:00.000Z","comments":0,"description":"bind/apply/call实现","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Generator_bg.jpg"],"_content":"\n## Function.prototype.bind\n\n1. 该方法会创建一个新的函数,在bind()被调用时,这个新函数的this被指定为bind()的第一个参数,而其余参数将作为新函数的参数,供调用时使用\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 新函数被调用时所指定的this值\n * 2. arg1,arg2... 新函数执行所被传入的参数\n * \n */\nfunction.bind(thisArg,arg1,arg2....)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myBind = function(thisArg,...args){\n\n    var thisArg = thisArg || window\n\n    let self = this;\n\n    let result = function(){\n        self.apply(\n            this instanceof self\n            ?this:thisArg\n            ,args.concat(Array.prototype.slice.call(arguments))\n        )\n    }\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nvar p1 = f.myBind({a:1});\n\nconsole.log(f===p1); // false\nf(); // window对象\np1(); // {a:1}\n```\n\n## Function.prototype.apply\n\n1. 该方法调用一个具有指定this值的函数,以及作为一个`数组`提供的参数\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. argsArray 传递给函数时的参数数组\n * \n */\nfunction.apply(thisArg,argsArray)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myApply = function(thisArg,args){\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval('thisArg.fn(args)');\n\n    delete thisArg.fn;\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nf(); // window对象\nf.myApply({a:1}); // {a:1}\n```\n\n## Function.prototype.call\n\n1. 该方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. arg1,arg2,arg3... 传递给函数时的参数列表\n *  \n */\nfunction.apply(thisArg,arg1,arg2,arg3...)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myApply = function(thisArg,...args){\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval('thisArg.fn(args)');\n\n    delete thisArg.fn;\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nf(); // window对象\nf.myApply({a:1}); // {a:1}\n```\n","source":"_posts/笔记/bind&apply&call方法实现.md","raw":"---\ntitle: bind/apply/call实现\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 笔记\ntags:\n - 笔记\nkeywords: 笔记\ndate: 2020-06-06\ncomments: false\ndescription: bind/apply/call实现\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Generator_bg.jpg\n---\n\n## Function.prototype.bind\n\n1. 该方法会创建一个新的函数,在bind()被调用时,这个新函数的this被指定为bind()的第一个参数,而其余参数将作为新函数的参数,供调用时使用\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 新函数被调用时所指定的this值\n * 2. arg1,arg2... 新函数执行所被传入的参数\n * \n */\nfunction.bind(thisArg,arg1,arg2....)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myBind = function(thisArg,...args){\n\n    var thisArg = thisArg || window\n\n    let self = this;\n\n    let result = function(){\n        self.apply(\n            this instanceof self\n            ?this:thisArg\n            ,args.concat(Array.prototype.slice.call(arguments))\n        )\n    }\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nvar p1 = f.myBind({a:1});\n\nconsole.log(f===p1); // false\nf(); // window对象\np1(); // {a:1}\n```\n\n## Function.prototype.apply\n\n1. 该方法调用一个具有指定this值的函数,以及作为一个`数组`提供的参数\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. argsArray 传递给函数时的参数数组\n * \n */\nfunction.apply(thisArg,argsArray)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myApply = function(thisArg,args){\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval('thisArg.fn(args)');\n\n    delete thisArg.fn;\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nf(); // window对象\nf.myApply({a:1}); // {a:1}\n```\n\n## Function.prototype.call\n\n1. 该方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\n\n<!-- ... -->\n\n2. 语法\n\n```js\n/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. arg1,arg2,arg3... 传递给函数时的参数列表\n *  \n */\nfunction.apply(thisArg,arg1,arg2,arg3...)\n```\n\n3. 实现代码\n\n```js\nFunction.prototype.myApply = function(thisArg,...args){\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval('thisArg.fn(args)');\n\n    delete thisArg.fn;\n\n    return result;\n\n}\n// 测试样例\nfunction f(){\n    console.log(this);\n}\n\nf(); // window对象\nf.myApply({a:1}); // {a:1}\n```\n","slug":"笔记/bind&apply&call方法实现","published":1,"updated":"2023-05-12T23:28:10.998Z","layout":"post","link":"","_id":"clhws1t2j000g2h176mfz49vb","content":"<h2 id=\"Function-prototype-bind\"><a href=\"#Function-prototype-bind\" class=\"headerlink\" title=\"Function.prototype.bind\"></a>Function.prototype.bind</h2><ol>\n<li>该方法会创建一个新的函数,在bind()被调用时,这个新函数的this被指定为bind()的第一个参数,而其余参数将作为新函数的参数,供调用时使用</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 新函数被调用时所指定的this值\n * 2. arg1,arg2... 新函数执行所被传入的参数\n * \n */\nfunction.bind(thisArg,arg1,arg2....)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myBind = function(thisArg,...args)&#123;\n\n    var thisArg = thisArg || window\n\n    let self = this;\n\n    let result = function()&#123;\n        self.apply(\n            this instanceof self\n            ?this:thisArg\n            ,args.concat(Array.prototype.slice.call(arguments))\n        )\n    &#125;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nvar p1 = f.myBind(&#123;a:1&#125;);\n\nconsole.log(f===p1); // false\nf(); // window对象\np1(); // &#123;a:1&#125;\n</code></pre>\n<h2 id=\"Function-prototype-apply\"><a href=\"#Function-prototype-apply\" class=\"headerlink\" title=\"Function.prototype.apply\"></a>Function.prototype.apply</h2><ol>\n<li>该方法调用一个具有指定this值的函数,以及作为一个<code>数组</code>提供的参数</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. argsArray 传递给函数时的参数数组\n * \n */\nfunction.apply(thisArg,argsArray)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myApply = function(thisArg,args)&#123;\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval(&#39;thisArg.fn(args)&#39;);\n\n    delete thisArg.fn;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nf(); // window对象\nf.myApply(&#123;a:1&#125;); // &#123;a:1&#125;\n</code></pre>\n<h2 id=\"Function-prototype-call\"><a href=\"#Function-prototype-call\" class=\"headerlink\" title=\"Function.prototype.call\"></a>Function.prototype.call</h2><ol>\n<li>该方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. arg1,arg2,arg3... 传递给函数时的参数列表\n *  \n */\nfunction.apply(thisArg,arg1,arg2,arg3...)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myApply = function(thisArg,...args)&#123;\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval(&#39;thisArg.fn(args)&#39;);\n\n    delete thisArg.fn;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nf(); // window对象\nf.myApply(&#123;a:1&#125;); // &#123;a:1&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Function-prototype-bind\"><a href=\"#Function-prototype-bind\" class=\"headerlink\" title=\"Function.prototype.bind\"></a>Function.prototype.bind</h2><ol>\n<li>该方法会创建一个新的函数,在bind()被调用时,这个新函数的this被指定为bind()的第一个参数,而其余参数将作为新函数的参数,供调用时使用</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 新函数被调用时所指定的this值\n * 2. arg1,arg2... 新函数执行所被传入的参数\n * \n */\nfunction.bind(thisArg,arg1,arg2....)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myBind = function(thisArg,...args)&#123;\n\n    var thisArg = thisArg || window\n\n    let self = this;\n\n    let result = function()&#123;\n        self.apply(\n            this instanceof self\n            ?this:thisArg\n            ,args.concat(Array.prototype.slice.call(arguments))\n        )\n    &#125;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nvar p1 = f.myBind(&#123;a:1&#125;);\n\nconsole.log(f===p1); // false\nf(); // window对象\np1(); // &#123;a:1&#125;\n</code></pre>\n<h2 id=\"Function-prototype-apply\"><a href=\"#Function-prototype-apply\" class=\"headerlink\" title=\"Function.prototype.apply\"></a>Function.prototype.apply</h2><ol>\n<li>该方法调用一个具有指定this值的函数,以及作为一个<code>数组</code>提供的参数</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. argsArray 传递给函数时的参数数组\n * \n */\nfunction.apply(thisArg,argsArray)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myApply = function(thisArg,args)&#123;\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval(&#39;thisArg.fn(args)&#39;);\n\n    delete thisArg.fn;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nf(); // window对象\nf.myApply(&#123;a:1&#125;); // &#123;a:1&#125;\n</code></pre>\n<h2 id=\"Function-prototype-call\"><a href=\"#Function-prototype-call\" class=\"headerlink\" title=\"Function.prototype.call\"></a>Function.prototype.call</h2><ol>\n<li>该方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</li>\n</ol>\n<!-- ... -->\n\n<ol start=\"2\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">/**\n * \n * 1. thisAge 函数被调用时所指定的this值\n * 2. arg1,arg2,arg3... 传递给函数时的参数列表\n *  \n */\nfunction.apply(thisArg,arg1,arg2,arg3...)\n</code></pre>\n<ol start=\"3\">\n<li>实现代码</li>\n</ol>\n<pre><code class=\"js\">Function.prototype.myApply = function(thisArg,...args)&#123;\n\n    let thisArg = thisArg || window;\n\n    thisArg.fn = this;\n\n    let result = eval(&#39;thisArg.fn(args)&#39;);\n\n    delete thisArg.fn;\n\n    return result;\n\n&#125;\n// 测试样例\nfunction f()&#123;\n    console.log(this);\n&#125;\n\nf(); // window对象\nf.myApply(&#123;a:1&#125;); // &#123;a:1&#125;\n</code></pre>\n"},{"title":"高数 - 极限","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"数学","date":"2020-07-22T09:58:23.000Z","comments":0,"description":"高数 - 极限","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/极限.jpg"],"_content":"\n## 文章思维导图\n\n![数列极限知识点](https://gitee.com/trueLoving/cdn/raw/master/img/数列极限.jpg)\n\n## 定义\n\n极限的定义是这样描述的:对于任意的$\\epsilon$大于0，满足存在一个非负数N,当n大于N时,满足|$x_{n}$-a | < $\\epsilon$,则称数列$x_{n}$的极限为a。记作$\\lim_{n\\rightarrow+\\infty}x_{n}$=a\n\n而因为极限的定义，所以如果我们要通过定义来证明一个数列的极限是否存在，通常按以下三步即可完成证明：\n1. 找出数列的通项并做极限差的绝对值，然后小于一个正整数$\\epsilon$\n2. 通过上述的不等式反解出左侧为n的一个不等式g($\\epsilon$)（此不等式为关于$\\epsilon$的一个函数）\n3. 取N = [g($\\epsilon$)]+1,并证明当n>N时，对任意的$\\epsilon$大于0，存在n满足不等式即可完成证明\n\n## 例题\n\n![极限定义证明 01](https://gitee.com/trueLoving/cdn/raw/master/math/极限定义证明01.jpg)\n\n![极限定义证明 02](https://gitee.com/trueLoving/cdn/raw/master/math/极限定义证明02.jpg)\n\n## 原数列和子数列\n\n定理：如果原数列收敛于A，那么该数列的子数列全部都收敛且收敛于A\n\n那么由该定理的逆否命题，可以得到以下两个推论\n1. 当一个数列的一个子数列发散，则该数列发散\n2. 若一个数列的两个子数列收敛，但是收敛的不是同一个值，则该数列发散\n\n通过，我们使用这两个推论来证明一个数列的极限是不存在的\n\n## 例题\n\n![原数组和子数组](https://gitee.com/trueLoving/cdn/raw/master/math/原数组和子数组.jpg)\n\n## 性质\n\n当一个数列的极限存在，则会具有以下三个性质\n1. 唯一性，即该数列的极限值有且只有一个\n2. 有界性，即该数列上的所有点都在极限值的下方/上方\n3. 保号性，若该数列的极限a大于0，则存在正整数N，当n>N时，数列大于0\n\n而由保号性我们又可以得到以下推论\n当数列{$a_n$}从某项后>=0/<=0，并且$\\lim_{n\\rightarrow+\\infty}a_{n}$=a，则可以得到a>=0\n\n\n## 极限的运算规则\n\n若数列{$a_n$}和数列{$b_n$}的极限存在分别为a和b,则数列极限的+-*/为数列的+-*/再取极限\n\n## 例题\n![极限运算](https://gitee.com/trueLoving/cdn/raw/master/math/极限运算.jpg)\n\n## 夹逼准则\n\n若满足以下条件\n1. {$y_n$}<{$x_n$}<{$z_n$}\n2. 并且$y_n$的极限为C，$z_n$的极限为C\n\n那么，我们就可以得到$x_n$的极限为C\n`注意：不等式是可以有等号的，也是可以没有等号的`\n\n## 例题\n\n![夹逼准则](https://gitee.com/trueLoving/cdn/raw/master/math/夹逼准则.jpg)\n\n## 单调有界\n\n单调有界函数必定有极限\n\n若数列$x_n$单调递减（递增）且有下界（上界），则$x_n$的极限存在\n\n证明单调性我们可以做相邻项之间的差/商，来和0（1）比较\n\n## 例题\n\n![单调有界](https://gitee.com/trueLoving/cdn/raw/master/math/单调有界.jpg)","source":"_posts/数学/极限.md","raw":"---\ntitle: 高数 - 极限\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 数学\ntags:\n - 数学\nkeywords: 数学\ndate: 2020-07-22 17:58:23\ncomments: false\ndescription: 高数 - 极限\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/极限.jpg\n---\n\n## 文章思维导图\n\n![数列极限知识点](https://gitee.com/trueLoving/cdn/raw/master/img/数列极限.jpg)\n\n## 定义\n\n极限的定义是这样描述的:对于任意的$\\epsilon$大于0，满足存在一个非负数N,当n大于N时,满足|$x_{n}$-a | < $\\epsilon$,则称数列$x_{n}$的极限为a。记作$\\lim_{n\\rightarrow+\\infty}x_{n}$=a\n\n而因为极限的定义，所以如果我们要通过定义来证明一个数列的极限是否存在，通常按以下三步即可完成证明：\n1. 找出数列的通项并做极限差的绝对值，然后小于一个正整数$\\epsilon$\n2. 通过上述的不等式反解出左侧为n的一个不等式g($\\epsilon$)（此不等式为关于$\\epsilon$的一个函数）\n3. 取N = [g($\\epsilon$)]+1,并证明当n>N时，对任意的$\\epsilon$大于0，存在n满足不等式即可完成证明\n\n## 例题\n\n![极限定义证明 01](https://gitee.com/trueLoving/cdn/raw/master/math/极限定义证明01.jpg)\n\n![极限定义证明 02](https://gitee.com/trueLoving/cdn/raw/master/math/极限定义证明02.jpg)\n\n## 原数列和子数列\n\n定理：如果原数列收敛于A，那么该数列的子数列全部都收敛且收敛于A\n\n那么由该定理的逆否命题，可以得到以下两个推论\n1. 当一个数列的一个子数列发散，则该数列发散\n2. 若一个数列的两个子数列收敛，但是收敛的不是同一个值，则该数列发散\n\n通过，我们使用这两个推论来证明一个数列的极限是不存在的\n\n## 例题\n\n![原数组和子数组](https://gitee.com/trueLoving/cdn/raw/master/math/原数组和子数组.jpg)\n\n## 性质\n\n当一个数列的极限存在，则会具有以下三个性质\n1. 唯一性，即该数列的极限值有且只有一个\n2. 有界性，即该数列上的所有点都在极限值的下方/上方\n3. 保号性，若该数列的极限a大于0，则存在正整数N，当n>N时，数列大于0\n\n而由保号性我们又可以得到以下推论\n当数列{$a_n$}从某项后>=0/<=0，并且$\\lim_{n\\rightarrow+\\infty}a_{n}$=a，则可以得到a>=0\n\n\n## 极限的运算规则\n\n若数列{$a_n$}和数列{$b_n$}的极限存在分别为a和b,则数列极限的+-*/为数列的+-*/再取极限\n\n## 例题\n![极限运算](https://gitee.com/trueLoving/cdn/raw/master/math/极限运算.jpg)\n\n## 夹逼准则\n\n若满足以下条件\n1. {$y_n$}<{$x_n$}<{$z_n$}\n2. 并且$y_n$的极限为C，$z_n$的极限为C\n\n那么，我们就可以得到$x_n$的极限为C\n`注意：不等式是可以有等号的，也是可以没有等号的`\n\n## 例题\n\n![夹逼准则](https://gitee.com/trueLoving/cdn/raw/master/math/夹逼准则.jpg)\n\n## 单调有界\n\n单调有界函数必定有极限\n\n若数列$x_n$单调递减（递增）且有下界（上界），则$x_n$的极限存在\n\n证明单调性我们可以做相邻项之间的差/商，来和0（1）比较\n\n## 例题\n\n![单调有界](https://gitee.com/trueLoving/cdn/raw/master/math/单调有界.jpg)","slug":"数学/极限","published":1,"updated":"2023-05-12T23:28:10.998Z","layout":"post","link":"","_id":"clhws1t2k000i2h1793uracyh","content":"<h2 id=\"文章思维导图\"><a href=\"#文章思维导图\" class=\"headerlink\" title=\"文章思维导图\"></a>文章思维导图</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.jpg\" alt=\"数列极限知识点\"></p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>极限的定义是这样描述的:对于任意的$\\epsilon$大于0，满足存在一个非负数N,当n大于N时,满足|$x_{n}$-a | &lt; $\\epsilon$,则称数列$x_{n}$的极限为a。记作$\\lim_{n\\rightarrow+\\infty}x_{n}$&#x3D;a</p>\n<p>而因为极限的定义，所以如果我们要通过定义来证明一个数列的极限是否存在，通常按以下三步即可完成证明：</p>\n<ol>\n<li>找出数列的通项并做极限差的绝对值，然后小于一个正整数$\\epsilon$</li>\n<li>通过上述的不等式反解出左侧为n的一个不等式g($\\epsilon$)（此不等式为关于$\\epsilon$的一个函数）</li>\n<li>取N &#x3D; [g($\\epsilon$)]+1,并证明当n&gt;N时，对任意的$\\epsilon$大于0，存在n满足不等式即可完成证明</li>\n</ol>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E01.jpg\" alt=\"极限定义证明 01\"></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E02.jpg\" alt=\"极限定义证明 02\"></p>\n<h2 id=\"原数列和子数列\"><a href=\"#原数列和子数列\" class=\"headerlink\" title=\"原数列和子数列\"></a>原数列和子数列</h2><p>定理：如果原数列收敛于A，那么该数列的子数列全部都收敛且收敛于A</p>\n<p>那么由该定理的逆否命题，可以得到以下两个推论</p>\n<ol>\n<li>当一个数列的一个子数列发散，则该数列发散</li>\n<li>若一个数列的两个子数列收敛，但是收敛的不是同一个值，则该数列发散</li>\n</ol>\n<p>通过，我们使用这两个推论来证明一个数列的极限是不存在的</p>\n<h2 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%8E%9F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84.jpg\" alt=\"原数组和子数组\"></p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><p>当一个数列的极限存在，则会具有以下三个性质</p>\n<ol>\n<li>唯一性，即该数列的极限值有且只有一个</li>\n<li>有界性，即该数列上的所有点都在极限值的下方&#x2F;上方</li>\n<li>保号性，若该数列的极限a大于0，则存在正整数N，当n&gt;N时，数列大于0</li>\n</ol>\n<p>而由保号性我们又可以得到以下推论<br>当数列{$a_n$}从某项后&gt;&#x3D;0&#x2F;&lt;&#x3D;0，并且$\\lim_{n\\rightarrow+\\infty}a_{n}$&#x3D;a，则可以得到a&gt;&#x3D;0</p>\n<h2 id=\"极限的运算规则\"><a href=\"#极限的运算规则\" class=\"headerlink\" title=\"极限的运算规则\"></a>极限的运算规则</h2><p>若数列{$a_n$}和数列{$b_n$}的极限存在分别为a和b,则数列极限的+-<em>&#x2F;为数列的+-</em>&#x2F;再取极限</p>\n<h2 id=\"例题-2\"><a href=\"#例题-2\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E8%BF%90%E7%AE%97.jpg\" alt=\"极限运算\"></p>\n<h2 id=\"夹逼准则\"><a href=\"#夹逼准则\" class=\"headerlink\" title=\"夹逼准则\"></a>夹逼准则</h2><p>若满足以下条件</p>\n<ol>\n<li>{$y_n$}&lt;{$x_n$}&lt;{$z_n$}</li>\n<li>并且$y_n$的极限为C，$z_n$的极限为C</li>\n</ol>\n<p>那么，我们就可以得到$x_n$的极限为C<br><code>注意：不等式是可以有等号的，也是可以没有等号的</code></p>\n<h2 id=\"例题-3\"><a href=\"#例题-3\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99.jpg\" alt=\"夹逼准则\"></p>\n<h2 id=\"单调有界\"><a href=\"#单调有界\" class=\"headerlink\" title=\"单调有界\"></a>单调有界</h2><p>单调有界函数必定有极限</p>\n<p>若数列$x_n$单调递减（递增）且有下界（上界），则$x_n$的极限存在</p>\n<p>证明单调性我们可以做相邻项之间的差&#x2F;商，来和0（1）比较</p>\n<h2 id=\"例题-4\"><a href=\"#例题-4\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%8D%95%E8%B0%83%E6%9C%89%E7%95%8C.jpg\" alt=\"单调有界\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文章思维导图\"><a href=\"#文章思维导图\" class=\"headerlink\" title=\"文章思维导图\"></a>文章思维导图</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.jpg\" alt=\"数列极限知识点\"></p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>极限的定义是这样描述的:对于任意的$\\epsilon$大于0，满足存在一个非负数N,当n大于N时,满足|$x_{n}$-a | &lt; $\\epsilon$,则称数列$x_{n}$的极限为a。记作$\\lim_{n\\rightarrow+\\infty}x_{n}$&#x3D;a</p>\n<p>而因为极限的定义，所以如果我们要通过定义来证明一个数列的极限是否存在，通常按以下三步即可完成证明：</p>\n<ol>\n<li>找出数列的通项并做极限差的绝对值，然后小于一个正整数$\\epsilon$</li>\n<li>通过上述的不等式反解出左侧为n的一个不等式g($\\epsilon$)（此不等式为关于$\\epsilon$的一个函数）</li>\n<li>取N &#x3D; [g($\\epsilon$)]+1,并证明当n&gt;N时，对任意的$\\epsilon$大于0，存在n满足不等式即可完成证明</li>\n</ol>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E01.jpg\" alt=\"极限定义证明 01\"></p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E02.jpg\" alt=\"极限定义证明 02\"></p>\n<h2 id=\"原数列和子数列\"><a href=\"#原数列和子数列\" class=\"headerlink\" title=\"原数列和子数列\"></a>原数列和子数列</h2><p>定理：如果原数列收敛于A，那么该数列的子数列全部都收敛且收敛于A</p>\n<p>那么由该定理的逆否命题，可以得到以下两个推论</p>\n<ol>\n<li>当一个数列的一个子数列发散，则该数列发散</li>\n<li>若一个数列的两个子数列收敛，但是收敛的不是同一个值，则该数列发散</li>\n</ol>\n<p>通过，我们使用这两个推论来证明一个数列的极限是不存在的</p>\n<h2 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%8E%9F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84.jpg\" alt=\"原数组和子数组\"></p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><p>当一个数列的极限存在，则会具有以下三个性质</p>\n<ol>\n<li>唯一性，即该数列的极限值有且只有一个</li>\n<li>有界性，即该数列上的所有点都在极限值的下方&#x2F;上方</li>\n<li>保号性，若该数列的极限a大于0，则存在正整数N，当n&gt;N时，数列大于0</li>\n</ol>\n<p>而由保号性我们又可以得到以下推论<br>当数列{$a_n$}从某项后&gt;&#x3D;0&#x2F;&lt;&#x3D;0，并且$\\lim_{n\\rightarrow+\\infty}a_{n}$&#x3D;a，则可以得到a&gt;&#x3D;0</p>\n<h2 id=\"极限的运算规则\"><a href=\"#极限的运算规则\" class=\"headerlink\" title=\"极限的运算规则\"></a>极限的运算规则</h2><p>若数列{$a_n$}和数列{$b_n$}的极限存在分别为a和b,则数列极限的+-<em>&#x2F;为数列的+-</em>&#x2F;再取极限</p>\n<h2 id=\"例题-2\"><a href=\"#例题-2\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E6%9E%81%E9%99%90%E8%BF%90%E7%AE%97.jpg\" alt=\"极限运算\"></p>\n<h2 id=\"夹逼准则\"><a href=\"#夹逼准则\" class=\"headerlink\" title=\"夹逼准则\"></a>夹逼准则</h2><p>若满足以下条件</p>\n<ol>\n<li>{$y_n$}&lt;{$x_n$}&lt;{$z_n$}</li>\n<li>并且$y_n$的极限为C，$z_n$的极限为C</li>\n</ol>\n<p>那么，我们就可以得到$x_n$的极限为C<br><code>注意：不等式是可以有等号的，也是可以没有等号的</code></p>\n<h2 id=\"例题-3\"><a href=\"#例题-3\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99.jpg\" alt=\"夹逼准则\"></p>\n<h2 id=\"单调有界\"><a href=\"#单调有界\" class=\"headerlink\" title=\"单调有界\"></a>单调有界</h2><p>单调有界函数必定有极限</p>\n<p>若数列$x_n$单调递减（递增）且有下界（上界），则$x_n$的极限存在</p>\n<p>证明单调性我们可以做相邻项之间的差&#x2F;商，来和0（1）比较</p>\n<h2 id=\"例题-4\"><a href=\"#例题-4\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/math/%E5%8D%95%E8%B0%83%E6%9C%89%E7%95%8C.jpg\" alt=\"单调有界\"></p>\n"},{"title":"常见排序算法","author":"Re_Star","avatar":"https://trueloving.gitee.io/blog/avatar.png","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"算法","date":"2020-06-17T16:00:00.000Z","comments":0,"description":"常见排序算法","photos":["http://p0.qhimg.com/bdm/960_593_0/t0136891cfc94bfabd0.jpg"],"_content":"\n## 插入排序\n`代码`\n```js\n/**\n * 插入排序\n * @param {Array} array 要排序的数组\n */\nfunction insertSort(array) {\n    let temp;\n    for (let i = 0; i < array.length; i++) {\n        temp = array[i];\n        for (let j = i; j > 0 && temp < array[j - 1]; j--) {\n            array[j] = array[j - 1];\n        }\n        array[j] = temp;\n    }\n    return array;\n}\n\n// ----------- test\ninsertSort([3,1,2]) // [1,2,3]\n```\n\n`思路`\n1. 插入排序 = 元素插入 + 顺序插入\n2. 数组的第一个元素不动，第二个元素找左侧比它小的边界元素，然后插在该边界元素的左侧\n3. 第三个元素类型，以此类推插完数组中的所有元素\n\n\n## 快速排序\n`代码`\n```js\n/**\n * 快速排序\n * @param {Array} array 要排序的数组\n */\nfunction quickSort(array) {\n\n    if (array.length <= 1) return array;\n\n    let pivotIndex = Math.floor(array.length / 2);\n\n    let pivot = array.splice(pivotIndex, 1)[0];\n\n    let left = [], right = [];\n\n    for (let i = 0; i < array.length; i++) {\n        if (pivot > array[i]) {\n            left.push(array[i]);\n        }\n        if (pivot < array[i]) {\n            right.push(array[i]);\n        }\n    }\n\n    return quickSort(left).concat([pivotIndex], quickSort(right));\n\n}\n```\n\n`思想`\n1. 如果数组只有这一个成员变量就直接返回该数组\n2. 如果数组成员变量有多个，就在数组中找一个基准元素，然后根据这个基准将整个数组分为三部分:左侧，基准，右侧.最后递归调用quickSort\n\n## 冒泡排序\n`代码`\n```js\n/**\n * 冒泡排序\n * @param {Array} array 要排序的数组\n */\nfunction bubblingSort(array) {\n    for (let i = 0; i < array.length; i++) {\n        for (let j = i + 1; j < array.length; j++) {\n            if (array[i] < array[j]) {\n                [array[i], array[j]] = [array[j], array[i]];\n            }\n        }\n    }\n    return array;\n}\n```\n`思路`\n\n1. 两两比较数组元素之家的大小关系，如果前一个小于后一个，就交换，否则就不换\n\n\n## 归并排序\n`代码`\n```js\n\nfunction mergeSort(array){\n\n    if(array.length<=1)return array;\n\n    const len = array.length;\n    const mid = Math.floor(len/2);\n\n    const left = array.slice(0,mid);\n    const right = array.slice(mid,length);\n\n    return merge(mergeSort(left),mergeSort(right))\n\n}\n\nfunction merge(left,right){\n\n    const result = [];\n    let il = 0;\n    let ir = 0;\n\n    wihle(il<left.length&&ir<right.length){\n        if(left[il]<right[ir]){\n            result.push(left[il]);\n            il++;\n        }else{\n            result.push(left[ir]);\n            ir++;\n        }\n    }\n\n    while(il<left.length){\n        result.push(left[il]);\n        il++;\n    }\n\n    while(ir<right.length){\n        result.push(right[ir]);\n        ir++;\n    }\n\n    return result;\n\n}\n\n\n```\n\n`思路`\n1. 如果数组的长度为1，则直接返回该数组\n2. 如果数组的长度大于1，则将该数组分为左右两部分，然后递归分解（即左侧再分解左右，右侧再分解左右）\n3. 然后当分解完成后，两两合并(在这个阶段完成数组的排序)，最终合并成一个已排好序的数组\n\n\n## 堆排序\n`代码`\n```js\n/**\n* \n* @param {Array} array \n*/\nfunction heapSort(array) {\n  let len = array.length;\n  for (let i = Math.floor(len / 2 -1); i >= 0; i--) {\n      adjustHeap(array, i,len);\n  }\n  for (let i = len - 1; i > 0; i--) {\n      swap(array,0,i);\n      adjustHeap(array,0, i);\n  }\n  return array\n}\n\n/**\n* \n* @param {Array} array \n* @param {Number} i \n*/\nfunction adjustHeap(array, i,length) {\n  for (let j = 2 * i + 1; j < length; j = 2 * j + 1) {\n      temp = array[i];\n      if (j + 1 < length && array[j] < array[j + 1]) {\n          j++;\n      }\n      if (temp < array[j]) {\n          swap(array,i,j);\n          i = j;\n      } else {\n          break;\n      }\n  }\n}\n```\n\n`思路`\n1. 将数组构建成一个最大堆\n2. 将数组的根节点移动到最前面，然后调整堆\n3. 这样就可以完成对数组的排序\n\n","source":"_posts/算法/常见排序算法.md","raw":"---\ntitle: 常见排序算法\nauthor: Re_Star\navatar: https://trueloving.gitee.io/blog/avatar.png  \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 算法\ntags:\n - 算法\nkeywords: 算法\ndate: 2020-06-18\ncomments: false\ndescription: 常见排序算法\nphotos: http://p0.qhimg.com/bdm/960_593_0/t0136891cfc94bfabd0.jpg\n---\n\n## 插入排序\n`代码`\n```js\n/**\n * 插入排序\n * @param {Array} array 要排序的数组\n */\nfunction insertSort(array) {\n    let temp;\n    for (let i = 0; i < array.length; i++) {\n        temp = array[i];\n        for (let j = i; j > 0 && temp < array[j - 1]; j--) {\n            array[j] = array[j - 1];\n        }\n        array[j] = temp;\n    }\n    return array;\n}\n\n// ----------- test\ninsertSort([3,1,2]) // [1,2,3]\n```\n\n`思路`\n1. 插入排序 = 元素插入 + 顺序插入\n2. 数组的第一个元素不动，第二个元素找左侧比它小的边界元素，然后插在该边界元素的左侧\n3. 第三个元素类型，以此类推插完数组中的所有元素\n\n\n## 快速排序\n`代码`\n```js\n/**\n * 快速排序\n * @param {Array} array 要排序的数组\n */\nfunction quickSort(array) {\n\n    if (array.length <= 1) return array;\n\n    let pivotIndex = Math.floor(array.length / 2);\n\n    let pivot = array.splice(pivotIndex, 1)[0];\n\n    let left = [], right = [];\n\n    for (let i = 0; i < array.length; i++) {\n        if (pivot > array[i]) {\n            left.push(array[i]);\n        }\n        if (pivot < array[i]) {\n            right.push(array[i]);\n        }\n    }\n\n    return quickSort(left).concat([pivotIndex], quickSort(right));\n\n}\n```\n\n`思想`\n1. 如果数组只有这一个成员变量就直接返回该数组\n2. 如果数组成员变量有多个，就在数组中找一个基准元素，然后根据这个基准将整个数组分为三部分:左侧，基准，右侧.最后递归调用quickSort\n\n## 冒泡排序\n`代码`\n```js\n/**\n * 冒泡排序\n * @param {Array} array 要排序的数组\n */\nfunction bubblingSort(array) {\n    for (let i = 0; i < array.length; i++) {\n        for (let j = i + 1; j < array.length; j++) {\n            if (array[i] < array[j]) {\n                [array[i], array[j]] = [array[j], array[i]];\n            }\n        }\n    }\n    return array;\n}\n```\n`思路`\n\n1. 两两比较数组元素之家的大小关系，如果前一个小于后一个，就交换，否则就不换\n\n\n## 归并排序\n`代码`\n```js\n\nfunction mergeSort(array){\n\n    if(array.length<=1)return array;\n\n    const len = array.length;\n    const mid = Math.floor(len/2);\n\n    const left = array.slice(0,mid);\n    const right = array.slice(mid,length);\n\n    return merge(mergeSort(left),mergeSort(right))\n\n}\n\nfunction merge(left,right){\n\n    const result = [];\n    let il = 0;\n    let ir = 0;\n\n    wihle(il<left.length&&ir<right.length){\n        if(left[il]<right[ir]){\n            result.push(left[il]);\n            il++;\n        }else{\n            result.push(left[ir]);\n            ir++;\n        }\n    }\n\n    while(il<left.length){\n        result.push(left[il]);\n        il++;\n    }\n\n    while(ir<right.length){\n        result.push(right[ir]);\n        ir++;\n    }\n\n    return result;\n\n}\n\n\n```\n\n`思路`\n1. 如果数组的长度为1，则直接返回该数组\n2. 如果数组的长度大于1，则将该数组分为左右两部分，然后递归分解（即左侧再分解左右，右侧再分解左右）\n3. 然后当分解完成后，两两合并(在这个阶段完成数组的排序)，最终合并成一个已排好序的数组\n\n\n## 堆排序\n`代码`\n```js\n/**\n* \n* @param {Array} array \n*/\nfunction heapSort(array) {\n  let len = array.length;\n  for (let i = Math.floor(len / 2 -1); i >= 0; i--) {\n      adjustHeap(array, i,len);\n  }\n  for (let i = len - 1; i > 0; i--) {\n      swap(array,0,i);\n      adjustHeap(array,0, i);\n  }\n  return array\n}\n\n/**\n* \n* @param {Array} array \n* @param {Number} i \n*/\nfunction adjustHeap(array, i,length) {\n  for (let j = 2 * i + 1; j < length; j = 2 * j + 1) {\n      temp = array[i];\n      if (j + 1 < length && array[j] < array[j + 1]) {\n          j++;\n      }\n      if (temp < array[j]) {\n          swap(array,i,j);\n          i = j;\n      } else {\n          break;\n      }\n  }\n}\n```\n\n`思路`\n1. 将数组构建成一个最大堆\n2. 将数组的根节点移动到最前面，然后调整堆\n3. 这样就可以完成对数组的排序\n\n","slug":"算法/常见排序算法","published":1,"updated":"2023-05-12T23:28:10.999Z","layout":"post","link":"","_id":"clhws1t2n000o2h17dt4z7bo7","content":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 插入排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction insertSort(array) &#123;\n    let temp;\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        temp = array[i];\n        for (let j = i; j &gt; 0 &amp;&amp; temp &lt; array[j - 1]; j--) &#123;\n            array[j] = array[j - 1];\n        &#125;\n        array[j] = temp;\n    &#125;\n    return array;\n&#125;\n\n// ----------- test\ninsertSort([3,1,2]) // [1,2,3]\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>插入排序 &#x3D; 元素插入 + 顺序插入</li>\n<li>数组的第一个元素不动，第二个元素找左侧比它小的边界元素，然后插在该边界元素的左侧</li>\n<li>第三个元素类型，以此类推插完数组中的所有元素</li>\n</ol>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 快速排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction quickSort(array) &#123;\n\n    if (array.length &lt;= 1) return array;\n\n    let pivotIndex = Math.floor(array.length / 2);\n\n    let pivot = array.splice(pivotIndex, 1)[0];\n\n    let left = [], right = [];\n\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        if (pivot &gt; array[i]) &#123;\n            left.push(array[i]);\n        &#125;\n        if (pivot &lt; array[i]) &#123;\n            right.push(array[i]);\n        &#125;\n    &#125;\n\n    return quickSort(left).concat([pivotIndex], quickSort(right));\n\n&#125;\n</code></pre>\n<p><code>思想</code></p>\n<ol>\n<li>如果数组只有这一个成员变量就直接返回该数组</li>\n<li>如果数组成员变量有多个，就在数组中找一个基准元素，然后根据这个基准将整个数组分为三部分:左侧，基准，右侧.最后递归调用quickSort</li>\n</ol>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 冒泡排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction bubblingSort(array) &#123;\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        for (let j = i + 1; j &lt; array.length; j++) &#123;\n            if (array[i] &lt; array[j]) &#123;\n                [array[i], array[j]] = [array[j], array[i]];\n            &#125;\n        &#125;\n    &#125;\n    return array;\n&#125;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>两两比较数组元素之家的大小关系，如果前一个小于后一个，就交换，否则就不换</li>\n</ol>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">\nfunction mergeSort(array)&#123;\n\n    if(array.length&lt;=1)return array;\n\n    const len = array.length;\n    const mid = Math.floor(len/2);\n\n    const left = array.slice(0,mid);\n    const right = array.slice(mid,length);\n\n    return merge(mergeSort(left),mergeSort(right))\n\n&#125;\n\nfunction merge(left,right)&#123;\n\n    const result = [];\n    let il = 0;\n    let ir = 0;\n\n    wihle(il&lt;left.length&amp;&amp;ir&lt;right.length)&#123;\n        if(left[il]&lt;right[ir])&#123;\n            result.push(left[il]);\n            il++;\n        &#125;else&#123;\n            result.push(left[ir]);\n            ir++;\n        &#125;\n    &#125;\n\n    while(il&lt;left.length)&#123;\n        result.push(left[il]);\n        il++;\n    &#125;\n\n    while(ir&lt;right.length)&#123;\n        result.push(right[ir]);\n        ir++;\n    &#125;\n\n    return result;\n\n&#125;\n\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>如果数组的长度为1，则直接返回该数组</li>\n<li>如果数组的长度大于1，则将该数组分为左右两部分，然后递归分解（即左侧再分解左右，右侧再分解左右）</li>\n<li>然后当分解完成后，两两合并(在这个阶段完成数组的排序)，最终合并成一个已排好序的数组</li>\n</ol>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n* \n* @param &#123;Array&#125; array \n*/\nfunction heapSort(array) &#123;\n  let len = array.length;\n  for (let i = Math.floor(len / 2 -1); i &gt;= 0; i--) &#123;\n      adjustHeap(array, i,len);\n  &#125;\n  for (let i = len - 1; i &gt; 0; i--) &#123;\n      swap(array,0,i);\n      adjustHeap(array,0, i);\n  &#125;\n  return array\n&#125;\n\n/**\n* \n* @param &#123;Array&#125; array \n* @param &#123;Number&#125; i \n*/\nfunction adjustHeap(array, i,length) &#123;\n  for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) &#123;\n      temp = array[i];\n      if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) &#123;\n          j++;\n      &#125;\n      if (temp &lt; array[j]) &#123;\n          swap(array,i,j);\n          i = j;\n      &#125; else &#123;\n          break;\n      &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>将数组构建成一个最大堆</li>\n<li>将数组的根节点移动到最前面，然后调整堆</li>\n<li>这样就可以完成对数组的排序</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 插入排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction insertSort(array) &#123;\n    let temp;\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        temp = array[i];\n        for (let j = i; j &gt; 0 &amp;&amp; temp &lt; array[j - 1]; j--) &#123;\n            array[j] = array[j - 1];\n        &#125;\n        array[j] = temp;\n    &#125;\n    return array;\n&#125;\n\n// ----------- test\ninsertSort([3,1,2]) // [1,2,3]\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>插入排序 &#x3D; 元素插入 + 顺序插入</li>\n<li>数组的第一个元素不动，第二个元素找左侧比它小的边界元素，然后插在该边界元素的左侧</li>\n<li>第三个元素类型，以此类推插完数组中的所有元素</li>\n</ol>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 快速排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction quickSort(array) &#123;\n\n    if (array.length &lt;= 1) return array;\n\n    let pivotIndex = Math.floor(array.length / 2);\n\n    let pivot = array.splice(pivotIndex, 1)[0];\n\n    let left = [], right = [];\n\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        if (pivot &gt; array[i]) &#123;\n            left.push(array[i]);\n        &#125;\n        if (pivot &lt; array[i]) &#123;\n            right.push(array[i]);\n        &#125;\n    &#125;\n\n    return quickSort(left).concat([pivotIndex], quickSort(right));\n\n&#125;\n</code></pre>\n<p><code>思想</code></p>\n<ol>\n<li>如果数组只有这一个成员变量就直接返回该数组</li>\n<li>如果数组成员变量有多个，就在数组中找一个基准元素，然后根据这个基准将整个数组分为三部分:左侧，基准，右侧.最后递归调用quickSort</li>\n</ol>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n * 冒泡排序\n * @param &#123;Array&#125; array 要排序的数组\n */\nfunction bubblingSort(array) &#123;\n    for (let i = 0; i &lt; array.length; i++) &#123;\n        for (let j = i + 1; j &lt; array.length; j++) &#123;\n            if (array[i] &lt; array[j]) &#123;\n                [array[i], array[j]] = [array[j], array[i]];\n            &#125;\n        &#125;\n    &#125;\n    return array;\n&#125;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>两两比较数组元素之家的大小关系，如果前一个小于后一个，就交换，否则就不换</li>\n</ol>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">\nfunction mergeSort(array)&#123;\n\n    if(array.length&lt;=1)return array;\n\n    const len = array.length;\n    const mid = Math.floor(len/2);\n\n    const left = array.slice(0,mid);\n    const right = array.slice(mid,length);\n\n    return merge(mergeSort(left),mergeSort(right))\n\n&#125;\n\nfunction merge(left,right)&#123;\n\n    const result = [];\n    let il = 0;\n    let ir = 0;\n\n    wihle(il&lt;left.length&amp;&amp;ir&lt;right.length)&#123;\n        if(left[il]&lt;right[ir])&#123;\n            result.push(left[il]);\n            il++;\n        &#125;else&#123;\n            result.push(left[ir]);\n            ir++;\n        &#125;\n    &#125;\n\n    while(il&lt;left.length)&#123;\n        result.push(left[il]);\n        il++;\n    &#125;\n\n    while(ir&lt;right.length)&#123;\n        result.push(right[ir]);\n        ir++;\n    &#125;\n\n    return result;\n\n&#125;\n\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>如果数组的长度为1，则直接返回该数组</li>\n<li>如果数组的长度大于1，则将该数组分为左右两部分，然后递归分解（即左侧再分解左右，右侧再分解左右）</li>\n<li>然后当分解完成后，两两合并(在这个阶段完成数组的排序)，最终合并成一个已排好序的数组</li>\n</ol>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p><code>代码</code></p>\n<pre><code class=\"js\">/**\n* \n* @param &#123;Array&#125; array \n*/\nfunction heapSort(array) &#123;\n  let len = array.length;\n  for (let i = Math.floor(len / 2 -1); i &gt;= 0; i--) &#123;\n      adjustHeap(array, i,len);\n  &#125;\n  for (let i = len - 1; i &gt; 0; i--) &#123;\n      swap(array,0,i);\n      adjustHeap(array,0, i);\n  &#125;\n  return array\n&#125;\n\n/**\n* \n* @param &#123;Array&#125; array \n* @param &#123;Number&#125; i \n*/\nfunction adjustHeap(array, i,length) &#123;\n  for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) &#123;\n      temp = array[i];\n      if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) &#123;\n          j++;\n      &#125;\n      if (temp &lt; array[j]) &#123;\n          swap(array,i,j);\n          i = j;\n      &#125; else &#123;\n          break;\n      &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>将数组构建成一个最大堆</li>\n<li>将数组的根节点移动到最前面，然后调整堆</li>\n<li>这样就可以完成对数组的排序</li>\n</ol>\n"},{"title":"Generator对象","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES6","date":"2019-12-10T16:00:00.000Z","comments":0,"description":"Generator","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Generator_bg.jpg"],"_content":"## Generator原型\n\n方法\n1. [Generator.prototype.next()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/next)\n2. [Generator.prototype.return()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)\n3. [Generator.prototype.throw()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw)\n\n## 基本使用\n1. Generator对象与一种函数密切相关 Generator函数。我们在执行Generator函数，该函数不会立刻执行，而是会返回一个Generator对象。我们通过操作Generator对象来控制Generator函数的运行\n2. Generator函数的函数体中，通过yield关键字将函数的执行过程分成了好几个阶段。\n3. 当我们调用Generator对象的next方法时，Generator函数会向下执行，直至遇到关键字yield就停止，并且返回关键字yield后面的表达式的值。\n\n```js\n/**\n* Generator函数定义\n*/\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n// 执行Generator函数，返回一个Generator对象\nvar g = gen();\n// [object GeneratorFunction] 查看gen类型\nconsole.log(Object.prototype.toString.call(gen));\n// [object Generator] 查看g类型\nconsole.log(Object.prototype.toString.call(g));\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 3\nconsole.log(g.next().value);\n// undefined \nconsole.log(g.next().value);\n```\n\n4. 我们可以为Generator对象在执行next方法执行时传入参数，作为函数下一个阶段运行的输入\n\n```js\n// 定义Generator函数\nfunction *gen(){\n    yield 1;\n    let i = yield 2;\n    yield i;\n}\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 12\nconsole.log(g.next(12).value);\n```\n\n5. 而当生成器函数显示return时，该函数立即变为完成状态。且return返回的值是此次调用iterator.next()返回对象的属性名为value的值。\n\n```js\n// 定义Generator函数\nfunction *gen(){\n    yield 1;\n    yield 2;\n    return 14;\n    yield 3;\n}\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 14\nconsole.log(g.next().value);\n```\n\n## 高级用法\n\n1. 函数执行权转移\n\n我们可以通过Generator函数来实现函数执行时执行函数主体的转移\n\n```js\n// 定义Generator函数 gen1\nfunction *gen1(){\n    yield \"gen1 1\";\n    yield \"gen1 2\";\n    yield \"gen1 3\";\n}\n// 定义Generator函数 gen2\nfunction *gen2(){\n    yield \"gen2 1\";\n    yield* gen1();\n    yield \"gen2 3\";\n}\n// 执行gen2函数返回一个Generator对象\nvar g = gen2();\n// gen2 1\nconsole.log(g.next().value);\n// gen1 1 \nconsole.log(g.next().value);\n// gen1 2\nconsole.log(g.next().value);\n// gen1 3\nconsole.log(g.next().value);\n// gen2 3\nconsole.log(g.next().value);\n// undefined\nconsole.log(g.next().value);\n```\n\n2. 将嵌套数组转化为扁平一维数组，[来自MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*)\n\n```js\nfunction* iterArr(arr){\n    if(Array.isArray(arr)){\n        for(let i=0;i<arr.length;i++){\n            yield* iterArr(arr[i]);\n        }   \n    }else{\n        yield arr;\n    }\n}\n   \nvar arr = ['a', ['b', 'c'], ['d', 'e']];\nvar gen = iterArr(arr);\narr = [...gen];\n```\n\n3. 遍历二叉树，来自阮一峰老师的[es6](http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw)\n\n```js\n// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) {\n    this.left = left;\n    this.right = right;\n    this.label = label;\n}\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) {\n    if (t) {\n        yield* inorder(t.left);\n        yield t.label;\n        yield* inorder(t.right);\n    }\n}\n// 下面生成二叉树\nfunction make(array) {\n    // 判断是否为叶节点\n    if (array.length == 1) return new Tree(null, array[0], null);\n    return new Tree(make(array[0]), array[1], make(array[2]));\n}\nlet tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);\n   \nvar result = [];\nfor (let node of inorder(tree)) {\n    result.push(node);\n}\n   \nconsole.log(result);\n```\n\n4. 使用Generator构建构造函数，来控制实例对象的实例化过程\n\n```js\n// Generator函数\nfunction *gen(){\n    yield this.a = 1;\n    yield this.b = 2;\n    yield this.c = 3;\n}\n// 构造函数F\nfunction F(){\n    // 在当前对象挂载一个属性next,用于控制gen函数的运行\n    this.next = gen.call(this);\n}\n// 使用构造函数F\nvar f = new F();\n// F {next: gen}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1, b: 2}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1, b: 2, c: 3}\nconsole.log(f);\n```\n   \n5. 使用Generator来实现异步编程\n\n我们可以使用Generator函数来控制异步操作的工作流程\n\n```js\n// 异步操作函数f1\nfunction f1() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f1\")\n            resolve(\"第一阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 异步操作函数f2\nfunction f2() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f2\")\n            resolve(\"第二阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 异步操作函数f3\nfunction f3() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f3\")\n            resolve(\"第三阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 操控一系列异步操作流程的Generator函数\nfunction *gen(){\n    yield f1();\n    yield f2();\n    yield f3();\n}\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// 开始异步第一阶段操作\ng.next().value.then((res)=>{\n    console.log(res);\n    // 异步第一阶段操作完成，开始异步第二阶段操作\n    return g.next().value\n}).then((res)=>{\n    console.log(res);\n    // 异步第二阶段操作完成，开始异步第三阶段操作\n    return g.next().value;\n}).then((res)=>{\n    console.log(res);\n}).catch((err)=>{\n    console.log(err);\n})\n// 同步执行\nconsole.log(\"hello world\");\n```\n\n## Generator对象和Generator函数\n\n```js\n// Generator函数\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// [object Generator]\nconsole.log(Object.prototype.toString.call(g));\n// [object GeneratorFunction]\nconsole.log(Object.prototype.toString.call(gen));\n// true\n/**\n * 这个结果说明g的__proto__属性指向函数gen的原型\n * 可以与构造函数与由构造函数创建的实例对象进行比较\n */\nconsole.log(g.__proto__ == gen.prototype);\n// 构造函数A\nfunction A(){\n    this.a = 1;\n    this.b = 2;\n}\n// 实例对象a\nvar a = new A();\n// true\nconsole.log(a.__proto__ == A.prototype);\n```\n\n\n\n​上面的输出结果结果说明，generator实例对象是指向generator函数的原型，而generator函数的原型就是对象Generator","source":"_posts/前端/ES6/Generator对象和Generator函数.md","raw":"---\ntitle: Generator对象\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - ES6\nkeywords: ES6\ndate: 2019-12-11\ncomments: false\ndescription: Generator\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Generator_bg.jpg\n---\n## Generator原型\n\n方法\n1. [Generator.prototype.next()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/next)\n2. [Generator.prototype.return()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)\n3. [Generator.prototype.throw()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw)\n\n## 基本使用\n1. Generator对象与一种函数密切相关 Generator函数。我们在执行Generator函数，该函数不会立刻执行，而是会返回一个Generator对象。我们通过操作Generator对象来控制Generator函数的运行\n2. Generator函数的函数体中，通过yield关键字将函数的执行过程分成了好几个阶段。\n3. 当我们调用Generator对象的next方法时，Generator函数会向下执行，直至遇到关键字yield就停止，并且返回关键字yield后面的表达式的值。\n\n```js\n/**\n* Generator函数定义\n*/\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n// 执行Generator函数，返回一个Generator对象\nvar g = gen();\n// [object GeneratorFunction] 查看gen类型\nconsole.log(Object.prototype.toString.call(gen));\n// [object Generator] 查看g类型\nconsole.log(Object.prototype.toString.call(g));\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 3\nconsole.log(g.next().value);\n// undefined \nconsole.log(g.next().value);\n```\n\n4. 我们可以为Generator对象在执行next方法执行时传入参数，作为函数下一个阶段运行的输入\n\n```js\n// 定义Generator函数\nfunction *gen(){\n    yield 1;\n    let i = yield 2;\n    yield i;\n}\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 12\nconsole.log(g.next(12).value);\n```\n\n5. 而当生成器函数显示return时，该函数立即变为完成状态。且return返回的值是此次调用iterator.next()返回对象的属性名为value的值。\n\n```js\n// 定义Generator函数\nfunction *gen(){\n    yield 1;\n    yield 2;\n    return 14;\n    yield 3;\n}\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 14\nconsole.log(g.next().value);\n```\n\n## 高级用法\n\n1. 函数执行权转移\n\n我们可以通过Generator函数来实现函数执行时执行函数主体的转移\n\n```js\n// 定义Generator函数 gen1\nfunction *gen1(){\n    yield \"gen1 1\";\n    yield \"gen1 2\";\n    yield \"gen1 3\";\n}\n// 定义Generator函数 gen2\nfunction *gen2(){\n    yield \"gen2 1\";\n    yield* gen1();\n    yield \"gen2 3\";\n}\n// 执行gen2函数返回一个Generator对象\nvar g = gen2();\n// gen2 1\nconsole.log(g.next().value);\n// gen1 1 \nconsole.log(g.next().value);\n// gen1 2\nconsole.log(g.next().value);\n// gen1 3\nconsole.log(g.next().value);\n// gen2 3\nconsole.log(g.next().value);\n// undefined\nconsole.log(g.next().value);\n```\n\n2. 将嵌套数组转化为扁平一维数组，[来自MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*)\n\n```js\nfunction* iterArr(arr){\n    if(Array.isArray(arr)){\n        for(let i=0;i<arr.length;i++){\n            yield* iterArr(arr[i]);\n        }   \n    }else{\n        yield arr;\n    }\n}\n   \nvar arr = ['a', ['b', 'c'], ['d', 'e']];\nvar gen = iterArr(arr);\narr = [...gen];\n```\n\n3. 遍历二叉树，来自阮一峰老师的[es6](http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw)\n\n```js\n// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) {\n    this.left = left;\n    this.right = right;\n    this.label = label;\n}\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) {\n    if (t) {\n        yield* inorder(t.left);\n        yield t.label;\n        yield* inorder(t.right);\n    }\n}\n// 下面生成二叉树\nfunction make(array) {\n    // 判断是否为叶节点\n    if (array.length == 1) return new Tree(null, array[0], null);\n    return new Tree(make(array[0]), array[1], make(array[2]));\n}\nlet tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);\n   \nvar result = [];\nfor (let node of inorder(tree)) {\n    result.push(node);\n}\n   \nconsole.log(result);\n```\n\n4. 使用Generator构建构造函数，来控制实例对象的实例化过程\n\n```js\n// Generator函数\nfunction *gen(){\n    yield this.a = 1;\n    yield this.b = 2;\n    yield this.c = 3;\n}\n// 构造函数F\nfunction F(){\n    // 在当前对象挂载一个属性next,用于控制gen函数的运行\n    this.next = gen.call(this);\n}\n// 使用构造函数F\nvar f = new F();\n// F {next: gen}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1, b: 2}\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F {next: gen, a: 1, b: 2, c: 3}\nconsole.log(f);\n```\n   \n5. 使用Generator来实现异步编程\n\n我们可以使用Generator函数来控制异步操作的工作流程\n\n```js\n// 异步操作函数f1\nfunction f1() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f1\")\n            resolve(\"第一阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 异步操作函数f2\nfunction f2() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f2\")\n            resolve(\"第二阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 异步操作函数f3\nfunction f3() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"f3\")\n            resolve(\"第三阶段异步工作完成\")\n        }, 3000);\n    });\n}\n// 操控一系列异步操作流程的Generator函数\nfunction *gen(){\n    yield f1();\n    yield f2();\n    yield f3();\n}\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// 开始异步第一阶段操作\ng.next().value.then((res)=>{\n    console.log(res);\n    // 异步第一阶段操作完成，开始异步第二阶段操作\n    return g.next().value\n}).then((res)=>{\n    console.log(res);\n    // 异步第二阶段操作完成，开始异步第三阶段操作\n    return g.next().value;\n}).then((res)=>{\n    console.log(res);\n}).catch((err)=>{\n    console.log(err);\n})\n// 同步执行\nconsole.log(\"hello world\");\n```\n\n## Generator对象和Generator函数\n\n```js\n// Generator函数\nfunction* gen() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// [object Generator]\nconsole.log(Object.prototype.toString.call(g));\n// [object GeneratorFunction]\nconsole.log(Object.prototype.toString.call(gen));\n// true\n/**\n * 这个结果说明g的__proto__属性指向函数gen的原型\n * 可以与构造函数与由构造函数创建的实例对象进行比较\n */\nconsole.log(g.__proto__ == gen.prototype);\n// 构造函数A\nfunction A(){\n    this.a = 1;\n    this.b = 2;\n}\n// 实例对象a\nvar a = new A();\n// true\nconsole.log(a.__proto__ == A.prototype);\n```\n\n\n\n​上面的输出结果结果说明，generator实例对象是指向generator函数的原型，而generator函数的原型就是对象Generator","slug":"前端/ES6/Generator对象和Generator函数","published":1,"updated":"2023-05-12T23:28:10.992Z","layout":"post","link":"","_id":"clhws1t2o000r2h17d3pafu6n","content":"<h2 id=\"Generator原型\"><a href=\"#Generator原型\" class=\"headerlink\" title=\"Generator原型\"></a>Generator原型</h2><p>方法</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/next\">Generator.prototype.next()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/return\">Generator.prototype.return()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\">Generator.prototype.throw()</a></li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li>Generator对象与一种函数密切相关 Generator函数。我们在执行Generator函数，该函数不会立刻执行，而是会返回一个Generator对象。我们通过操作Generator对象来控制Generator函数的运行</li>\n<li>Generator函数的函数体中，通过yield关键字将函数的执行过程分成了好几个阶段。</li>\n<li>当我们调用Generator对象的next方法时，Generator函数会向下执行，直至遇到关键字yield就停止，并且返回关键字yield后面的表达式的值。</li>\n</ol>\n<pre><code class=\"js\">/**\n* Generator函数定义\n*/\nfunction* gen() &#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\n// 执行Generator函数，返回一个Generator对象\nvar g = gen();\n// [object GeneratorFunction] 查看gen类型\nconsole.log(Object.prototype.toString.call(gen));\n// [object Generator] 查看g类型\nconsole.log(Object.prototype.toString.call(g));\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 3\nconsole.log(g.next().value);\n// undefined \nconsole.log(g.next().value);\n</code></pre>\n<ol start=\"4\">\n<li>我们可以为Generator对象在执行next方法执行时传入参数，作为函数下一个阶段运行的输入</li>\n</ol>\n<pre><code class=\"js\">// 定义Generator函数\nfunction *gen()&#123;\n    yield 1;\n    let i = yield 2;\n    yield i;\n&#125;\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 12\nconsole.log(g.next(12).value);\n</code></pre>\n<ol start=\"5\">\n<li>而当生成器函数显示return时，该函数立即变为完成状态。且return返回的值是此次调用iterator.next()返回对象的属性名为value的值。</li>\n</ol>\n<pre><code class=\"js\">// 定义Generator函数\nfunction *gen()&#123;\n    yield 1;\n    yield 2;\n    return 14;\n    yield 3;\n&#125;\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 14\nconsole.log(g.next().value);\n</code></pre>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ol>\n<li>函数执行权转移</li>\n</ol>\n<p>我们可以通过Generator函数来实现函数执行时执行函数主体的转移</p>\n<pre><code class=\"js\">// 定义Generator函数 gen1\nfunction *gen1()&#123;\n    yield &quot;gen1 1&quot;;\n    yield &quot;gen1 2&quot;;\n    yield &quot;gen1 3&quot;;\n&#125;\n// 定义Generator函数 gen2\nfunction *gen2()&#123;\n    yield &quot;gen2 1&quot;;\n    yield* gen1();\n    yield &quot;gen2 3&quot;;\n&#125;\n// 执行gen2函数返回一个Generator对象\nvar g = gen2();\n// gen2 1\nconsole.log(g.next().value);\n// gen1 1 \nconsole.log(g.next().value);\n// gen1 2\nconsole.log(g.next().value);\n// gen1 3\nconsole.log(g.next().value);\n// gen2 3\nconsole.log(g.next().value);\n// undefined\nconsole.log(g.next().value);\n</code></pre>\n<ol start=\"2\">\n<li>将嵌套数组转化为扁平一维数组，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*\">来自MDN</a></li>\n</ol>\n<pre><code class=\"js\">function* iterArr(arr)&#123;\n    if(Array.isArray(arr))&#123;\n        for(let i=0;i&lt;arr.length;i++)&#123;\n            yield* iterArr(arr[i]);\n        &#125;   \n    &#125;else&#123;\n        yield arr;\n    &#125;\n&#125;\n   \nvar arr = [&#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;]];\nvar gen = iterArr(arr);\narr = [...gen];\n</code></pre>\n<ol start=\"3\">\n<li>遍历二叉树，来自阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw\">es6</a></li>\n</ol>\n<pre><code class=\"js\">// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) &#123;\n    this.left = left;\n    this.right = right;\n    this.label = label;\n&#125;\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) &#123;\n    if (t) &#123;\n        yield* inorder(t.left);\n        yield t.label;\n        yield* inorder(t.right);\n    &#125;\n&#125;\n// 下面生成二叉树\nfunction make(array) &#123;\n    // 判断是否为叶节点\n    if (array.length == 1) return new Tree(null, array[0], null);\n    return new Tree(make(array[0]), array[1], make(array[2]));\n&#125;\nlet tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);\n   \nvar result = [];\nfor (let node of inorder(tree)) &#123;\n    result.push(node);\n&#125;\n   \nconsole.log(result);\n</code></pre>\n<ol start=\"4\">\n<li>使用Generator构建构造函数，来控制实例对象的实例化过程</li>\n</ol>\n<pre><code class=\"js\">// Generator函数\nfunction *gen()&#123;\n    yield this.a = 1;\n    yield this.b = 2;\n    yield this.c = 3;\n&#125;\n// 构造函数F\nfunction F()&#123;\n    // 在当前对象挂载一个属性next,用于控制gen函数的运行\n    this.next = gen.call(this);\n&#125;\n// 使用构造函数F\nvar f = new F();\n// F &#123;next: gen&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1, b: 2&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1, b: 2, c: 3&#125;\nconsole.log(f);\n</code></pre>\n<ol start=\"5\">\n<li>使用Generator来实现异步编程</li>\n</ol>\n<p>我们可以使用Generator函数来控制异步操作的工作流程</p>\n<pre><code class=\"js\">// 异步操作函数f1\nfunction f1() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f1&quot;)\n            resolve(&quot;第一阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 异步操作函数f2\nfunction f2() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f2&quot;)\n            resolve(&quot;第二阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 异步操作函数f3\nfunction f3() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f3&quot;)\n            resolve(&quot;第三阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 操控一系列异步操作流程的Generator函数\nfunction *gen()&#123;\n    yield f1();\n    yield f2();\n    yield f3();\n&#125;\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// 开始异步第一阶段操作\ng.next().value.then((res)=&gt;&#123;\n    console.log(res);\n    // 异步第一阶段操作完成，开始异步第二阶段操作\n    return g.next().value\n&#125;).then((res)=&gt;&#123;\n    console.log(res);\n    // 异步第二阶段操作完成，开始异步第三阶段操作\n    return g.next().value;\n&#125;).then((res)=&gt;&#123;\n    console.log(res);\n&#125;).catch((err)=&gt;&#123;\n    console.log(err);\n&#125;)\n// 同步执行\nconsole.log(&quot;hello world&quot;);\n</code></pre>\n<h2 id=\"Generator对象和Generator函数\"><a href=\"#Generator对象和Generator函数\" class=\"headerlink\" title=\"Generator对象和Generator函数\"></a>Generator对象和Generator函数</h2><pre><code class=\"js\">// Generator函数\nfunction* gen() &#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// [object Generator]\nconsole.log(Object.prototype.toString.call(g));\n// [object GeneratorFunction]\nconsole.log(Object.prototype.toString.call(gen));\n// true\n/**\n * 这个结果说明g的__proto__属性指向函数gen的原型\n * 可以与构造函数与由构造函数创建的实例对象进行比较\n */\nconsole.log(g.__proto__ == gen.prototype);\n// 构造函数A\nfunction A()&#123;\n    this.a = 1;\n    this.b = 2;\n&#125;\n// 实例对象a\nvar a = new A();\n// true\nconsole.log(a.__proto__ == A.prototype);\n</code></pre>\n<p>​上面的输出结果结果说明，generator实例对象是指向generator函数的原型，而generator函数的原型就是对象Generator</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Generator原型\"><a href=\"#Generator原型\" class=\"headerlink\" title=\"Generator原型\"></a>Generator原型</h2><p>方法</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/next\">Generator.prototype.next()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/return\">Generator.prototype.return()</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\">Generator.prototype.throw()</a></li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><ol>\n<li>Generator对象与一种函数密切相关 Generator函数。我们在执行Generator函数，该函数不会立刻执行，而是会返回一个Generator对象。我们通过操作Generator对象来控制Generator函数的运行</li>\n<li>Generator函数的函数体中，通过yield关键字将函数的执行过程分成了好几个阶段。</li>\n<li>当我们调用Generator对象的next方法时，Generator函数会向下执行，直至遇到关键字yield就停止，并且返回关键字yield后面的表达式的值。</li>\n</ol>\n<pre><code class=\"js\">/**\n* Generator函数定义\n*/\nfunction* gen() &#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\n// 执行Generator函数，返回一个Generator对象\nvar g = gen();\n// [object GeneratorFunction] 查看gen类型\nconsole.log(Object.prototype.toString.call(gen));\n// [object Generator] 查看g类型\nconsole.log(Object.prototype.toString.call(g));\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 3\nconsole.log(g.next().value);\n// undefined \nconsole.log(g.next().value);\n</code></pre>\n<ol start=\"4\">\n<li>我们可以为Generator对象在执行next方法执行时传入参数，作为函数下一个阶段运行的输入</li>\n</ol>\n<pre><code class=\"js\">// 定义Generator函数\nfunction *gen()&#123;\n    yield 1;\n    let i = yield 2;\n    yield i;\n&#125;\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 12\nconsole.log(g.next(12).value);\n</code></pre>\n<ol start=\"5\">\n<li>而当生成器函数显示return时，该函数立即变为完成状态。且return返回的值是此次调用iterator.next()返回对象的属性名为value的值。</li>\n</ol>\n<pre><code class=\"js\">// 定义Generator函数\nfunction *gen()&#123;\n    yield 1;\n    yield 2;\n    return 14;\n    yield 3;\n&#125;\n// 执行函数，该函数返回Generator对象\nvar g = gen();\n// 1\nconsole.log(g.next().value);\n// 2\nconsole.log(g.next().value);\n// 14\nconsole.log(g.next().value);\n</code></pre>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><ol>\n<li>函数执行权转移</li>\n</ol>\n<p>我们可以通过Generator函数来实现函数执行时执行函数主体的转移</p>\n<pre><code class=\"js\">// 定义Generator函数 gen1\nfunction *gen1()&#123;\n    yield &quot;gen1 1&quot;;\n    yield &quot;gen1 2&quot;;\n    yield &quot;gen1 3&quot;;\n&#125;\n// 定义Generator函数 gen2\nfunction *gen2()&#123;\n    yield &quot;gen2 1&quot;;\n    yield* gen1();\n    yield &quot;gen2 3&quot;;\n&#125;\n// 执行gen2函数返回一个Generator对象\nvar g = gen2();\n// gen2 1\nconsole.log(g.next().value);\n// gen1 1 \nconsole.log(g.next().value);\n// gen1 2\nconsole.log(g.next().value);\n// gen1 3\nconsole.log(g.next().value);\n// gen2 3\nconsole.log(g.next().value);\n// undefined\nconsole.log(g.next().value);\n</code></pre>\n<ol start=\"2\">\n<li>将嵌套数组转化为扁平一维数组，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*\">来自MDN</a></li>\n</ol>\n<pre><code class=\"js\">function* iterArr(arr)&#123;\n    if(Array.isArray(arr))&#123;\n        for(let i=0;i&lt;arr.length;i++)&#123;\n            yield* iterArr(arr[i]);\n        &#125;   \n    &#125;else&#123;\n        yield arr;\n    &#125;\n&#125;\n   \nvar arr = [&#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;]];\nvar gen = iterArr(arr);\narr = [...gen];\n</code></pre>\n<ol start=\"3\">\n<li>遍历二叉树，来自阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/generator#Generator-prototype-throw\">es6</a></li>\n</ol>\n<pre><code class=\"js\">// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) &#123;\n    this.left = left;\n    this.right = right;\n    this.label = label;\n&#125;\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) &#123;\n    if (t) &#123;\n        yield* inorder(t.left);\n        yield t.label;\n        yield* inorder(t.right);\n    &#125;\n&#125;\n// 下面生成二叉树\nfunction make(array) &#123;\n    // 判断是否为叶节点\n    if (array.length == 1) return new Tree(null, array[0], null);\n    return new Tree(make(array[0]), array[1], make(array[2]));\n&#125;\nlet tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);\n   \nvar result = [];\nfor (let node of inorder(tree)) &#123;\n    result.push(node);\n&#125;\n   \nconsole.log(result);\n</code></pre>\n<ol start=\"4\">\n<li>使用Generator构建构造函数，来控制实例对象的实例化过程</li>\n</ol>\n<pre><code class=\"js\">// Generator函数\nfunction *gen()&#123;\n    yield this.a = 1;\n    yield this.b = 2;\n    yield this.c = 3;\n&#125;\n// 构造函数F\nfunction F()&#123;\n    // 在当前对象挂载一个属性next,用于控制gen函数的运行\n    this.next = gen.call(this);\n&#125;\n// 使用构造函数F\nvar f = new F();\n// F &#123;next: gen&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1, b: 2&#125;\nconsole.log(f);\n// 运行gen函数\nf.next.next();\n// F &#123;next: gen, a: 1, b: 2, c: 3&#125;\nconsole.log(f);\n</code></pre>\n<ol start=\"5\">\n<li>使用Generator来实现异步编程</li>\n</ol>\n<p>我们可以使用Generator函数来控制异步操作的工作流程</p>\n<pre><code class=\"js\">// 异步操作函数f1\nfunction f1() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f1&quot;)\n            resolve(&quot;第一阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 异步操作函数f2\nfunction f2() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f2&quot;)\n            resolve(&quot;第二阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 异步操作函数f3\nfunction f3() &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;f3&quot;)\n            resolve(&quot;第三阶段异步工作完成&quot;)\n        &#125;, 3000);\n    &#125;);\n&#125;\n// 操控一系列异步操作流程的Generator函数\nfunction *gen()&#123;\n    yield f1();\n    yield f2();\n    yield f3();\n&#125;\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// 开始异步第一阶段操作\ng.next().value.then((res)=&gt;&#123;\n    console.log(res);\n    // 异步第一阶段操作完成，开始异步第二阶段操作\n    return g.next().value\n&#125;).then((res)=&gt;&#123;\n    console.log(res);\n    // 异步第二阶段操作完成，开始异步第三阶段操作\n    return g.next().value;\n&#125;).then((res)=&gt;&#123;\n    console.log(res);\n&#125;).catch((err)=&gt;&#123;\n    console.log(err);\n&#125;)\n// 同步执行\nconsole.log(&quot;hello world&quot;);\n</code></pre>\n<h2 id=\"Generator对象和Generator函数\"><a href=\"#Generator对象和Generator函数\" class=\"headerlink\" title=\"Generator对象和Generator函数\"></a>Generator对象和Generator函数</h2><pre><code class=\"js\">// Generator函数\nfunction* gen() &#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\n// 执行Generator函数，返回Generator对象\nvar g = gen();\n// [object Generator]\nconsole.log(Object.prototype.toString.call(g));\n// [object GeneratorFunction]\nconsole.log(Object.prototype.toString.call(gen));\n// true\n/**\n * 这个结果说明g的__proto__属性指向函数gen的原型\n * 可以与构造函数与由构造函数创建的实例对象进行比较\n */\nconsole.log(g.__proto__ == gen.prototype);\n// 构造函数A\nfunction A()&#123;\n    this.a = 1;\n    this.b = 2;\n&#125;\n// 实例对象a\nvar a = new A();\n// true\nconsole.log(a.__proto__ == A.prototype);\n</code></pre>\n<p>​上面的输出结果结果说明，generator实例对象是指向generator函数的原型，而generator函数的原型就是对象Generator</p>\n"},{"title":"Promise对象","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"Promise","date":"2020-03-10T16:00:00.000Z","comments":0,"description":"Promise对象","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Promise_bg.jpg"],"_content":"\n## 前言\nPromise对象，是ES6新出的对象，主要目的是为了处理异步操作\n\n异步操作：通常来讲是指当我们去执行一种操作时，我们无法立即得到函数所执行后的结果，需要等待一段时间才能得到函数执行后的结果\n常见的异步操作如下:\n1. 定时器\n2. 网络请求(例如ajax)\n3. 事件函数\n4. 文件读写\n5. 数据库连接\n6. 图片异步加载\n7. ......\n\n\n## 什么是Promise对象 \n\n​在我们学习Promise对象时，我们必须要清楚它是什么东西\n\n​Promise对象，其实本质上是一个**函数**，那么它是可以执行Function上的一些方法（call,apply,bind...）。从另外一个方面来讲，Promise对象其实是一个容器，在这个容器中我们可以去完成一些任务，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n\n```js\nObject.prototype.toString.call(Promise) // \"[object Function]\"\n```\n\n​那么，Promise对象究竟是什么东西，这里有两个定义\n\n\n1. 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\nPromise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。（网址：http://es6.ruanyifeng.com/#docs/promise）\n2. Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。（网址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise）\n\n\n​在我看来，Promise对象其实就是用于处于异步操作的函数。我们可以通过使用Promise对象来完成异步。至于如何使用Promise对象，后面会有提到。\n\n## 为什么会出现Promise对象\n\n​Promise对象的出现其实是为了解决回调函数的“回调地狱”问题  \n（关于回调地狱的相关问题可以阅读这篇文章：https://www.cnblogs.com/suihang/p/9595548.html）。\n\n​主要原因是如果我们使用回调函数的方法来进行异步操作，我们书写的代码的阅读性会变得非常的糟糕，而使用Promise对象就可以使我们编写的代码更加方便开发人员阅读（主要是因为Promise的链式调用）\n\n\n## Promise对象的基本认识\n\n​接下来，就是来说说Promise对象的一些基本概念。\n\n\n注意：我们要搞清楚我们应该什么时候使用Promise对象（一般只要我们需要异步操作的时候都可以使用Promise对象）。不要因为去使用Promise对象而去使用Promise对象\n\n\n\n\nPromise对象在执行开始到执行完成有以下几种状态\n1. *pending*: 初始状态，既不是成功，也不是失败状态。\n2. *fulfilled*: 意味着操作成功完成。\n3. *rejected*: 意味着操作失败。\n\n​pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。\n\n​当其中任一种情况出现时，Promise 对象的 `then` 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。\n\n1. 当Promise状态为*fulfilled*时，调用 then 的 onfulfilled 方法\n2. 当Promise状态为*rejected*时，调用 then 的 onrejected 方法\n\n\n​而为什么Promise可以被链式调用主要是因为 Promise.prototype.then和Promise.prototype.catch方法返回promise 对象， 所以它们可以被链式调用\n\n## Promise对象的基本使用\n**Promise对象所具有的属性**\n1. Promise.length  构造器参数的数目（其值总是为1）\n2. Promise.prototype Promise构造器的原型  \n\n**Promise对象所具有的方法**\n1. Promise.all \t\t\t并行运行异步操作\n2. Promise.race         并行运行异步操作\n3. Promise.reject       手动创建一个已经 resolve的Promise 快捷方法\n4. Promise.resolve    手动创建一个已经 reject 的Promise 快捷方法  \n\n**Promise原型**\n1. Promise.prototype.catch   抓取Promise执行过程中出现的异常和reject抛出的异常\n2. Promise.prototype.then    异步操作完成后所要执行的函数\n3. Promise.prototype.finally  无论promise状态最终都会执行的函数\n\n**Promise对象的简单用法（基本异步使用）**\n\n```js\n// 如果异步操作执行成功，则使用resolve来表示promise对象异步操作成功\n// 如果异步操作执行成功，则使用reject来表示promise对象异步操作失败\n// 其中，resolve和reject其实是一个回调函数，在执行的时候可以携带参数给异步操作执行完成后要处理的函数\nvar myPromise = new Promise((resovle, reject) => {\n\n    // 在这里我们执行以下异步操作\n    // 例如\n    // 1. 向后端接口请求数据,同时更新界面\n    // 2. 异步加载图片\n    // 3. 文件的读写操作\n    // 4. 数据库的相关操作\n    // 5. 等等\n    setTimeout(() => {\n        console.log(\"hello world\");\n        reject(\"execute failed!\");\n    }, 1000);\n\n});\n\n\n// 异步操作完成后向对应的处理函数\n// then(cb)     若异步操作执行成功就会跳入到该函数执行\n// catch(cb)    若异步操作执行失败就会跳入到该函数执行 \n// finally(cb)  无论异步操作执行成功还是失败都会跳入到该函数执行\nmyPromise.then((success) => {\n    // 处理异步操作成功的函数\n    console.log(`success value is ${success}`);\n}).catch((err) => {\n    // 处理异步操作失败的函数\n    console.log(`error value is ${err}`);\n}).finally(() => {\n    // 无论成功还是失败都会执行的函数\n    console.log(\"finally\")\n})\n\n```\n\n**一系列异步操作（系列异步操作）**\n\n```js\n// Promise最强大的地方就是可以进行链式调用，来避免以前遇到的回调地狱问题\n// 在执行一系列异步操作时，我们只要在最后.catch一下就可以抓获前面异步操作所可能出现的异常\n// 在执行异步操作时，如果后面还要进行下一个异步操作，那么需要在这个异步操作返回一个新的Promise供下面的then函数使用\n// 在进行一系列异步操作时，如果其中的一个异步操作出现异常，那么后续的异步操作就不会被执行\nnew Promise((resovle, reject) => {\n    \n    // 异步1\n    setTimeout(() => {\n        console.log(\"洗菜\");\n        resovle(\"洗菜完成\");\n    }, 1000);\n\n}).then((success) => {\n\n    \n    console.log(`success value is ${success}`);\n    return new Promise((resovle, reject) => {\n        // 异步2\n        setTimeout(() => {\n            console.log(\"做饭\");\n            // resovle(\"做饭完成\");\n            reject(\"做饭失败\");\n        }, 1000);\n    });\n\n}).then((success) => {\n\n    console.log(`success value is ${success}`);  \n    return new Promise((resovle, reject) => {\n        // 异步3\n        setTimeout(() => {\n            console.log(\"吃饭\");\n            resovle(\"吃饭成功\")\n            // reject(\"吃饭失败\");\n        }, 1000);\n    });\n\n\n}).then((success) => {\n\n    // 异步操作执行成功\n    console.log(`success value is ${success}`);\n\n}).catch((err) => {\n\n    // 异步操作链中出现异常错误\n    console.log(`error value is ${err}`);\n\n})\n```\n\n**可同时进行的异步操作(组合异步操作)**\n\n```js\n//在这里共有两组异步操作\n// 异步操作1 p1 洗澡\n// 异步操作2 p2 洗菜->做饭\nvar p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"洗澡\", new Date());\n        // resolve(\"洗澡完成\");\n        reject(\"洗澡失败\");\n    }, 1000);\n})\n\nvar p2 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"洗菜\", new Date());\n        resolve(\"洗菜完成\");\n        // reject(\"洗菜失败\");\n    }, 1000);\n}).then((res) => {\n    console.log(res, new Date())\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"做饭\", new Date());\n            // resolve(\"做饭完成\");\n            reject(\"做饭失败\");\n        }, 1000);\n    })\n});\n\n// 通过使用Promise.all来使得异步操作1和异步操作2同时进行\n// 然后在then回调函数中同时处理两个异步操作返回回来的结果\n// Promise.all在任意一个传入的 promise 失败时返回失败\nPromise.all([p1, p2]).then(([r1, r2]) => {\n    console.log(r1, r2, new Date());\n}).catch((err) => {\n    console.log(err.toString());\n})\n\n\n\nvar p4 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"我快一点\");\n        resolve(\"我快一点\");\n    }, 1000);s\n});\n\nvar p5 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"我慢一点\");\n        reject(\"我慢一点\");\n    }, 2000);\n});\n\n// 现在有3系列异步操作 p1,p2,p3\n// 如果p1异步操作完成的最快，则fastestValue为p1所返回的值，err也同理\n// 注意：即使慢一点的异步操作也不会因为快一点的异步操作而中途停止，只是then中回调函数的参数是快一点异步操作的返回值罢了\n// 即Promise.race([p1,p2,p3])返回的是执行快一点的Promise对象\nPromise.race([p4, p5]).then(fastestValue => {\n    console.log(fastestValue);\n}).catch((err) => {\n    console.log(err.toString());\n});\n```\n​\t","source":"_posts/前端/ES6/Promise对象.md","raw":"---\ntitle: Promise对象\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg  \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - Promise\nkeywords: Promise\ndate: 2020-03-11\ncomments: false\ndescription: Promise对象\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Promise_bg.jpg\n---\n\n## 前言\nPromise对象，是ES6新出的对象，主要目的是为了处理异步操作\n\n异步操作：通常来讲是指当我们去执行一种操作时，我们无法立即得到函数所执行后的结果，需要等待一段时间才能得到函数执行后的结果\n常见的异步操作如下:\n1. 定时器\n2. 网络请求(例如ajax)\n3. 事件函数\n4. 文件读写\n5. 数据库连接\n6. 图片异步加载\n7. ......\n\n\n## 什么是Promise对象 \n\n​在我们学习Promise对象时，我们必须要清楚它是什么东西\n\n​Promise对象，其实本质上是一个**函数**，那么它是可以执行Function上的一些方法（call,apply,bind...）。从另外一个方面来讲，Promise对象其实是一个容器，在这个容器中我们可以去完成一些任务，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n\n```js\nObject.prototype.toString.call(Promise) // \"[object Function]\"\n```\n\n​那么，Promise对象究竟是什么东西，这里有两个定义\n\n\n1. 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\nPromise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。（网址：http://es6.ruanyifeng.com/#docs/promise）\n2. Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。（网址：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise）\n\n\n​在我看来，Promise对象其实就是用于处于异步操作的函数。我们可以通过使用Promise对象来完成异步。至于如何使用Promise对象，后面会有提到。\n\n## 为什么会出现Promise对象\n\n​Promise对象的出现其实是为了解决回调函数的“回调地狱”问题  \n（关于回调地狱的相关问题可以阅读这篇文章：https://www.cnblogs.com/suihang/p/9595548.html）。\n\n​主要原因是如果我们使用回调函数的方法来进行异步操作，我们书写的代码的阅读性会变得非常的糟糕，而使用Promise对象就可以使我们编写的代码更加方便开发人员阅读（主要是因为Promise的链式调用）\n\n\n## Promise对象的基本认识\n\n​接下来，就是来说说Promise对象的一些基本概念。\n\n\n注意：我们要搞清楚我们应该什么时候使用Promise对象（一般只要我们需要异步操作的时候都可以使用Promise对象）。不要因为去使用Promise对象而去使用Promise对象\n\n\n\n\nPromise对象在执行开始到执行完成有以下几种状态\n1. *pending*: 初始状态，既不是成功，也不是失败状态。\n2. *fulfilled*: 意味着操作成功完成。\n3. *rejected*: 意味着操作失败。\n\n​pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。\n\n​当其中任一种情况出现时，Promise 对象的 `then` 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。\n\n1. 当Promise状态为*fulfilled*时，调用 then 的 onfulfilled 方法\n2. 当Promise状态为*rejected*时，调用 then 的 onrejected 方法\n\n\n​而为什么Promise可以被链式调用主要是因为 Promise.prototype.then和Promise.prototype.catch方法返回promise 对象， 所以它们可以被链式调用\n\n## Promise对象的基本使用\n**Promise对象所具有的属性**\n1. Promise.length  构造器参数的数目（其值总是为1）\n2. Promise.prototype Promise构造器的原型  \n\n**Promise对象所具有的方法**\n1. Promise.all \t\t\t并行运行异步操作\n2. Promise.race         并行运行异步操作\n3. Promise.reject       手动创建一个已经 resolve的Promise 快捷方法\n4. Promise.resolve    手动创建一个已经 reject 的Promise 快捷方法  \n\n**Promise原型**\n1. Promise.prototype.catch   抓取Promise执行过程中出现的异常和reject抛出的异常\n2. Promise.prototype.then    异步操作完成后所要执行的函数\n3. Promise.prototype.finally  无论promise状态最终都会执行的函数\n\n**Promise对象的简单用法（基本异步使用）**\n\n```js\n// 如果异步操作执行成功，则使用resolve来表示promise对象异步操作成功\n// 如果异步操作执行成功，则使用reject来表示promise对象异步操作失败\n// 其中，resolve和reject其实是一个回调函数，在执行的时候可以携带参数给异步操作执行完成后要处理的函数\nvar myPromise = new Promise((resovle, reject) => {\n\n    // 在这里我们执行以下异步操作\n    // 例如\n    // 1. 向后端接口请求数据,同时更新界面\n    // 2. 异步加载图片\n    // 3. 文件的读写操作\n    // 4. 数据库的相关操作\n    // 5. 等等\n    setTimeout(() => {\n        console.log(\"hello world\");\n        reject(\"execute failed!\");\n    }, 1000);\n\n});\n\n\n// 异步操作完成后向对应的处理函数\n// then(cb)     若异步操作执行成功就会跳入到该函数执行\n// catch(cb)    若异步操作执行失败就会跳入到该函数执行 \n// finally(cb)  无论异步操作执行成功还是失败都会跳入到该函数执行\nmyPromise.then((success) => {\n    // 处理异步操作成功的函数\n    console.log(`success value is ${success}`);\n}).catch((err) => {\n    // 处理异步操作失败的函数\n    console.log(`error value is ${err}`);\n}).finally(() => {\n    // 无论成功还是失败都会执行的函数\n    console.log(\"finally\")\n})\n\n```\n\n**一系列异步操作（系列异步操作）**\n\n```js\n// Promise最强大的地方就是可以进行链式调用，来避免以前遇到的回调地狱问题\n// 在执行一系列异步操作时，我们只要在最后.catch一下就可以抓获前面异步操作所可能出现的异常\n// 在执行异步操作时，如果后面还要进行下一个异步操作，那么需要在这个异步操作返回一个新的Promise供下面的then函数使用\n// 在进行一系列异步操作时，如果其中的一个异步操作出现异常，那么后续的异步操作就不会被执行\nnew Promise((resovle, reject) => {\n    \n    // 异步1\n    setTimeout(() => {\n        console.log(\"洗菜\");\n        resovle(\"洗菜完成\");\n    }, 1000);\n\n}).then((success) => {\n\n    \n    console.log(`success value is ${success}`);\n    return new Promise((resovle, reject) => {\n        // 异步2\n        setTimeout(() => {\n            console.log(\"做饭\");\n            // resovle(\"做饭完成\");\n            reject(\"做饭失败\");\n        }, 1000);\n    });\n\n}).then((success) => {\n\n    console.log(`success value is ${success}`);  \n    return new Promise((resovle, reject) => {\n        // 异步3\n        setTimeout(() => {\n            console.log(\"吃饭\");\n            resovle(\"吃饭成功\")\n            // reject(\"吃饭失败\");\n        }, 1000);\n    });\n\n\n}).then((success) => {\n\n    // 异步操作执行成功\n    console.log(`success value is ${success}`);\n\n}).catch((err) => {\n\n    // 异步操作链中出现异常错误\n    console.log(`error value is ${err}`);\n\n})\n```\n\n**可同时进行的异步操作(组合异步操作)**\n\n```js\n//在这里共有两组异步操作\n// 异步操作1 p1 洗澡\n// 异步操作2 p2 洗菜->做饭\nvar p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"洗澡\", new Date());\n        // resolve(\"洗澡完成\");\n        reject(\"洗澡失败\");\n    }, 1000);\n})\n\nvar p2 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"洗菜\", new Date());\n        resolve(\"洗菜完成\");\n        // reject(\"洗菜失败\");\n    }, 1000);\n}).then((res) => {\n    console.log(res, new Date())\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\"做饭\", new Date());\n            // resolve(\"做饭完成\");\n            reject(\"做饭失败\");\n        }, 1000);\n    })\n});\n\n// 通过使用Promise.all来使得异步操作1和异步操作2同时进行\n// 然后在then回调函数中同时处理两个异步操作返回回来的结果\n// Promise.all在任意一个传入的 promise 失败时返回失败\nPromise.all([p1, p2]).then(([r1, r2]) => {\n    console.log(r1, r2, new Date());\n}).catch((err) => {\n    console.log(err.toString());\n})\n\n\n\nvar p4 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"我快一点\");\n        resolve(\"我快一点\");\n    }, 1000);s\n});\n\nvar p5 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        console.log(\"我慢一点\");\n        reject(\"我慢一点\");\n    }, 2000);\n});\n\n// 现在有3系列异步操作 p1,p2,p3\n// 如果p1异步操作完成的最快，则fastestValue为p1所返回的值，err也同理\n// 注意：即使慢一点的异步操作也不会因为快一点的异步操作而中途停止，只是then中回调函数的参数是快一点异步操作的返回值罢了\n// 即Promise.race([p1,p2,p3])返回的是执行快一点的Promise对象\nPromise.race([p4, p5]).then(fastestValue => {\n    console.log(fastestValue);\n}).catch((err) => {\n    console.log(err.toString());\n});\n```\n​\t","slug":"前端/ES6/Promise对象","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2p000w2h17e27g6zz8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Promise对象，是ES6新出的对象，主要目的是为了处理异步操作</p>\n<p>异步操作：通常来讲是指当我们去执行一种操作时，我们无法立即得到函数所执行后的结果，需要等待一段时间才能得到函数执行后的结果<br>常见的异步操作如下:</p>\n<ol>\n<li>定时器</li>\n<li>网络请求(例如ajax)</li>\n<li>事件函数</li>\n<li>文件读写</li>\n<li>数据库连接</li>\n<li>图片异步加载</li>\n<li>……</li>\n</ol>\n<h2 id=\"什么是Promise对象\"><a href=\"#什么是Promise对象\" class=\"headerlink\" title=\"什么是Promise对象\"></a>什么是Promise对象</h2><p>​在我们学习Promise对象时，我们必须要清楚它是什么东西</p>\n<p>​Promise对象，其实本质上是一个<strong>函数</strong>，那么它是可以执行Function上的一些方法（call,apply,bind…）。从另外一个方面来讲，Promise对象其实是一个容器，在这个容器中我们可以去完成一些任务，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n<pre><code class=\"js\">Object.prototype.toString.call(Promise) // &quot;[object Function]&quot;\n</code></pre>\n<p>​那么，Promise对象究竟是什么东西，这里有两个定义</p>\n<ol>\n<li>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。<br>Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。（网址：<a href=\"http://es6.ruanyifeng.com/#docs/promise%EF%BC%89\">http://es6.ruanyifeng.com/#docs/promise）</a></li>\n<li>Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。（网址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise%EF%BC%89\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise）</a></li>\n</ol>\n<p>​在我看来，Promise对象其实就是用于处于异步操作的函数。我们可以通过使用Promise对象来完成异步。至于如何使用Promise对象，后面会有提到。</p>\n<h2 id=\"为什么会出现Promise对象\"><a href=\"#为什么会出现Promise对象\" class=\"headerlink\" title=\"为什么会出现Promise对象\"></a>为什么会出现Promise对象</h2><p>​Promise对象的出现其实是为了解决回调函数的“回调地狱”问题<br>（关于回调地狱的相关问题可以阅读这篇文章：<a href=\"https://www.cnblogs.com/suihang/p/9595548.html%EF%BC%89%E3%80%82\">https://www.cnblogs.com/suihang/p/9595548.html）。</a></p>\n<p>​主要原因是如果我们使用回调函数的方法来进行异步操作，我们书写的代码的阅读性会变得非常的糟糕，而使用Promise对象就可以使我们编写的代码更加方便开发人员阅读（主要是因为Promise的链式调用）</p>\n<h2 id=\"Promise对象的基本认识\"><a href=\"#Promise对象的基本认识\" class=\"headerlink\" title=\"Promise对象的基本认识\"></a>Promise对象的基本认识</h2><p>​接下来，就是来说说Promise对象的一些基本概念。</p>\n<p>注意：我们要搞清楚我们应该什么时候使用Promise对象（一般只要我们需要异步操作的时候都可以使用Promise对象）。不要因为去使用Promise对象而去使用Promise对象</p>\n<p>Promise对象在执行开始到执行完成有以下几种状态</p>\n<ol>\n<li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。</li>\n<li><em>fulfilled</em>: 意味着操作成功完成。</li>\n<li><em>rejected</em>: 意味着操作失败。</li>\n</ol>\n<p>​pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。</p>\n<p>​当其中任一种情况出现时，Promise 对象的 <code>then</code> 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。</p>\n<ol>\n<li>当Promise状态为<em>fulfilled</em>时，调用 then 的 onfulfilled 方法</li>\n<li>当Promise状态为<em>rejected</em>时，调用 then 的 onrejected 方法</li>\n</ol>\n<p>​而为什么Promise可以被链式调用主要是因为 Promise.prototype.then和Promise.prototype.catch方法返回promise 对象， 所以它们可以被链式调用</p>\n<h2 id=\"Promise对象的基本使用\"><a href=\"#Promise对象的基本使用\" class=\"headerlink\" title=\"Promise对象的基本使用\"></a>Promise对象的基本使用</h2><p><strong>Promise对象所具有的属性</strong></p>\n<ol>\n<li>Promise.length  构造器参数的数目（其值总是为1）</li>\n<li>Promise.prototype Promise构造器的原型</li>\n</ol>\n<p><strong>Promise对象所具有的方法</strong></p>\n<ol>\n<li>Promise.all \t\t\t并行运行异步操作</li>\n<li>Promise.race         并行运行异步操作</li>\n<li>Promise.reject       手动创建一个已经 resolve的Promise 快捷方法</li>\n<li>Promise.resolve    手动创建一个已经 reject 的Promise 快捷方法</li>\n</ol>\n<p><strong>Promise原型</strong></p>\n<ol>\n<li>Promise.prototype.catch   抓取Promise执行过程中出现的异常和reject抛出的异常</li>\n<li>Promise.prototype.then    异步操作完成后所要执行的函数</li>\n<li>Promise.prototype.finally  无论promise状态最终都会执行的函数</li>\n</ol>\n<p><strong>Promise对象的简单用法（基本异步使用）</strong></p>\n<pre><code class=\"js\">// 如果异步操作执行成功，则使用resolve来表示promise对象异步操作成功\n// 如果异步操作执行成功，则使用reject来表示promise对象异步操作失败\n// 其中，resolve和reject其实是一个回调函数，在执行的时候可以携带参数给异步操作执行完成后要处理的函数\nvar myPromise = new Promise((resovle, reject) =&gt; &#123;\n\n    // 在这里我们执行以下异步操作\n    // 例如\n    // 1. 向后端接口请求数据,同时更新界面\n    // 2. 异步加载图片\n    // 3. 文件的读写操作\n    // 4. 数据库的相关操作\n    // 5. 等等\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;hello world&quot;);\n        reject(&quot;execute failed!&quot;);\n    &#125;, 1000);\n\n&#125;);\n\n\n// 异步操作完成后向对应的处理函数\n// then(cb)     若异步操作执行成功就会跳入到该函数执行\n// catch(cb)    若异步操作执行失败就会跳入到该函数执行 \n// finally(cb)  无论异步操作执行成功还是失败都会跳入到该函数执行\nmyPromise.then((success) =&gt; &#123;\n    // 处理异步操作成功的函数\n    console.log(`success value is $&#123;success&#125;`);\n&#125;).catch((err) =&gt; &#123;\n    // 处理异步操作失败的函数\n    console.log(`error value is $&#123;err&#125;`);\n&#125;).finally(() =&gt; &#123;\n    // 无论成功还是失败都会执行的函数\n    console.log(&quot;finally&quot;)\n&#125;)\n</code></pre>\n<p><strong>一系列异步操作（系列异步操作）</strong></p>\n<pre><code class=\"js\">// Promise最强大的地方就是可以进行链式调用，来避免以前遇到的回调地狱问题\n// 在执行一系列异步操作时，我们只要在最后.catch一下就可以抓获前面异步操作所可能出现的异常\n// 在执行异步操作时，如果后面还要进行下一个异步操作，那么需要在这个异步操作返回一个新的Promise供下面的then函数使用\n// 在进行一系列异步操作时，如果其中的一个异步操作出现异常，那么后续的异步操作就不会被执行\nnew Promise((resovle, reject) =&gt; &#123;\n    \n    // 异步1\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗菜&quot;);\n        resovle(&quot;洗菜完成&quot;);\n    &#125;, 1000);\n\n&#125;).then((success) =&gt; &#123;\n\n    \n    console.log(`success value is $&#123;success&#125;`);\n    return new Promise((resovle, reject) =&gt; &#123;\n        // 异步2\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;做饭&quot;);\n            // resovle(&quot;做饭完成&quot;);\n            reject(&quot;做饭失败&quot;);\n        &#125;, 1000);\n    &#125;);\n\n&#125;).then((success) =&gt; &#123;\n\n    console.log(`success value is $&#123;success&#125;`);  \n    return new Promise((resovle, reject) =&gt; &#123;\n        // 异步3\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;吃饭&quot;);\n            resovle(&quot;吃饭成功&quot;)\n            // reject(&quot;吃饭失败&quot;);\n        &#125;, 1000);\n    &#125;);\n\n\n&#125;).then((success) =&gt; &#123;\n\n    // 异步操作执行成功\n    console.log(`success value is $&#123;success&#125;`);\n\n&#125;).catch((err) =&gt; &#123;\n\n    // 异步操作链中出现异常错误\n    console.log(`error value is $&#123;err&#125;`);\n\n&#125;)\n</code></pre>\n<p><strong>可同时进行的异步操作(组合异步操作)</strong></p>\n<pre><code class=\"js\">//在这里共有两组异步操作\n// 异步操作1 p1 洗澡\n// 异步操作2 p2 洗菜-&gt;做饭\nvar p1 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗澡&quot;, new Date());\n        // resolve(&quot;洗澡完成&quot;);\n        reject(&quot;洗澡失败&quot;);\n    &#125;, 1000);\n&#125;)\n\nvar p2 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗菜&quot;, new Date());\n        resolve(&quot;洗菜完成&quot;);\n        // reject(&quot;洗菜失败&quot;);\n    &#125;, 1000);\n&#125;).then((res) =&gt; &#123;\n    console.log(res, new Date())\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;做饭&quot;, new Date());\n            // resolve(&quot;做饭完成&quot;);\n            reject(&quot;做饭失败&quot;);\n        &#125;, 1000);\n    &#125;)\n&#125;);\n\n// 通过使用Promise.all来使得异步操作1和异步操作2同时进行\n// 然后在then回调函数中同时处理两个异步操作返回回来的结果\n// Promise.all在任意一个传入的 promise 失败时返回失败\nPromise.all([p1, p2]).then(([r1, r2]) =&gt; &#123;\n    console.log(r1, r2, new Date());\n&#125;).catch((err) =&gt; &#123;\n    console.log(err.toString());\n&#125;)\n\n\n\nvar p4 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;我快一点&quot;);\n        resolve(&quot;我快一点&quot;);\n    &#125;, 1000);s\n&#125;);\n\nvar p5 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;我慢一点&quot;);\n        reject(&quot;我慢一点&quot;);\n    &#125;, 2000);\n&#125;);\n\n// 现在有3系列异步操作 p1,p2,p3\n// 如果p1异步操作完成的最快，则fastestValue为p1所返回的值，err也同理\n// 注意：即使慢一点的异步操作也不会因为快一点的异步操作而中途停止，只是then中回调函数的参数是快一点异步操作的返回值罢了\n// 即Promise.race([p1,p2,p3])返回的是执行快一点的Promise对象\nPromise.race([p4, p5]).then(fastestValue =&gt; &#123;\n    console.log(fastestValue);\n&#125;).catch((err) =&gt; &#123;\n    console.log(err.toString());\n&#125;);\n</code></pre>\n<p>​\t</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Promise对象，是ES6新出的对象，主要目的是为了处理异步操作</p>\n<p>异步操作：通常来讲是指当我们去执行一种操作时，我们无法立即得到函数所执行后的结果，需要等待一段时间才能得到函数执行后的结果<br>常见的异步操作如下:</p>\n<ol>\n<li>定时器</li>\n<li>网络请求(例如ajax)</li>\n<li>事件函数</li>\n<li>文件读写</li>\n<li>数据库连接</li>\n<li>图片异步加载</li>\n<li>……</li>\n</ol>\n<h2 id=\"什么是Promise对象\"><a href=\"#什么是Promise对象\" class=\"headerlink\" title=\"什么是Promise对象\"></a>什么是Promise对象</h2><p>​在我们学习Promise对象时，我们必须要清楚它是什么东西</p>\n<p>​Promise对象，其实本质上是一个<strong>函数</strong>，那么它是可以执行Function上的一些方法（call,apply,bind…）。从另外一个方面来讲，Promise对象其实是一个容器，在这个容器中我们可以去完成一些任务，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n<pre><code class=\"js\">Object.prototype.toString.call(Promise) // &quot;[object Function]&quot;\n</code></pre>\n<p>​那么，Promise对象究竟是什么东西，这里有两个定义</p>\n<ol>\n<li>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。<br>Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。（网址：<a href=\"http://es6.ruanyifeng.com/#docs/promise%EF%BC%89\">http://es6.ruanyifeng.com/#docs/promise）</a></li>\n<li>Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。（网址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise%EF%BC%89\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise）</a></li>\n</ol>\n<p>​在我看来，Promise对象其实就是用于处于异步操作的函数。我们可以通过使用Promise对象来完成异步。至于如何使用Promise对象，后面会有提到。</p>\n<h2 id=\"为什么会出现Promise对象\"><a href=\"#为什么会出现Promise对象\" class=\"headerlink\" title=\"为什么会出现Promise对象\"></a>为什么会出现Promise对象</h2><p>​Promise对象的出现其实是为了解决回调函数的“回调地狱”问题<br>（关于回调地狱的相关问题可以阅读这篇文章：<a href=\"https://www.cnblogs.com/suihang/p/9595548.html%EF%BC%89%E3%80%82\">https://www.cnblogs.com/suihang/p/9595548.html）。</a></p>\n<p>​主要原因是如果我们使用回调函数的方法来进行异步操作，我们书写的代码的阅读性会变得非常的糟糕，而使用Promise对象就可以使我们编写的代码更加方便开发人员阅读（主要是因为Promise的链式调用）</p>\n<h2 id=\"Promise对象的基本认识\"><a href=\"#Promise对象的基本认识\" class=\"headerlink\" title=\"Promise对象的基本认识\"></a>Promise对象的基本认识</h2><p>​接下来，就是来说说Promise对象的一些基本概念。</p>\n<p>注意：我们要搞清楚我们应该什么时候使用Promise对象（一般只要我们需要异步操作的时候都可以使用Promise对象）。不要因为去使用Promise对象而去使用Promise对象</p>\n<p>Promise对象在执行开始到执行完成有以下几种状态</p>\n<ol>\n<li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。</li>\n<li><em>fulfilled</em>: 意味着操作成功完成。</li>\n<li><em>rejected</em>: 意味着操作失败。</li>\n</ol>\n<p>​pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。</p>\n<p>​当其中任一种情况出现时，Promise 对象的 <code>then</code> 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。</p>\n<ol>\n<li>当Promise状态为<em>fulfilled</em>时，调用 then 的 onfulfilled 方法</li>\n<li>当Promise状态为<em>rejected</em>时，调用 then 的 onrejected 方法</li>\n</ol>\n<p>​而为什么Promise可以被链式调用主要是因为 Promise.prototype.then和Promise.prototype.catch方法返回promise 对象， 所以它们可以被链式调用</p>\n<h2 id=\"Promise对象的基本使用\"><a href=\"#Promise对象的基本使用\" class=\"headerlink\" title=\"Promise对象的基本使用\"></a>Promise对象的基本使用</h2><p><strong>Promise对象所具有的属性</strong></p>\n<ol>\n<li>Promise.length  构造器参数的数目（其值总是为1）</li>\n<li>Promise.prototype Promise构造器的原型</li>\n</ol>\n<p><strong>Promise对象所具有的方法</strong></p>\n<ol>\n<li>Promise.all \t\t\t并行运行异步操作</li>\n<li>Promise.race         并行运行异步操作</li>\n<li>Promise.reject       手动创建一个已经 resolve的Promise 快捷方法</li>\n<li>Promise.resolve    手动创建一个已经 reject 的Promise 快捷方法</li>\n</ol>\n<p><strong>Promise原型</strong></p>\n<ol>\n<li>Promise.prototype.catch   抓取Promise执行过程中出现的异常和reject抛出的异常</li>\n<li>Promise.prototype.then    异步操作完成后所要执行的函数</li>\n<li>Promise.prototype.finally  无论promise状态最终都会执行的函数</li>\n</ol>\n<p><strong>Promise对象的简单用法（基本异步使用）</strong></p>\n<pre><code class=\"js\">// 如果异步操作执行成功，则使用resolve来表示promise对象异步操作成功\n// 如果异步操作执行成功，则使用reject来表示promise对象异步操作失败\n// 其中，resolve和reject其实是一个回调函数，在执行的时候可以携带参数给异步操作执行完成后要处理的函数\nvar myPromise = new Promise((resovle, reject) =&gt; &#123;\n\n    // 在这里我们执行以下异步操作\n    // 例如\n    // 1. 向后端接口请求数据,同时更新界面\n    // 2. 异步加载图片\n    // 3. 文件的读写操作\n    // 4. 数据库的相关操作\n    // 5. 等等\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;hello world&quot;);\n        reject(&quot;execute failed!&quot;);\n    &#125;, 1000);\n\n&#125;);\n\n\n// 异步操作完成后向对应的处理函数\n// then(cb)     若异步操作执行成功就会跳入到该函数执行\n// catch(cb)    若异步操作执行失败就会跳入到该函数执行 \n// finally(cb)  无论异步操作执行成功还是失败都会跳入到该函数执行\nmyPromise.then((success) =&gt; &#123;\n    // 处理异步操作成功的函数\n    console.log(`success value is $&#123;success&#125;`);\n&#125;).catch((err) =&gt; &#123;\n    // 处理异步操作失败的函数\n    console.log(`error value is $&#123;err&#125;`);\n&#125;).finally(() =&gt; &#123;\n    // 无论成功还是失败都会执行的函数\n    console.log(&quot;finally&quot;)\n&#125;)\n</code></pre>\n<p><strong>一系列异步操作（系列异步操作）</strong></p>\n<pre><code class=\"js\">// Promise最强大的地方就是可以进行链式调用，来避免以前遇到的回调地狱问题\n// 在执行一系列异步操作时，我们只要在最后.catch一下就可以抓获前面异步操作所可能出现的异常\n// 在执行异步操作时，如果后面还要进行下一个异步操作，那么需要在这个异步操作返回一个新的Promise供下面的then函数使用\n// 在进行一系列异步操作时，如果其中的一个异步操作出现异常，那么后续的异步操作就不会被执行\nnew Promise((resovle, reject) =&gt; &#123;\n    \n    // 异步1\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗菜&quot;);\n        resovle(&quot;洗菜完成&quot;);\n    &#125;, 1000);\n\n&#125;).then((success) =&gt; &#123;\n\n    \n    console.log(`success value is $&#123;success&#125;`);\n    return new Promise((resovle, reject) =&gt; &#123;\n        // 异步2\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;做饭&quot;);\n            // resovle(&quot;做饭完成&quot;);\n            reject(&quot;做饭失败&quot;);\n        &#125;, 1000);\n    &#125;);\n\n&#125;).then((success) =&gt; &#123;\n\n    console.log(`success value is $&#123;success&#125;`);  \n    return new Promise((resovle, reject) =&gt; &#123;\n        // 异步3\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;吃饭&quot;);\n            resovle(&quot;吃饭成功&quot;)\n            // reject(&quot;吃饭失败&quot;);\n        &#125;, 1000);\n    &#125;);\n\n\n&#125;).then((success) =&gt; &#123;\n\n    // 异步操作执行成功\n    console.log(`success value is $&#123;success&#125;`);\n\n&#125;).catch((err) =&gt; &#123;\n\n    // 异步操作链中出现异常错误\n    console.log(`error value is $&#123;err&#125;`);\n\n&#125;)\n</code></pre>\n<p><strong>可同时进行的异步操作(组合异步操作)</strong></p>\n<pre><code class=\"js\">//在这里共有两组异步操作\n// 异步操作1 p1 洗澡\n// 异步操作2 p2 洗菜-&gt;做饭\nvar p1 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗澡&quot;, new Date());\n        // resolve(&quot;洗澡完成&quot;);\n        reject(&quot;洗澡失败&quot;);\n    &#125;, 1000);\n&#125;)\n\nvar p2 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;洗菜&quot;, new Date());\n        resolve(&quot;洗菜完成&quot;);\n        // reject(&quot;洗菜失败&quot;);\n    &#125;, 1000);\n&#125;).then((res) =&gt; &#123;\n    console.log(res, new Date())\n    return new Promise((resolve, reject) =&gt; &#123;\n        setTimeout(() =&gt; &#123;\n            console.log(&quot;做饭&quot;, new Date());\n            // resolve(&quot;做饭完成&quot;);\n            reject(&quot;做饭失败&quot;);\n        &#125;, 1000);\n    &#125;)\n&#125;);\n\n// 通过使用Promise.all来使得异步操作1和异步操作2同时进行\n// 然后在then回调函数中同时处理两个异步操作返回回来的结果\n// Promise.all在任意一个传入的 promise 失败时返回失败\nPromise.all([p1, p2]).then(([r1, r2]) =&gt; &#123;\n    console.log(r1, r2, new Date());\n&#125;).catch((err) =&gt; &#123;\n    console.log(err.toString());\n&#125;)\n\n\n\nvar p4 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;我快一点&quot;);\n        resolve(&quot;我快一点&quot;);\n    &#125;, 1000);s\n&#125;);\n\nvar p5 = new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(&quot;我慢一点&quot;);\n        reject(&quot;我慢一点&quot;);\n    &#125;, 2000);\n&#125;);\n\n// 现在有3系列异步操作 p1,p2,p3\n// 如果p1异步操作完成的最快，则fastestValue为p1所返回的值，err也同理\n// 注意：即使慢一点的异步操作也不会因为快一点的异步操作而中途停止，只是then中回调函数的参数是快一点异步操作的返回值罢了\n// 即Promise.race([p1,p2,p3])返回的是执行快一点的Promise对象\nPromise.race([p4, p5]).then(fastestValue =&gt; &#123;\n    console.log(fastestValue);\n&#125;).catch((err) =&gt; &#123;\n    console.log(err.toString());\n&#125;);\n</code></pre>\n<p>​\t</p>\n"},{"title":"Proxy对象","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES6","date":"2019-11-15T16:00:00.000Z","comments":0,"description":"Proxy对象","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Proxy_bg.jpg"],"_content":"## 基础认识\n\n​\tProxy是ES6新提出来的内置对象，主要目的是实现在对象进行操作时能够对对象的行为进行拦截，然后拦截者可以根据自己的意愿重新定义该对象的此次操作行为。\n\n​\tProxy对象用于定义基本操作的自定义行为（例如属性查找，赋值，枚举，函数调用等）\n\n​\t当对象或者函数进行一些行为时我们可以通过proxy对象对其行为进行拦截，而对象本身的行为就无效了\n\n​\t而跟Proxy对象息息相关的就是一个handler对象\n\n## 基础使用\n\n​\t下面的代码创建一个Proxy对象p，关联对象是o,并对p的读取属性的操作进行拦截\n\n````js\n// 创建测试对象\nvar o = {\n    a:1\n}\n// 创建一个proxy对象(被关联的对象,handler对象)\nvar p = new Proxy(o,{\n    // target 关联对象\n    // 被读取的属性名\n    // 当前的proxy对象\n    get:function(target,prop,proxy){\n        console.log(target,prop,proxy);\n        return target[prop];\n    }\n})\n// 打印 1\n// 读取p的a属性行为会触发刚刚定义该proxy中handler对象的get方法，而之前对象的读取属性的行为将会被取消\n// 还会打印对象o,\"a\",p(当前触发该行为的proxy对象)\nconsole.log(p.a)\n// 而target对象的读取行为则不会触发handler对象中的get方法\nconsole.log(o.a)\n````\n\n## handler对象\n\n​\thandler对象是proxy对象功能实现的核心模块，主要是定义当进行拦截操作后应该去做什么。handler对象可拦截的操作很多，在这里主要讲几种常见的。\n\n#### 1. 拦截对象读取属性的行为 handler.get\n\n​\thandler.set，该方法用于拦截对象的读取属性操作,刚刚上面已有演示，这里就不演示了。\n\n#### 2. 拦截对象设置设置属性的行为 handler.set\n\n​\thandler.set，该方法用于拦截设置属性值的操作\n\n```js\n// 创建测试对象o\nvar o = {\n    a:1\n}\n// 创建代理对象p\nlet p = new Proxy(o,{\n    set:function(target,prop,value,proxy){\n        console.log(target,prop,value,proxy);\n        target[prop] = value;\n    }\n})\n// 为对象添加属性b\n// 该行为会触发hander.set方法\n// 会打印当前p关联的对象，此时添加的属性名，属性值和对象p\n// {a: 1} \"b\" 2 Proxy {a: 1}\np.b = 2;\n// Proxy {a: 1, b: 2}\nconsole.log(p);\n// {a: 1, b: 2}\nconsole.log(o);\n```\n\n#### 3. 拦截函数调用的行为 handler.apply\n\n​\thandler.apply，该用于拦截函数的调用。而之前的函数行为就不会发生，需要在拦截处理中手动调用该函数\n\n```js\n// 创建测试函数\nfunction f(){\n    console.log(\"hello world\");\n}\n// 创建测试Proxy对象p\nlet p = new Proxy(f,{\n    // 该函数会返回三个回调参数\n    // target 关联的函数\n    // thisArg 当前执行p的this值\n    // args 当前执行p所传来的参数\n    apply:function(f,thisArg,args){\n        // 输出\n        console.log(f.prototype,thisArg,args);\n        // 在这里执行原函数\n        f();\n    }\n})\n// 执行\n// {constructor: ƒ} \"thisArgs\" (5) [1, 2, 3, 4, 5]\n// hello world\np.apply(\"thisArgs\",[1,2,3,4,5]);\n```\n\n## 高级使用\n\n#### 1. 验证（函数调用时的参数类型校验，对象属性赋值校验）\n\n```js\n/**\n * \n * @param {Number} a \n * @param {Number} b \n * \n * 测试函数f\n */\nfunction f(a, b) {\n    console.log(a,b);\n}\n// 测试对象o\nvar o = {\n    a: 1// Number\n}\n// 创建对象o的代理对象op\nvar op = new Proxy(o, {\n    set: function (target, prop, value, _proxy) {\n        if (typeof value != \"number\") {\n            throw new TypeError(\"属性值必须为Number类型\");\n        }\n        target[prop] = value;\n    }\n})\n// 创建函数f的代理对象fp\nvar fp = new Proxy(f, {\n    apply: function (f, _thisArgs, args) {\n        for (let i = 0; i < args.length; i++) {\n            if (typeof args[i] != \"number\") {\n                throw new TypeError(\"参数必须为Number类型\");\n            }\n        }\n        f(...args);\n    }\n})\n// throw error(必须为Number类型)\n// op.a = \"string\";\n// ok\nop.a = 2;\n// throw error(必须为Number类型)\n// fp(\"a\",\"b\");\n// ok\n// 打印1,2\nfp(1,2);\n```\n\n#### 2. 扩展构造函数\n\n```js\nfunction extend(sup, base) {\n    // 获取base原型上的属性描述符\n    var descriptor = Object.getOwnPropertyDescriptor(\n        base.prototype, \"constructor\"\n    );\n    // 再将base的原型指向基于sup的原型的新的对象\n    base.prototype = Object.create(sup.prototype);\n    // 设置handler\n    var handler = {\n        // 该属性用于当进行new操作的操作拦截\n        construct: function (target, args) {\n           \t// 基于base.prototype创建新的对象\n            var obj = Object.create(base.prototype);\n            // 将当前对象和base原型对象进行关联\n            this.apply(target, obj, args);\n            // 返回创建好的对象\n            return obj;\n        },\n        apply: function (_target, that, args) {\n            sup.apply(that, args);\n            base.apply(that, args);\n        }\n    };\n    var proxy = new Proxy(base, handler);\n    descriptor.value = proxy;\n    Object.defineProperty(base.prototype, \"constructor\", descriptor);\n    return proxy;\n}\n\nvar Person = function (name) {\n    this.name = name\n};\n\nvar Boy = extend(Person, function (name, age) {\n    this.age = age;\n});\n\nBoy.prototype.sex = \"M\";\n\nvar Peter = new Boy(\"Peter\", 13);\nconsole.log(Peter.sex);  // \"M\"\nconsole.log(Peter.name); // \"Peter\"\nconsole.log(Peter.age);  // 13\n```\n\n#### 3. 通过属性查找数组中特定的对象\n\n```js\n// 创建测试数组 personLists\nlet personLists = [\n    { name: \"张三\", age: 24 },\n    { name: \"李四\", age: 22 },\n    { name: \"王五\", age: 25 },\n]\n\nlet pp = new Proxy(personLists, {\n\n    get: function (target, prop, _proxy) {\n        // 如果prop是target对象的一个属性，直接target上prop属性名对应的属性值\n        if (prop in target) {\n            return target[prop];\n        }\n        // 如果prop的值为“number”，则直接返回数组的长度\n        if (prop === \"number\") {\n            return target.length;\n        }\n\n        let result, ages = {};\n\n        for (let person of target) {\n\n            if (person.name === prop) {\n                result = person;\n            }\n            if (ages[person.age]) {\n                ages[person.age].push(person);\n            } else {\n                ages[person.age] = [person];\n            }\n        }\n\n        if (result) {\n            return result;\n        }\n\n        if (prop in ages) {\n            return ages[prop];\n        }\n\n        if (prop === \"ages\") {\n            return Object.keys(ages);\n        }\n        // 返回未定义\n        return undefined;\n    }\n\n})\n// {name: \"张三\", age: 24}\nconsole.log(pp[0]);\n// {name: \"张三\", age: 24}\nconsole.log(pp[\"张三\"]);\n// [{name: \"张三\", age: 24}]\nconsole.log(pp[24]);\n// [\"22\", \"24\", \"25\"]\nconsole.log(pp.ages);\n// 3\nconsole.log(pp.number);\n```\n\n#### 4. 实现观察者模式\n\n```js\n// 创建实例对象\nlet o = {\n    a: 1,\n    b: 2,\n    c: 3\n}\n/**\n * 在这里对对象o的属性c实现监控\n * c = a + b; 当a,b发生变化,c也要做出相应变化\n */\nlet p = new Proxy(o, {\n    set: function (target, prop, value, _proxy) {\n        target[prop] = value;\n        if (prop != \"c\") {\n            target.c = target.a + target.b;\n        }\n    }\n})\n// 输出原本p,{a: 1, b: 2, c: 3}\nconsole.log(p);\n// 修改p.a的值\np.a = 2;\n// 再次输出p, {a: 2, b: 2, c: 4}\nconsole.log(p);\n// 修改p.b的值\np.b = 3;\n// 输出p,{a: 2, b: 3, c: 5}\nconsole.log(p);\n```\n\n#### 5. 低层封装，只允许上层访问特定接口(这里用属性举例)\n\n```js\nvar Stack = (function () {\n    // 原始对象定义\n    var stack = [];\n    // 可被允许访问的属性名\n    var allowed = [\"push\", \"pop\", \"length\"];\n    // 返回代理对象\n    return new Proxy(stack, {\n        get: function (target, prop, _proxy) {\n            // 如果是可以被访问的属性，就允许它指向\n            if (allowed.indexOf(prop) > -1) {\n                return target[prop];\n            }\n            // 否则就抛出异常\n            throw new ReferenceError(`无权访问 ${prop} 属性`)\n        }\n    });\n})\n// 创建Stack实例对象,s\nvar s = new Stack();\n// 可以执行push方法\ns.push(\"1\");\n// 可以访问length属性，1\nconsole.log(s.length);\n// ReferenceError: 无权访问 __proto__ 属性\nconsole.log(s.__proto__);\n```\n\n\n\n","source":"_posts/前端/ES6/Proxy对象.md","raw":"---\ntitle: Proxy对象\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - ES6\nkeywords: ES6\ndate: 2019-11-16\ncomments: false\ndescription: Proxy对象\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Proxy_bg.jpg\n---\n## 基础认识\n\n​\tProxy是ES6新提出来的内置对象，主要目的是实现在对象进行操作时能够对对象的行为进行拦截，然后拦截者可以根据自己的意愿重新定义该对象的此次操作行为。\n\n​\tProxy对象用于定义基本操作的自定义行为（例如属性查找，赋值，枚举，函数调用等）\n\n​\t当对象或者函数进行一些行为时我们可以通过proxy对象对其行为进行拦截，而对象本身的行为就无效了\n\n​\t而跟Proxy对象息息相关的就是一个handler对象\n\n## 基础使用\n\n​\t下面的代码创建一个Proxy对象p，关联对象是o,并对p的读取属性的操作进行拦截\n\n````js\n// 创建测试对象\nvar o = {\n    a:1\n}\n// 创建一个proxy对象(被关联的对象,handler对象)\nvar p = new Proxy(o,{\n    // target 关联对象\n    // 被读取的属性名\n    // 当前的proxy对象\n    get:function(target,prop,proxy){\n        console.log(target,prop,proxy);\n        return target[prop];\n    }\n})\n// 打印 1\n// 读取p的a属性行为会触发刚刚定义该proxy中handler对象的get方法，而之前对象的读取属性的行为将会被取消\n// 还会打印对象o,\"a\",p(当前触发该行为的proxy对象)\nconsole.log(p.a)\n// 而target对象的读取行为则不会触发handler对象中的get方法\nconsole.log(o.a)\n````\n\n## handler对象\n\n​\thandler对象是proxy对象功能实现的核心模块，主要是定义当进行拦截操作后应该去做什么。handler对象可拦截的操作很多，在这里主要讲几种常见的。\n\n#### 1. 拦截对象读取属性的行为 handler.get\n\n​\thandler.set，该方法用于拦截对象的读取属性操作,刚刚上面已有演示，这里就不演示了。\n\n#### 2. 拦截对象设置设置属性的行为 handler.set\n\n​\thandler.set，该方法用于拦截设置属性值的操作\n\n```js\n// 创建测试对象o\nvar o = {\n    a:1\n}\n// 创建代理对象p\nlet p = new Proxy(o,{\n    set:function(target,prop,value,proxy){\n        console.log(target,prop,value,proxy);\n        target[prop] = value;\n    }\n})\n// 为对象添加属性b\n// 该行为会触发hander.set方法\n// 会打印当前p关联的对象，此时添加的属性名，属性值和对象p\n// {a: 1} \"b\" 2 Proxy {a: 1}\np.b = 2;\n// Proxy {a: 1, b: 2}\nconsole.log(p);\n// {a: 1, b: 2}\nconsole.log(o);\n```\n\n#### 3. 拦截函数调用的行为 handler.apply\n\n​\thandler.apply，该用于拦截函数的调用。而之前的函数行为就不会发生，需要在拦截处理中手动调用该函数\n\n```js\n// 创建测试函数\nfunction f(){\n    console.log(\"hello world\");\n}\n// 创建测试Proxy对象p\nlet p = new Proxy(f,{\n    // 该函数会返回三个回调参数\n    // target 关联的函数\n    // thisArg 当前执行p的this值\n    // args 当前执行p所传来的参数\n    apply:function(f,thisArg,args){\n        // 输出\n        console.log(f.prototype,thisArg,args);\n        // 在这里执行原函数\n        f();\n    }\n})\n// 执行\n// {constructor: ƒ} \"thisArgs\" (5) [1, 2, 3, 4, 5]\n// hello world\np.apply(\"thisArgs\",[1,2,3,4,5]);\n```\n\n## 高级使用\n\n#### 1. 验证（函数调用时的参数类型校验，对象属性赋值校验）\n\n```js\n/**\n * \n * @param {Number} a \n * @param {Number} b \n * \n * 测试函数f\n */\nfunction f(a, b) {\n    console.log(a,b);\n}\n// 测试对象o\nvar o = {\n    a: 1// Number\n}\n// 创建对象o的代理对象op\nvar op = new Proxy(o, {\n    set: function (target, prop, value, _proxy) {\n        if (typeof value != \"number\") {\n            throw new TypeError(\"属性值必须为Number类型\");\n        }\n        target[prop] = value;\n    }\n})\n// 创建函数f的代理对象fp\nvar fp = new Proxy(f, {\n    apply: function (f, _thisArgs, args) {\n        for (let i = 0; i < args.length; i++) {\n            if (typeof args[i] != \"number\") {\n                throw new TypeError(\"参数必须为Number类型\");\n            }\n        }\n        f(...args);\n    }\n})\n// throw error(必须为Number类型)\n// op.a = \"string\";\n// ok\nop.a = 2;\n// throw error(必须为Number类型)\n// fp(\"a\",\"b\");\n// ok\n// 打印1,2\nfp(1,2);\n```\n\n#### 2. 扩展构造函数\n\n```js\nfunction extend(sup, base) {\n    // 获取base原型上的属性描述符\n    var descriptor = Object.getOwnPropertyDescriptor(\n        base.prototype, \"constructor\"\n    );\n    // 再将base的原型指向基于sup的原型的新的对象\n    base.prototype = Object.create(sup.prototype);\n    // 设置handler\n    var handler = {\n        // 该属性用于当进行new操作的操作拦截\n        construct: function (target, args) {\n           \t// 基于base.prototype创建新的对象\n            var obj = Object.create(base.prototype);\n            // 将当前对象和base原型对象进行关联\n            this.apply(target, obj, args);\n            // 返回创建好的对象\n            return obj;\n        },\n        apply: function (_target, that, args) {\n            sup.apply(that, args);\n            base.apply(that, args);\n        }\n    };\n    var proxy = new Proxy(base, handler);\n    descriptor.value = proxy;\n    Object.defineProperty(base.prototype, \"constructor\", descriptor);\n    return proxy;\n}\n\nvar Person = function (name) {\n    this.name = name\n};\n\nvar Boy = extend(Person, function (name, age) {\n    this.age = age;\n});\n\nBoy.prototype.sex = \"M\";\n\nvar Peter = new Boy(\"Peter\", 13);\nconsole.log(Peter.sex);  // \"M\"\nconsole.log(Peter.name); // \"Peter\"\nconsole.log(Peter.age);  // 13\n```\n\n#### 3. 通过属性查找数组中特定的对象\n\n```js\n// 创建测试数组 personLists\nlet personLists = [\n    { name: \"张三\", age: 24 },\n    { name: \"李四\", age: 22 },\n    { name: \"王五\", age: 25 },\n]\n\nlet pp = new Proxy(personLists, {\n\n    get: function (target, prop, _proxy) {\n        // 如果prop是target对象的一个属性，直接target上prop属性名对应的属性值\n        if (prop in target) {\n            return target[prop];\n        }\n        // 如果prop的值为“number”，则直接返回数组的长度\n        if (prop === \"number\") {\n            return target.length;\n        }\n\n        let result, ages = {};\n\n        for (let person of target) {\n\n            if (person.name === prop) {\n                result = person;\n            }\n            if (ages[person.age]) {\n                ages[person.age].push(person);\n            } else {\n                ages[person.age] = [person];\n            }\n        }\n\n        if (result) {\n            return result;\n        }\n\n        if (prop in ages) {\n            return ages[prop];\n        }\n\n        if (prop === \"ages\") {\n            return Object.keys(ages);\n        }\n        // 返回未定义\n        return undefined;\n    }\n\n})\n// {name: \"张三\", age: 24}\nconsole.log(pp[0]);\n// {name: \"张三\", age: 24}\nconsole.log(pp[\"张三\"]);\n// [{name: \"张三\", age: 24}]\nconsole.log(pp[24]);\n// [\"22\", \"24\", \"25\"]\nconsole.log(pp.ages);\n// 3\nconsole.log(pp.number);\n```\n\n#### 4. 实现观察者模式\n\n```js\n// 创建实例对象\nlet o = {\n    a: 1,\n    b: 2,\n    c: 3\n}\n/**\n * 在这里对对象o的属性c实现监控\n * c = a + b; 当a,b发生变化,c也要做出相应变化\n */\nlet p = new Proxy(o, {\n    set: function (target, prop, value, _proxy) {\n        target[prop] = value;\n        if (prop != \"c\") {\n            target.c = target.a + target.b;\n        }\n    }\n})\n// 输出原本p,{a: 1, b: 2, c: 3}\nconsole.log(p);\n// 修改p.a的值\np.a = 2;\n// 再次输出p, {a: 2, b: 2, c: 4}\nconsole.log(p);\n// 修改p.b的值\np.b = 3;\n// 输出p,{a: 2, b: 3, c: 5}\nconsole.log(p);\n```\n\n#### 5. 低层封装，只允许上层访问特定接口(这里用属性举例)\n\n```js\nvar Stack = (function () {\n    // 原始对象定义\n    var stack = [];\n    // 可被允许访问的属性名\n    var allowed = [\"push\", \"pop\", \"length\"];\n    // 返回代理对象\n    return new Proxy(stack, {\n        get: function (target, prop, _proxy) {\n            // 如果是可以被访问的属性，就允许它指向\n            if (allowed.indexOf(prop) > -1) {\n                return target[prop];\n            }\n            // 否则就抛出异常\n            throw new ReferenceError(`无权访问 ${prop} 属性`)\n        }\n    });\n})\n// 创建Stack实例对象,s\nvar s = new Stack();\n// 可以执行push方法\ns.push(\"1\");\n// 可以访问length属性，1\nconsole.log(s.length);\n// ReferenceError: 无权访问 __proto__ 属性\nconsole.log(s.__proto__);\n```\n\n\n\n","slug":"前端/ES6/Proxy对象","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2q00102h178s6qe35p","content":"<h2 id=\"基础认识\"><a href=\"#基础认识\" class=\"headerlink\" title=\"基础认识\"></a>基础认识</h2><p>​\tProxy是ES6新提出来的内置对象，主要目的是实现在对象进行操作时能够对对象的行为进行拦截，然后拦截者可以根据自己的意愿重新定义该对象的此次操作行为。</p>\n<p>​\tProxy对象用于定义基本操作的自定义行为（例如属性查找，赋值，枚举，函数调用等）</p>\n<p>​\t当对象或者函数进行一些行为时我们可以通过proxy对象对其行为进行拦截，而对象本身的行为就无效了</p>\n<p>​\t而跟Proxy对象息息相关的就是一个handler对象</p>\n<h2 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h2><p>​\t下面的代码创建一个Proxy对象p，关联对象是o,并对p的读取属性的操作进行拦截</p>\n<pre><code class=\"js\">// 创建测试对象\nvar o = &#123;\n    a:1\n&#125;\n// 创建一个proxy对象(被关联的对象,handler对象)\nvar p = new Proxy(o,&#123;\n    // target 关联对象\n    // 被读取的属性名\n    // 当前的proxy对象\n    get:function(target,prop,proxy)&#123;\n        console.log(target,prop,proxy);\n        return target[prop];\n    &#125;\n&#125;)\n// 打印 1\n// 读取p的a属性行为会触发刚刚定义该proxy中handler对象的get方法，而之前对象的读取属性的行为将会被取消\n// 还会打印对象o,&quot;a&quot;,p(当前触发该行为的proxy对象)\nconsole.log(p.a)\n// 而target对象的读取行为则不会触发handler对象中的get方法\nconsole.log(o.a)\n</code></pre>\n<h2 id=\"handler对象\"><a href=\"#handler对象\" class=\"headerlink\" title=\"handler对象\"></a>handler对象</h2><p>​\thandler对象是proxy对象功能实现的核心模块，主要是定义当进行拦截操作后应该去做什么。handler对象可拦截的操作很多，在这里主要讲几种常见的。</p>\n<h4 id=\"1-拦截对象读取属性的行为-handler-get\"><a href=\"#1-拦截对象读取属性的行为-handler-get\" class=\"headerlink\" title=\"1. 拦截对象读取属性的行为 handler.get\"></a>1. 拦截对象读取属性的行为 handler.get</h4><p>​\thandler.set，该方法用于拦截对象的读取属性操作,刚刚上面已有演示，这里就不演示了。</p>\n<h4 id=\"2-拦截对象设置设置属性的行为-handler-set\"><a href=\"#2-拦截对象设置设置属性的行为-handler-set\" class=\"headerlink\" title=\"2. 拦截对象设置设置属性的行为 handler.set\"></a>2. 拦截对象设置设置属性的行为 handler.set</h4><p>​\thandler.set，该方法用于拦截设置属性值的操作</p>\n<pre><code class=\"js\">// 创建测试对象o\nvar o = &#123;\n    a:1\n&#125;\n// 创建代理对象p\nlet p = new Proxy(o,&#123;\n    set:function(target,prop,value,proxy)&#123;\n        console.log(target,prop,value,proxy);\n        target[prop] = value;\n    &#125;\n&#125;)\n// 为对象添加属性b\n// 该行为会触发hander.set方法\n// 会打印当前p关联的对象，此时添加的属性名，属性值和对象p\n// &#123;a: 1&#125; &quot;b&quot; 2 Proxy &#123;a: 1&#125;\np.b = 2;\n// Proxy &#123;a: 1, b: 2&#125;\nconsole.log(p);\n// &#123;a: 1, b: 2&#125;\nconsole.log(o);\n</code></pre>\n<h4 id=\"3-拦截函数调用的行为-handler-apply\"><a href=\"#3-拦截函数调用的行为-handler-apply\" class=\"headerlink\" title=\"3. 拦截函数调用的行为 handler.apply\"></a>3. 拦截函数调用的行为 handler.apply</h4><p>​\thandler.apply，该用于拦截函数的调用。而之前的函数行为就不会发生，需要在拦截处理中手动调用该函数</p>\n<pre><code class=\"js\">// 创建测试函数\nfunction f()&#123;\n    console.log(&quot;hello world&quot;);\n&#125;\n// 创建测试Proxy对象p\nlet p = new Proxy(f,&#123;\n    // 该函数会返回三个回调参数\n    // target 关联的函数\n    // thisArg 当前执行p的this值\n    // args 当前执行p所传来的参数\n    apply:function(f,thisArg,args)&#123;\n        // 输出\n        console.log(f.prototype,thisArg,args);\n        // 在这里执行原函数\n        f();\n    &#125;\n&#125;)\n// 执行\n// &#123;constructor: ƒ&#125; &quot;thisArgs&quot; (5) [1, 2, 3, 4, 5]\n// hello world\np.apply(&quot;thisArgs&quot;,[1,2,3,4,5]);\n</code></pre>\n<h2 id=\"高级使用\"><a href=\"#高级使用\" class=\"headerlink\" title=\"高级使用\"></a>高级使用</h2><h4 id=\"1-验证（函数调用时的参数类型校验，对象属性赋值校验）\"><a href=\"#1-验证（函数调用时的参数类型校验，对象属性赋值校验）\" class=\"headerlink\" title=\"1. 验证（函数调用时的参数类型校验，对象属性赋值校验）\"></a>1. 验证（函数调用时的参数类型校验，对象属性赋值校验）</h4><pre><code class=\"js\">/**\n * \n * @param &#123;Number&#125; a \n * @param &#123;Number&#125; b \n * \n * 测试函数f\n */\nfunction f(a, b) &#123;\n    console.log(a,b);\n&#125;\n// 测试对象o\nvar o = &#123;\n    a: 1// Number\n&#125;\n// 创建对象o的代理对象op\nvar op = new Proxy(o, &#123;\n    set: function (target, prop, value, _proxy) &#123;\n        if (typeof value != &quot;number&quot;) &#123;\n            throw new TypeError(&quot;属性值必须为Number类型&quot;);\n        &#125;\n        target[prop] = value;\n    &#125;\n&#125;)\n// 创建函数f的代理对象fp\nvar fp = new Proxy(f, &#123;\n    apply: function (f, _thisArgs, args) &#123;\n        for (let i = 0; i &lt; args.length; i++) &#123;\n            if (typeof args[i] != &quot;number&quot;) &#123;\n                throw new TypeError(&quot;参数必须为Number类型&quot;);\n            &#125;\n        &#125;\n        f(...args);\n    &#125;\n&#125;)\n// throw error(必须为Number类型)\n// op.a = &quot;string&quot;;\n// ok\nop.a = 2;\n// throw error(必须为Number类型)\n// fp(&quot;a&quot;,&quot;b&quot;);\n// ok\n// 打印1,2\nfp(1,2);\n</code></pre>\n<h4 id=\"2-扩展构造函数\"><a href=\"#2-扩展构造函数\" class=\"headerlink\" title=\"2. 扩展构造函数\"></a>2. 扩展构造函数</h4><pre><code class=\"js\">function extend(sup, base) &#123;\n    // 获取base原型上的属性描述符\n    var descriptor = Object.getOwnPropertyDescriptor(\n        base.prototype, &quot;constructor&quot;\n    );\n    // 再将base的原型指向基于sup的原型的新的对象\n    base.prototype = Object.create(sup.prototype);\n    // 设置handler\n    var handler = &#123;\n        // 该属性用于当进行new操作的操作拦截\n        construct: function (target, args) &#123;\n               // 基于base.prototype创建新的对象\n            var obj = Object.create(base.prototype);\n            // 将当前对象和base原型对象进行关联\n            this.apply(target, obj, args);\n            // 返回创建好的对象\n            return obj;\n        &#125;,\n        apply: function (_target, that, args) &#123;\n            sup.apply(that, args);\n            base.apply(that, args);\n        &#125;\n    &#125;;\n    var proxy = new Proxy(base, handler);\n    descriptor.value = proxy;\n    Object.defineProperty(base.prototype, &quot;constructor&quot;, descriptor);\n    return proxy;\n&#125;\n\nvar Person = function (name) &#123;\n    this.name = name\n&#125;;\n\nvar Boy = extend(Person, function (name, age) &#123;\n    this.age = age;\n&#125;);\n\nBoy.prototype.sex = &quot;M&quot;;\n\nvar Peter = new Boy(&quot;Peter&quot;, 13);\nconsole.log(Peter.sex);  // &quot;M&quot;\nconsole.log(Peter.name); // &quot;Peter&quot;\nconsole.log(Peter.age);  // 13\n</code></pre>\n<h4 id=\"3-通过属性查找数组中特定的对象\"><a href=\"#3-通过属性查找数组中特定的对象\" class=\"headerlink\" title=\"3. 通过属性查找数组中特定的对象\"></a>3. 通过属性查找数组中特定的对象</h4><pre><code class=\"js\">// 创建测试数组 personLists\nlet personLists = [\n    &#123; name: &quot;张三&quot;, age: 24 &#125;,\n    &#123; name: &quot;李四&quot;, age: 22 &#125;,\n    &#123; name: &quot;王五&quot;, age: 25 &#125;,\n]\n\nlet pp = new Proxy(personLists, &#123;\n\n    get: function (target, prop, _proxy) &#123;\n        // 如果prop是target对象的一个属性，直接target上prop属性名对应的属性值\n        if (prop in target) &#123;\n            return target[prop];\n        &#125;\n        // 如果prop的值为“number”，则直接返回数组的长度\n        if (prop === &quot;number&quot;) &#123;\n            return target.length;\n        &#125;\n\n        let result, ages = &#123;&#125;;\n\n        for (let person of target) &#123;\n\n            if (person.name === prop) &#123;\n                result = person;\n            &#125;\n            if (ages[person.age]) &#123;\n                ages[person.age].push(person);\n            &#125; else &#123;\n                ages[person.age] = [person];\n            &#125;\n        &#125;\n\n        if (result) &#123;\n            return result;\n        &#125;\n\n        if (prop in ages) &#123;\n            return ages[prop];\n        &#125;\n\n        if (prop === &quot;ages&quot;) &#123;\n            return Object.keys(ages);\n        &#125;\n        // 返回未定义\n        return undefined;\n    &#125;\n\n&#125;)\n// &#123;name: &quot;张三&quot;, age: 24&#125;\nconsole.log(pp[0]);\n// &#123;name: &quot;张三&quot;, age: 24&#125;\nconsole.log(pp[&quot;张三&quot;]);\n// [&#123;name: &quot;张三&quot;, age: 24&#125;]\nconsole.log(pp[24]);\n// [&quot;22&quot;, &quot;24&quot;, &quot;25&quot;]\nconsole.log(pp.ages);\n// 3\nconsole.log(pp.number);\n</code></pre>\n<h4 id=\"4-实现观察者模式\"><a href=\"#4-实现观察者模式\" class=\"headerlink\" title=\"4. 实现观察者模式\"></a>4. 实现观察者模式</h4><pre><code class=\"js\">// 创建实例对象\nlet o = &#123;\n    a: 1,\n    b: 2,\n    c: 3\n&#125;\n/**\n * 在这里对对象o的属性c实现监控\n * c = a + b; 当a,b发生变化,c也要做出相应变化\n */\nlet p = new Proxy(o, &#123;\n    set: function (target, prop, value, _proxy) &#123;\n        target[prop] = value;\n        if (prop != &quot;c&quot;) &#123;\n            target.c = target.a + target.b;\n        &#125;\n    &#125;\n&#125;)\n// 输出原本p,&#123;a: 1, b: 2, c: 3&#125;\nconsole.log(p);\n// 修改p.a的值\np.a = 2;\n// 再次输出p, &#123;a: 2, b: 2, c: 4&#125;\nconsole.log(p);\n// 修改p.b的值\np.b = 3;\n// 输出p,&#123;a: 2, b: 3, c: 5&#125;\nconsole.log(p);\n</code></pre>\n<h4 id=\"5-低层封装，只允许上层访问特定接口-这里用属性举例\"><a href=\"#5-低层封装，只允许上层访问特定接口-这里用属性举例\" class=\"headerlink\" title=\"5. 低层封装，只允许上层访问特定接口(这里用属性举例)\"></a>5. 低层封装，只允许上层访问特定接口(这里用属性举例)</h4><pre><code class=\"js\">var Stack = (function () &#123;\n    // 原始对象定义\n    var stack = [];\n    // 可被允许访问的属性名\n    var allowed = [&quot;push&quot;, &quot;pop&quot;, &quot;length&quot;];\n    // 返回代理对象\n    return new Proxy(stack, &#123;\n        get: function (target, prop, _proxy) &#123;\n            // 如果是可以被访问的属性，就允许它指向\n            if (allowed.indexOf(prop) &gt; -1) &#123;\n                return target[prop];\n            &#125;\n            // 否则就抛出异常\n            throw new ReferenceError(`无权访问 $&#123;prop&#125; 属性`)\n        &#125;\n    &#125;);\n&#125;)\n// 创建Stack实例对象,s\nvar s = new Stack();\n// 可以执行push方法\ns.push(&quot;1&quot;);\n// 可以访问length属性，1\nconsole.log(s.length);\n// ReferenceError: 无权访问 __proto__ 属性\nconsole.log(s.__proto__);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础认识\"><a href=\"#基础认识\" class=\"headerlink\" title=\"基础认识\"></a>基础认识</h2><p>​\tProxy是ES6新提出来的内置对象，主要目的是实现在对象进行操作时能够对对象的行为进行拦截，然后拦截者可以根据自己的意愿重新定义该对象的此次操作行为。</p>\n<p>​\tProxy对象用于定义基本操作的自定义行为（例如属性查找，赋值，枚举，函数调用等）</p>\n<p>​\t当对象或者函数进行一些行为时我们可以通过proxy对象对其行为进行拦截，而对象本身的行为就无效了</p>\n<p>​\t而跟Proxy对象息息相关的就是一个handler对象</p>\n<h2 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h2><p>​\t下面的代码创建一个Proxy对象p，关联对象是o,并对p的读取属性的操作进行拦截</p>\n<pre><code class=\"js\">// 创建测试对象\nvar o = &#123;\n    a:1\n&#125;\n// 创建一个proxy对象(被关联的对象,handler对象)\nvar p = new Proxy(o,&#123;\n    // target 关联对象\n    // 被读取的属性名\n    // 当前的proxy对象\n    get:function(target,prop,proxy)&#123;\n        console.log(target,prop,proxy);\n        return target[prop];\n    &#125;\n&#125;)\n// 打印 1\n// 读取p的a属性行为会触发刚刚定义该proxy中handler对象的get方法，而之前对象的读取属性的行为将会被取消\n// 还会打印对象o,&quot;a&quot;,p(当前触发该行为的proxy对象)\nconsole.log(p.a)\n// 而target对象的读取行为则不会触发handler对象中的get方法\nconsole.log(o.a)\n</code></pre>\n<h2 id=\"handler对象\"><a href=\"#handler对象\" class=\"headerlink\" title=\"handler对象\"></a>handler对象</h2><p>​\thandler对象是proxy对象功能实现的核心模块，主要是定义当进行拦截操作后应该去做什么。handler对象可拦截的操作很多，在这里主要讲几种常见的。</p>\n<h4 id=\"1-拦截对象读取属性的行为-handler-get\"><a href=\"#1-拦截对象读取属性的行为-handler-get\" class=\"headerlink\" title=\"1. 拦截对象读取属性的行为 handler.get\"></a>1. 拦截对象读取属性的行为 handler.get</h4><p>​\thandler.set，该方法用于拦截对象的读取属性操作,刚刚上面已有演示，这里就不演示了。</p>\n<h4 id=\"2-拦截对象设置设置属性的行为-handler-set\"><a href=\"#2-拦截对象设置设置属性的行为-handler-set\" class=\"headerlink\" title=\"2. 拦截对象设置设置属性的行为 handler.set\"></a>2. 拦截对象设置设置属性的行为 handler.set</h4><p>​\thandler.set，该方法用于拦截设置属性值的操作</p>\n<pre><code class=\"js\">// 创建测试对象o\nvar o = &#123;\n    a:1\n&#125;\n// 创建代理对象p\nlet p = new Proxy(o,&#123;\n    set:function(target,prop,value,proxy)&#123;\n        console.log(target,prop,value,proxy);\n        target[prop] = value;\n    &#125;\n&#125;)\n// 为对象添加属性b\n// 该行为会触发hander.set方法\n// 会打印当前p关联的对象，此时添加的属性名，属性值和对象p\n// &#123;a: 1&#125; &quot;b&quot; 2 Proxy &#123;a: 1&#125;\np.b = 2;\n// Proxy &#123;a: 1, b: 2&#125;\nconsole.log(p);\n// &#123;a: 1, b: 2&#125;\nconsole.log(o);\n</code></pre>\n<h4 id=\"3-拦截函数调用的行为-handler-apply\"><a href=\"#3-拦截函数调用的行为-handler-apply\" class=\"headerlink\" title=\"3. 拦截函数调用的行为 handler.apply\"></a>3. 拦截函数调用的行为 handler.apply</h4><p>​\thandler.apply，该用于拦截函数的调用。而之前的函数行为就不会发生，需要在拦截处理中手动调用该函数</p>\n<pre><code class=\"js\">// 创建测试函数\nfunction f()&#123;\n    console.log(&quot;hello world&quot;);\n&#125;\n// 创建测试Proxy对象p\nlet p = new Proxy(f,&#123;\n    // 该函数会返回三个回调参数\n    // target 关联的函数\n    // thisArg 当前执行p的this值\n    // args 当前执行p所传来的参数\n    apply:function(f,thisArg,args)&#123;\n        // 输出\n        console.log(f.prototype,thisArg,args);\n        // 在这里执行原函数\n        f();\n    &#125;\n&#125;)\n// 执行\n// &#123;constructor: ƒ&#125; &quot;thisArgs&quot; (5) [1, 2, 3, 4, 5]\n// hello world\np.apply(&quot;thisArgs&quot;,[1,2,3,4,5]);\n</code></pre>\n<h2 id=\"高级使用\"><a href=\"#高级使用\" class=\"headerlink\" title=\"高级使用\"></a>高级使用</h2><h4 id=\"1-验证（函数调用时的参数类型校验，对象属性赋值校验）\"><a href=\"#1-验证（函数调用时的参数类型校验，对象属性赋值校验）\" class=\"headerlink\" title=\"1. 验证（函数调用时的参数类型校验，对象属性赋值校验）\"></a>1. 验证（函数调用时的参数类型校验，对象属性赋值校验）</h4><pre><code class=\"js\">/**\n * \n * @param &#123;Number&#125; a \n * @param &#123;Number&#125; b \n * \n * 测试函数f\n */\nfunction f(a, b) &#123;\n    console.log(a,b);\n&#125;\n// 测试对象o\nvar o = &#123;\n    a: 1// Number\n&#125;\n// 创建对象o的代理对象op\nvar op = new Proxy(o, &#123;\n    set: function (target, prop, value, _proxy) &#123;\n        if (typeof value != &quot;number&quot;) &#123;\n            throw new TypeError(&quot;属性值必须为Number类型&quot;);\n        &#125;\n        target[prop] = value;\n    &#125;\n&#125;)\n// 创建函数f的代理对象fp\nvar fp = new Proxy(f, &#123;\n    apply: function (f, _thisArgs, args) &#123;\n        for (let i = 0; i &lt; args.length; i++) &#123;\n            if (typeof args[i] != &quot;number&quot;) &#123;\n                throw new TypeError(&quot;参数必须为Number类型&quot;);\n            &#125;\n        &#125;\n        f(...args);\n    &#125;\n&#125;)\n// throw error(必须为Number类型)\n// op.a = &quot;string&quot;;\n// ok\nop.a = 2;\n// throw error(必须为Number类型)\n// fp(&quot;a&quot;,&quot;b&quot;);\n// ok\n// 打印1,2\nfp(1,2);\n</code></pre>\n<h4 id=\"2-扩展构造函数\"><a href=\"#2-扩展构造函数\" class=\"headerlink\" title=\"2. 扩展构造函数\"></a>2. 扩展构造函数</h4><pre><code class=\"js\">function extend(sup, base) &#123;\n    // 获取base原型上的属性描述符\n    var descriptor = Object.getOwnPropertyDescriptor(\n        base.prototype, &quot;constructor&quot;\n    );\n    // 再将base的原型指向基于sup的原型的新的对象\n    base.prototype = Object.create(sup.prototype);\n    // 设置handler\n    var handler = &#123;\n        // 该属性用于当进行new操作的操作拦截\n        construct: function (target, args) &#123;\n               // 基于base.prototype创建新的对象\n            var obj = Object.create(base.prototype);\n            // 将当前对象和base原型对象进行关联\n            this.apply(target, obj, args);\n            // 返回创建好的对象\n            return obj;\n        &#125;,\n        apply: function (_target, that, args) &#123;\n            sup.apply(that, args);\n            base.apply(that, args);\n        &#125;\n    &#125;;\n    var proxy = new Proxy(base, handler);\n    descriptor.value = proxy;\n    Object.defineProperty(base.prototype, &quot;constructor&quot;, descriptor);\n    return proxy;\n&#125;\n\nvar Person = function (name) &#123;\n    this.name = name\n&#125;;\n\nvar Boy = extend(Person, function (name, age) &#123;\n    this.age = age;\n&#125;);\n\nBoy.prototype.sex = &quot;M&quot;;\n\nvar Peter = new Boy(&quot;Peter&quot;, 13);\nconsole.log(Peter.sex);  // &quot;M&quot;\nconsole.log(Peter.name); // &quot;Peter&quot;\nconsole.log(Peter.age);  // 13\n</code></pre>\n<h4 id=\"3-通过属性查找数组中特定的对象\"><a href=\"#3-通过属性查找数组中特定的对象\" class=\"headerlink\" title=\"3. 通过属性查找数组中特定的对象\"></a>3. 通过属性查找数组中特定的对象</h4><pre><code class=\"js\">// 创建测试数组 personLists\nlet personLists = [\n    &#123; name: &quot;张三&quot;, age: 24 &#125;,\n    &#123; name: &quot;李四&quot;, age: 22 &#125;,\n    &#123; name: &quot;王五&quot;, age: 25 &#125;,\n]\n\nlet pp = new Proxy(personLists, &#123;\n\n    get: function (target, prop, _proxy) &#123;\n        // 如果prop是target对象的一个属性，直接target上prop属性名对应的属性值\n        if (prop in target) &#123;\n            return target[prop];\n        &#125;\n        // 如果prop的值为“number”，则直接返回数组的长度\n        if (prop === &quot;number&quot;) &#123;\n            return target.length;\n        &#125;\n\n        let result, ages = &#123;&#125;;\n\n        for (let person of target) &#123;\n\n            if (person.name === prop) &#123;\n                result = person;\n            &#125;\n            if (ages[person.age]) &#123;\n                ages[person.age].push(person);\n            &#125; else &#123;\n                ages[person.age] = [person];\n            &#125;\n        &#125;\n\n        if (result) &#123;\n            return result;\n        &#125;\n\n        if (prop in ages) &#123;\n            return ages[prop];\n        &#125;\n\n        if (prop === &quot;ages&quot;) &#123;\n            return Object.keys(ages);\n        &#125;\n        // 返回未定义\n        return undefined;\n    &#125;\n\n&#125;)\n// &#123;name: &quot;张三&quot;, age: 24&#125;\nconsole.log(pp[0]);\n// &#123;name: &quot;张三&quot;, age: 24&#125;\nconsole.log(pp[&quot;张三&quot;]);\n// [&#123;name: &quot;张三&quot;, age: 24&#125;]\nconsole.log(pp[24]);\n// [&quot;22&quot;, &quot;24&quot;, &quot;25&quot;]\nconsole.log(pp.ages);\n// 3\nconsole.log(pp.number);\n</code></pre>\n<h4 id=\"4-实现观察者模式\"><a href=\"#4-实现观察者模式\" class=\"headerlink\" title=\"4. 实现观察者模式\"></a>4. 实现观察者模式</h4><pre><code class=\"js\">// 创建实例对象\nlet o = &#123;\n    a: 1,\n    b: 2,\n    c: 3\n&#125;\n/**\n * 在这里对对象o的属性c实现监控\n * c = a + b; 当a,b发生变化,c也要做出相应变化\n */\nlet p = new Proxy(o, &#123;\n    set: function (target, prop, value, _proxy) &#123;\n        target[prop] = value;\n        if (prop != &quot;c&quot;) &#123;\n            target.c = target.a + target.b;\n        &#125;\n    &#125;\n&#125;)\n// 输出原本p,&#123;a: 1, b: 2, c: 3&#125;\nconsole.log(p);\n// 修改p.a的值\np.a = 2;\n// 再次输出p, &#123;a: 2, b: 2, c: 4&#125;\nconsole.log(p);\n// 修改p.b的值\np.b = 3;\n// 输出p,&#123;a: 2, b: 3, c: 5&#125;\nconsole.log(p);\n</code></pre>\n<h4 id=\"5-低层封装，只允许上层访问特定接口-这里用属性举例\"><a href=\"#5-低层封装，只允许上层访问特定接口-这里用属性举例\" class=\"headerlink\" title=\"5. 低层封装，只允许上层访问特定接口(这里用属性举例)\"></a>5. 低层封装，只允许上层访问特定接口(这里用属性举例)</h4><pre><code class=\"js\">var Stack = (function () &#123;\n    // 原始对象定义\n    var stack = [];\n    // 可被允许访问的属性名\n    var allowed = [&quot;push&quot;, &quot;pop&quot;, &quot;length&quot;];\n    // 返回代理对象\n    return new Proxy(stack, &#123;\n        get: function (target, prop, _proxy) &#123;\n            // 如果是可以被访问的属性，就允许它指向\n            if (allowed.indexOf(prop) &gt; -1) &#123;\n                return target[prop];\n            &#125;\n            // 否则就抛出异常\n            throw new ReferenceError(`无权访问 $&#123;prop&#125; 属性`)\n        &#125;\n    &#125;);\n&#125;)\n// 创建Stack实例对象,s\nvar s = new Stack();\n// 可以执行push方法\ns.push(&quot;1&quot;);\n// 可以访问length属性，1\nconsole.log(s.length);\n// ReferenceError: 无权访问 __proto__ 属性\nconsole.log(s.__proto__);\n</code></pre>\n"},{"title":"Promise 认识","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"Promise","date":"2020-05-10T16:00:00.000Z","comments":0,"description":"Promise 认识","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识_bg.jpg"],"_content":"\n# Promise\n\n## What\n\n### 宏观\n\n一种异步编程的解决方案\n\n### 微观\n\nPromise是构造函数,用于创建Promise实例,其构造参数为一个包含异步操作的函数\n\n而Promise实例则可以用于获取异步操作后所返回的数据\n\n### 状态\n\npromise共有三中状态\n1. pending 正在执行中\n2. resolved 已成功\n3. rejected 已失败\n\n一开始的promsie的状态为pending,异步函数可以通过回调函数中传来的参数resolve,reject方法来改变该promise对象的状态\n\n调用resolve方法,promise的状态由pending-> resolved,意味着异步操作已成功\n\n调用reject方法,promise的状态由pending-> rejected,意味着异步操作已失败\n\n而且,promise的状态一旦改变就不可以再次恢复\n\n## Why\n\n### 纯函数,回调地狱\n\n当我们执行串行的异步操作时,如果采用纯回调函数的方式来处理的化,代码的阅读会变得非常糟糕\n\n例如\n```js\ndoSomething(function(result){\n  doSomethingElse(result,function(newResult){\n​    doSomethingFinally(newResult,function(finallyResult){\n​      console.log(`finallyResult: ${finallyResult}`)\n​    },failureCallback\n  }.failureCallback)\n},failureCallback)\n```\n\n而使用promise我们就可以通过链式来操作串行的异步操作,简化代码,方便阅读\n\n### 统一异常处理\n\n使用之前纯函数来处理串行异步操作,如果某一个环节出现了异常,我们需要为每一个执行异步操作的代码指定异常处理函数,异常的捕获会十分的困难\n\n而使用promise,因为promise的异常穿透,我们只需要最后使用catch函数抓捕异常就可以了\n\n### 指定回调函数灵活\n\n之前执行异步函数时,在执行异步操作时必须先指定回调函数\n\n而Promise可以等待异步操作执行完成后再指定相应的回调韩函数\n\n## How\n\n### API\n\n1. new Promise(executor)\n\n创建一个promise的实例对象\n\n传入的参数类型为函数\n\n当执行构造函数时,参数函数也会同步进行\n\n2. Promise.then(onResolved,onRejected)\n\n当promise的状态变为resolved/rejected会触发then中传递的回调函数,成功调用onResolved函数,失败调用onRejected韩素华\n\n3. Promise.catch(onRejected)\n\n当promise的状态变为rejected,我们可以使用onRejected函数来对rejected返回过来的结果进行处理\n\n4. Promise.prototype.resolve(value)\n\n简洁语法 手动创建一个指定value的promise,状态为resolved\n\n5. Promise.prototype.reject(reason)\n\n简洁语法 手动创建一个指定reason的promise,状态为rejected\n\n6. Promise.prototype.all(promises)\n\n返回一个prmise,其状态由参数数组中的所有promise决定,只有参数数组中的所有promise执行成功,则返回的promise才会成功,且value值为promise执行成功返回的值\n\n若其中一个promise执行失败,则返回的promise状态为rejected,且reason值为异常抛出的值\n\n7. Promise.prototype.race(promises)\n\n返回一个promise,.该promise的状态由参数数组中执行最快的promise决定,该promise为resolved状态,则返回的promise状态为resolved,promise为rejected状态,则返回的promise状态为rejected,\n\n### 注意点\n\n1. Promise的状态改变\n\nPromise的状态只能从pending-->resolved或者从pending-->rejected。\n一旦状态确定,就不能再次改变改promise的状态\n\n2. 指定多个回调函数\n\n当我们为promise指定多个成功/失败的回调函数,只要当前的promise处于pending状态,那么回调函数会放入回调队列中,当promise的状态变为resolved/rejected时,才会调用与之对应的回调队列的所有回调函数\n\n3. 同步执行执行器函数,同步指定回调函数,异步执行回调函数\n\n<!-- .... -->\n\n4. Promise.then()返回Promise\n\n<!-- .... -->\n\n5. promise.then()返回的promise状态由then()指定的回调函数的执行结果决定\n  \n若执行结果返回一个非promise对象,则then()返回promise的对象状态为resolved,value为返回值\n\n若执行过程中,异常抛出,则then()返回promise的对象状态为rejected,reason为error\n\n若执行结果返回一个promise对象,则then()返回promise的对象状态为执行函数返回的promise状态决定,resolved为resolved,rejected为rejected\n\n\n6. 执行多个串联的同步/异步任务\n\n<!-- .... -->\n\n7. Promise的异常穿透/中断链式调用链\n\n异常穿透实现的原因是因为当我们没有为then指定onRejected函数时,该值默认为reason=>{throw reason}\n\n中断链式调用链只要返回pending状态的promise即可\n\n### 代码实现\n\n```js\nclass Promise {\n\n  constructor(executor) {\n\n      const self = this;\n      self.status = PENDING;\n      self.callbacks = [];\n\n      function resolve(value) {\n          if (self.status !== PENDING) {\n              return\n          }\n          self.status = RESOLVED;\n          self.data = value;\n          if (self.callbacks.length > 0) {\n              setTimeout(() => {\n                  self.callbacks.forEach((callbackObj) => {\n                      callbackObj.onResolved(value);\n                  })\n              })\n          }\n      }\n\n      function reject(reason) {\n          if (self.status !== PENDING) {\n              return\n          }\n          self.status = REJECTED;\n          self.data = reason;\n          if (self.callbacks.length > 0) {\n              setTimeout(() => {\n                  self.callbacks.forEach((callbackObj) => {\n                      callbackObj.onRejected(reason);\n                  })\n              })\n          }\n      }\n\n      try {\n          executor(resolve, reject)\n      } catch (error) {\n          reject(error);\n      }\n\n  }\n\n  then(onResolved, onRejected) {\n\n      onResolved = typeof onResolved === \"function\" ? onResolved : value => value;\n      onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason };\n\n      const self = this;\n\n      return new Promise((resolve, reject) => {\n          function handle(callback) {\n              try {\n                  const result = callback(self.data);\n                  result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n              } catch (error) {\n                  reject(error)\n              }\n          }\n          switch (this.status) {\n              case PENDING:\n                  self.callbacks.push({\n                      onResolved(value) {\n                          handle(onResolved);\n                      },\n                      onRejected(reason) {\n                          handle(onRejected);\n                      }\n                  });\n                  break;\n              case RESOLVED:\n                  setTimeout(() => { handle(onResolved) });\n                  break;\n              case REJECTED:\n                  setTimeout(() => { handle(onRejected) });\n                  break;\n          }\n      })\n  }\n\n  catch(onRejected) {\n      return this.then(undefined, onRejected);\n  }\n\n  static resolve(value) {\n      return new Promise((resolve, reject) => {\n          value instanceof Promise ? value.then(resolve, reject) : resolve(value);\n      })\n  }\n\n  static reject(reason) {\n      return new Promise((resolve, reject) => {\n          reject(reason);\n      })\n  }\n\n  static all(promises) {\n\n      const values = new Array(promises.length);\n      let resolveCount = 0;\n\n      return new Promise((resolve, reject) => {\n          promises.forEach((p, index) => {\n              Promise.resolve(p).then(\n                  value => {\n                      values[index] = value;\n                      resolveCount++;\n                      if (resolveCount === promises.length) {\n                          resolve(values);\n                      }\n                  },\n                  reason => {\n                      reject(reason);\n                  }\n              )\n          })\n      })\n\n  }\n\n  static race(promises) {\n      return new Promise((resolve, reject) => {\n          promises.forEach((p) => {\n              Promise.resolve(p).then(resolve, reject);\n          })\n      })\n  }\n\n}\n```\n\n## 图片\n\n![Promise思维导图](https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识 01.jpg)\n","source":"_posts/前端/ES6/Promise认识.md","raw":"---\ntitle: Promise 认识\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg  \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - Promise\nkeywords: Promise\ndate: 2020-05-11\ncomments: false\ndescription: Promise 认识\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识_bg.jpg\n---\n\n# Promise\n\n## What\n\n### 宏观\n\n一种异步编程的解决方案\n\n### 微观\n\nPromise是构造函数,用于创建Promise实例,其构造参数为一个包含异步操作的函数\n\n而Promise实例则可以用于获取异步操作后所返回的数据\n\n### 状态\n\npromise共有三中状态\n1. pending 正在执行中\n2. resolved 已成功\n3. rejected 已失败\n\n一开始的promsie的状态为pending,异步函数可以通过回调函数中传来的参数resolve,reject方法来改变该promise对象的状态\n\n调用resolve方法,promise的状态由pending-> resolved,意味着异步操作已成功\n\n调用reject方法,promise的状态由pending-> rejected,意味着异步操作已失败\n\n而且,promise的状态一旦改变就不可以再次恢复\n\n## Why\n\n### 纯函数,回调地狱\n\n当我们执行串行的异步操作时,如果采用纯回调函数的方式来处理的化,代码的阅读会变得非常糟糕\n\n例如\n```js\ndoSomething(function(result){\n  doSomethingElse(result,function(newResult){\n​    doSomethingFinally(newResult,function(finallyResult){\n​      console.log(`finallyResult: ${finallyResult}`)\n​    },failureCallback\n  }.failureCallback)\n},failureCallback)\n```\n\n而使用promise我们就可以通过链式来操作串行的异步操作,简化代码,方便阅读\n\n### 统一异常处理\n\n使用之前纯函数来处理串行异步操作,如果某一个环节出现了异常,我们需要为每一个执行异步操作的代码指定异常处理函数,异常的捕获会十分的困难\n\n而使用promise,因为promise的异常穿透,我们只需要最后使用catch函数抓捕异常就可以了\n\n### 指定回调函数灵活\n\n之前执行异步函数时,在执行异步操作时必须先指定回调函数\n\n而Promise可以等待异步操作执行完成后再指定相应的回调韩函数\n\n## How\n\n### API\n\n1. new Promise(executor)\n\n创建一个promise的实例对象\n\n传入的参数类型为函数\n\n当执行构造函数时,参数函数也会同步进行\n\n2. Promise.then(onResolved,onRejected)\n\n当promise的状态变为resolved/rejected会触发then中传递的回调函数,成功调用onResolved函数,失败调用onRejected韩素华\n\n3. Promise.catch(onRejected)\n\n当promise的状态变为rejected,我们可以使用onRejected函数来对rejected返回过来的结果进行处理\n\n4. Promise.prototype.resolve(value)\n\n简洁语法 手动创建一个指定value的promise,状态为resolved\n\n5. Promise.prototype.reject(reason)\n\n简洁语法 手动创建一个指定reason的promise,状态为rejected\n\n6. Promise.prototype.all(promises)\n\n返回一个prmise,其状态由参数数组中的所有promise决定,只有参数数组中的所有promise执行成功,则返回的promise才会成功,且value值为promise执行成功返回的值\n\n若其中一个promise执行失败,则返回的promise状态为rejected,且reason值为异常抛出的值\n\n7. Promise.prototype.race(promises)\n\n返回一个promise,.该promise的状态由参数数组中执行最快的promise决定,该promise为resolved状态,则返回的promise状态为resolved,promise为rejected状态,则返回的promise状态为rejected,\n\n### 注意点\n\n1. Promise的状态改变\n\nPromise的状态只能从pending-->resolved或者从pending-->rejected。\n一旦状态确定,就不能再次改变改promise的状态\n\n2. 指定多个回调函数\n\n当我们为promise指定多个成功/失败的回调函数,只要当前的promise处于pending状态,那么回调函数会放入回调队列中,当promise的状态变为resolved/rejected时,才会调用与之对应的回调队列的所有回调函数\n\n3. 同步执行执行器函数,同步指定回调函数,异步执行回调函数\n\n<!-- .... -->\n\n4. Promise.then()返回Promise\n\n<!-- .... -->\n\n5. promise.then()返回的promise状态由then()指定的回调函数的执行结果决定\n  \n若执行结果返回一个非promise对象,则then()返回promise的对象状态为resolved,value为返回值\n\n若执行过程中,异常抛出,则then()返回promise的对象状态为rejected,reason为error\n\n若执行结果返回一个promise对象,则then()返回promise的对象状态为执行函数返回的promise状态决定,resolved为resolved,rejected为rejected\n\n\n6. 执行多个串联的同步/异步任务\n\n<!-- .... -->\n\n7. Promise的异常穿透/中断链式调用链\n\n异常穿透实现的原因是因为当我们没有为then指定onRejected函数时,该值默认为reason=>{throw reason}\n\n中断链式调用链只要返回pending状态的promise即可\n\n### 代码实现\n\n```js\nclass Promise {\n\n  constructor(executor) {\n\n      const self = this;\n      self.status = PENDING;\n      self.callbacks = [];\n\n      function resolve(value) {\n          if (self.status !== PENDING) {\n              return\n          }\n          self.status = RESOLVED;\n          self.data = value;\n          if (self.callbacks.length > 0) {\n              setTimeout(() => {\n                  self.callbacks.forEach((callbackObj) => {\n                      callbackObj.onResolved(value);\n                  })\n              })\n          }\n      }\n\n      function reject(reason) {\n          if (self.status !== PENDING) {\n              return\n          }\n          self.status = REJECTED;\n          self.data = reason;\n          if (self.callbacks.length > 0) {\n              setTimeout(() => {\n                  self.callbacks.forEach((callbackObj) => {\n                      callbackObj.onRejected(reason);\n                  })\n              })\n          }\n      }\n\n      try {\n          executor(resolve, reject)\n      } catch (error) {\n          reject(error);\n      }\n\n  }\n\n  then(onResolved, onRejected) {\n\n      onResolved = typeof onResolved === \"function\" ? onResolved : value => value;\n      onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason };\n\n      const self = this;\n\n      return new Promise((resolve, reject) => {\n          function handle(callback) {\n              try {\n                  const result = callback(self.data);\n                  result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n              } catch (error) {\n                  reject(error)\n              }\n          }\n          switch (this.status) {\n              case PENDING:\n                  self.callbacks.push({\n                      onResolved(value) {\n                          handle(onResolved);\n                      },\n                      onRejected(reason) {\n                          handle(onRejected);\n                      }\n                  });\n                  break;\n              case RESOLVED:\n                  setTimeout(() => { handle(onResolved) });\n                  break;\n              case REJECTED:\n                  setTimeout(() => { handle(onRejected) });\n                  break;\n          }\n      })\n  }\n\n  catch(onRejected) {\n      return this.then(undefined, onRejected);\n  }\n\n  static resolve(value) {\n      return new Promise((resolve, reject) => {\n          value instanceof Promise ? value.then(resolve, reject) : resolve(value);\n      })\n  }\n\n  static reject(reason) {\n      return new Promise((resolve, reject) => {\n          reject(reason);\n      })\n  }\n\n  static all(promises) {\n\n      const values = new Array(promises.length);\n      let resolveCount = 0;\n\n      return new Promise((resolve, reject) => {\n          promises.forEach((p, index) => {\n              Promise.resolve(p).then(\n                  value => {\n                      values[index] = value;\n                      resolveCount++;\n                      if (resolveCount === promises.length) {\n                          resolve(values);\n                      }\n                  },\n                  reason => {\n                      reject(reason);\n                  }\n              )\n          })\n      })\n\n  }\n\n  static race(promises) {\n      return new Promise((resolve, reject) => {\n          promises.forEach((p) => {\n              Promise.resolve(p).then(resolve, reject);\n          })\n      })\n  }\n\n}\n```\n\n## 图片\n\n![Promise思维导图](https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识 01.jpg)\n","slug":"前端/ES6/Promise认识","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2r00142h17h2589xsw","content":"<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><h3 id=\"宏观\"><a href=\"#宏观\" class=\"headerlink\" title=\"宏观\"></a>宏观</h3><p>一种异步编程的解决方案</p>\n<h3 id=\"微观\"><a href=\"#微观\" class=\"headerlink\" title=\"微观\"></a>微观</h3><p>Promise是构造函数,用于创建Promise实例,其构造参数为一个包含异步操作的函数</p>\n<p>而Promise实例则可以用于获取异步操作后所返回的数据</p>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><p>promise共有三中状态</p>\n<ol>\n<li>pending 正在执行中</li>\n<li>resolved 已成功</li>\n<li>rejected 已失败</li>\n</ol>\n<p>一开始的promsie的状态为pending,异步函数可以通过回调函数中传来的参数resolve,reject方法来改变该promise对象的状态</p>\n<p>调用resolve方法,promise的状态由pending-&gt; resolved,意味着异步操作已成功</p>\n<p>调用reject方法,promise的状态由pending-&gt; rejected,意味着异步操作已失败</p>\n<p>而且,promise的状态一旦改变就不可以再次恢复</p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><h3 id=\"纯函数-回调地狱\"><a href=\"#纯函数-回调地狱\" class=\"headerlink\" title=\"纯函数,回调地狱\"></a>纯函数,回调地狱</h3><p>当我们执行串行的异步操作时,如果采用纯回调函数的方式来处理的化,代码的阅读会变得非常糟糕</p>\n<p>例如</p>\n<pre><code class=\"js\">doSomething(function(result)&#123;\n  doSomethingElse(result,function(newResult)&#123;\n​    doSomethingFinally(newResult,function(finallyResult)&#123;\n​      console.log(`finallyResult: $&#123;finallyResult&#125;`)\n​    &#125;,failureCallback\n  &#125;.failureCallback)\n&#125;,failureCallback)\n</code></pre>\n<p>而使用promise我们就可以通过链式来操作串行的异步操作,简化代码,方便阅读</p>\n<h3 id=\"统一异常处理\"><a href=\"#统一异常处理\" class=\"headerlink\" title=\"统一异常处理\"></a>统一异常处理</h3><p>使用之前纯函数来处理串行异步操作,如果某一个环节出现了异常,我们需要为每一个执行异步操作的代码指定异常处理函数,异常的捕获会十分的困难</p>\n<p>而使用promise,因为promise的异常穿透,我们只需要最后使用catch函数抓捕异常就可以了</p>\n<h3 id=\"指定回调函数灵活\"><a href=\"#指定回调函数灵活\" class=\"headerlink\" title=\"指定回调函数灵活\"></a>指定回调函数灵活</h3><p>之前执行异步函数时,在执行异步操作时必须先指定回调函数</p>\n<p>而Promise可以等待异步操作执行完成后再指定相应的回调韩函数</p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ol>\n<li>new Promise(executor)</li>\n</ol>\n<p>创建一个promise的实例对象</p>\n<p>传入的参数类型为函数</p>\n<p>当执行构造函数时,参数函数也会同步进行</p>\n<ol start=\"2\">\n<li>Promise.then(onResolved,onRejected)</li>\n</ol>\n<p>当promise的状态变为resolved&#x2F;rejected会触发then中传递的回调函数,成功调用onResolved函数,失败调用onRejected韩素华</p>\n<ol start=\"3\">\n<li>Promise.catch(onRejected)</li>\n</ol>\n<p>当promise的状态变为rejected,我们可以使用onRejected函数来对rejected返回过来的结果进行处理</p>\n<ol start=\"4\">\n<li>Promise.prototype.resolve(value)</li>\n</ol>\n<p>简洁语法 手动创建一个指定value的promise,状态为resolved</p>\n<ol start=\"5\">\n<li>Promise.prototype.reject(reason)</li>\n</ol>\n<p>简洁语法 手动创建一个指定reason的promise,状态为rejected</p>\n<ol start=\"6\">\n<li>Promise.prototype.all(promises)</li>\n</ol>\n<p>返回一个prmise,其状态由参数数组中的所有promise决定,只有参数数组中的所有promise执行成功,则返回的promise才会成功,且value值为promise执行成功返回的值</p>\n<p>若其中一个promise执行失败,则返回的promise状态为rejected,且reason值为异常抛出的值</p>\n<ol start=\"7\">\n<li>Promise.prototype.race(promises)</li>\n</ol>\n<p>返回一个promise,.该promise的状态由参数数组中执行最快的promise决定,该promise为resolved状态,则返回的promise状态为resolved,promise为rejected状态,则返回的promise状态为rejected,</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ol>\n<li>Promise的状态改变</li>\n</ol>\n<p>Promise的状态只能从pending–&gt;resolved或者从pending–&gt;rejected。<br>一旦状态确定,就不能再次改变改promise的状态</p>\n<ol start=\"2\">\n<li>指定多个回调函数</li>\n</ol>\n<p>当我们为promise指定多个成功&#x2F;失败的回调函数,只要当前的promise处于pending状态,那么回调函数会放入回调队列中,当promise的状态变为resolved&#x2F;rejected时,才会调用与之对应的回调队列的所有回调函数</p>\n<ol start=\"3\">\n<li>同步执行执行器函数,同步指定回调函数,异步执行回调函数</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"4\">\n<li>Promise.then()返回Promise</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"5\">\n<li>promise.then()返回的promise状态由then()指定的回调函数的执行结果决定</li>\n</ol>\n<p>若执行结果返回一个非promise对象,则then()返回promise的对象状态为resolved,value为返回值</p>\n<p>若执行过程中,异常抛出,则then()返回promise的对象状态为rejected,reason为error</p>\n<p>若执行结果返回一个promise对象,则then()返回promise的对象状态为执行函数返回的promise状态决定,resolved为resolved,rejected为rejected</p>\n<ol start=\"6\">\n<li>执行多个串联的同步&#x2F;异步任务</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"7\">\n<li>Promise的异常穿透&#x2F;中断链式调用链</li>\n</ol>\n<p>异常穿透实现的原因是因为当我们没有为then指定onRejected函数时,该值默认为reason&#x3D;&gt;{throw reason}</p>\n<p>中断链式调用链只要返回pending状态的promise即可</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><pre><code class=\"js\">class Promise &#123;\n\n  constructor(executor) &#123;\n\n      const self = this;\n      self.status = PENDING;\n      self.callbacks = [];\n\n      function resolve(value) &#123;\n          if (self.status !== PENDING) &#123;\n              return\n          &#125;\n          self.status = RESOLVED;\n          self.data = value;\n          if (self.callbacks.length &gt; 0) &#123;\n              setTimeout(() =&gt; &#123;\n                  self.callbacks.forEach((callbackObj) =&gt; &#123;\n                      callbackObj.onResolved(value);\n                  &#125;)\n              &#125;)\n          &#125;\n      &#125;\n\n      function reject(reason) &#123;\n          if (self.status !== PENDING) &#123;\n              return\n          &#125;\n          self.status = REJECTED;\n          self.data = reason;\n          if (self.callbacks.length &gt; 0) &#123;\n              setTimeout(() =&gt; &#123;\n                  self.callbacks.forEach((callbackObj) =&gt; &#123;\n                      callbackObj.onRejected(reason);\n                  &#125;)\n              &#125;)\n          &#125;\n      &#125;\n\n      try &#123;\n          executor(resolve, reject)\n      &#125; catch (error) &#123;\n          reject(error);\n      &#125;\n\n  &#125;\n\n  then(onResolved, onRejected) &#123;\n\n      onResolved = typeof onResolved === &quot;function&quot; ? onResolved : value =&gt; value;\n      onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123; throw reason &#125;;\n\n      const self = this;\n\n      return new Promise((resolve, reject) =&gt; &#123;\n          function handle(callback) &#123;\n              try &#123;\n                  const result = callback(self.data);\n                  result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n              &#125; catch (error) &#123;\n                  reject(error)\n              &#125;\n          &#125;\n          switch (this.status) &#123;\n              case PENDING:\n                  self.callbacks.push(&#123;\n                      onResolved(value) &#123;\n                          handle(onResolved);\n                      &#125;,\n                      onRejected(reason) &#123;\n                          handle(onRejected);\n                      &#125;\n                  &#125;);\n                  break;\n              case RESOLVED:\n                  setTimeout(() =&gt; &#123; handle(onResolved) &#125;);\n                  break;\n              case REJECTED:\n                  setTimeout(() =&gt; &#123; handle(onRejected) &#125;);\n                  break;\n          &#125;\n      &#125;)\n  &#125;\n\n  catch(onRejected) &#123;\n      return this.then(undefined, onRejected);\n  &#125;\n\n  static resolve(value) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          value instanceof Promise ? value.then(resolve, reject) : resolve(value);\n      &#125;)\n  &#125;\n\n  static reject(reason) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          reject(reason);\n      &#125;)\n  &#125;\n\n  static all(promises) &#123;\n\n      const values = new Array(promises.length);\n      let resolveCount = 0;\n\n      return new Promise((resolve, reject) =&gt; &#123;\n          promises.forEach((p, index) =&gt; &#123;\n              Promise.resolve(p).then(\n                  value =&gt; &#123;\n                      values[index] = value;\n                      resolveCount++;\n                      if (resolveCount === promises.length) &#123;\n                          resolve(values);\n                      &#125;\n                  &#125;,\n                  reason =&gt; &#123;\n                      reject(reason);\n                  &#125;\n              )\n          &#125;)\n      &#125;)\n\n  &#125;\n\n  static race(promises) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          promises.forEach((p) =&gt; &#123;\n              Promise.resolve(p).then(resolve, reject);\n          &#125;)\n      &#125;)\n  &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>![Promise思维导图](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Promise%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识</a> 01.jpg)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><h3 id=\"宏观\"><a href=\"#宏观\" class=\"headerlink\" title=\"宏观\"></a>宏观</h3><p>一种异步编程的解决方案</p>\n<h3 id=\"微观\"><a href=\"#微观\" class=\"headerlink\" title=\"微观\"></a>微观</h3><p>Promise是构造函数,用于创建Promise实例,其构造参数为一个包含异步操作的函数</p>\n<p>而Promise实例则可以用于获取异步操作后所返回的数据</p>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><p>promise共有三中状态</p>\n<ol>\n<li>pending 正在执行中</li>\n<li>resolved 已成功</li>\n<li>rejected 已失败</li>\n</ol>\n<p>一开始的promsie的状态为pending,异步函数可以通过回调函数中传来的参数resolve,reject方法来改变该promise对象的状态</p>\n<p>调用resolve方法,promise的状态由pending-&gt; resolved,意味着异步操作已成功</p>\n<p>调用reject方法,promise的状态由pending-&gt; rejected,意味着异步操作已失败</p>\n<p>而且,promise的状态一旦改变就不可以再次恢复</p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><h3 id=\"纯函数-回调地狱\"><a href=\"#纯函数-回调地狱\" class=\"headerlink\" title=\"纯函数,回调地狱\"></a>纯函数,回调地狱</h3><p>当我们执行串行的异步操作时,如果采用纯回调函数的方式来处理的化,代码的阅读会变得非常糟糕</p>\n<p>例如</p>\n<pre><code class=\"js\">doSomething(function(result)&#123;\n  doSomethingElse(result,function(newResult)&#123;\n​    doSomethingFinally(newResult,function(finallyResult)&#123;\n​      console.log(`finallyResult: $&#123;finallyResult&#125;`)\n​    &#125;,failureCallback\n  &#125;.failureCallback)\n&#125;,failureCallback)\n</code></pre>\n<p>而使用promise我们就可以通过链式来操作串行的异步操作,简化代码,方便阅读</p>\n<h3 id=\"统一异常处理\"><a href=\"#统一异常处理\" class=\"headerlink\" title=\"统一异常处理\"></a>统一异常处理</h3><p>使用之前纯函数来处理串行异步操作,如果某一个环节出现了异常,我们需要为每一个执行异步操作的代码指定异常处理函数,异常的捕获会十分的困难</p>\n<p>而使用promise,因为promise的异常穿透,我们只需要最后使用catch函数抓捕异常就可以了</p>\n<h3 id=\"指定回调函数灵活\"><a href=\"#指定回调函数灵活\" class=\"headerlink\" title=\"指定回调函数灵活\"></a>指定回调函数灵活</h3><p>之前执行异步函数时,在执行异步操作时必须先指定回调函数</p>\n<p>而Promise可以等待异步操作执行完成后再指定相应的回调韩函数</p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><ol>\n<li>new Promise(executor)</li>\n</ol>\n<p>创建一个promise的实例对象</p>\n<p>传入的参数类型为函数</p>\n<p>当执行构造函数时,参数函数也会同步进行</p>\n<ol start=\"2\">\n<li>Promise.then(onResolved,onRejected)</li>\n</ol>\n<p>当promise的状态变为resolved&#x2F;rejected会触发then中传递的回调函数,成功调用onResolved函数,失败调用onRejected韩素华</p>\n<ol start=\"3\">\n<li>Promise.catch(onRejected)</li>\n</ol>\n<p>当promise的状态变为rejected,我们可以使用onRejected函数来对rejected返回过来的结果进行处理</p>\n<ol start=\"4\">\n<li>Promise.prototype.resolve(value)</li>\n</ol>\n<p>简洁语法 手动创建一个指定value的promise,状态为resolved</p>\n<ol start=\"5\">\n<li>Promise.prototype.reject(reason)</li>\n</ol>\n<p>简洁语法 手动创建一个指定reason的promise,状态为rejected</p>\n<ol start=\"6\">\n<li>Promise.prototype.all(promises)</li>\n</ol>\n<p>返回一个prmise,其状态由参数数组中的所有promise决定,只有参数数组中的所有promise执行成功,则返回的promise才会成功,且value值为promise执行成功返回的值</p>\n<p>若其中一个promise执行失败,则返回的promise状态为rejected,且reason值为异常抛出的值</p>\n<ol start=\"7\">\n<li>Promise.prototype.race(promises)</li>\n</ol>\n<p>返回一个promise,.该promise的状态由参数数组中执行最快的promise决定,该promise为resolved状态,则返回的promise状态为resolved,promise为rejected状态,则返回的promise状态为rejected,</p>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ol>\n<li>Promise的状态改变</li>\n</ol>\n<p>Promise的状态只能从pending–&gt;resolved或者从pending–&gt;rejected。<br>一旦状态确定,就不能再次改变改promise的状态</p>\n<ol start=\"2\">\n<li>指定多个回调函数</li>\n</ol>\n<p>当我们为promise指定多个成功&#x2F;失败的回调函数,只要当前的promise处于pending状态,那么回调函数会放入回调队列中,当promise的状态变为resolved&#x2F;rejected时,才会调用与之对应的回调队列的所有回调函数</p>\n<ol start=\"3\">\n<li>同步执行执行器函数,同步指定回调函数,异步执行回调函数</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"4\">\n<li>Promise.then()返回Promise</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"5\">\n<li>promise.then()返回的promise状态由then()指定的回调函数的执行结果决定</li>\n</ol>\n<p>若执行结果返回一个非promise对象,则then()返回promise的对象状态为resolved,value为返回值</p>\n<p>若执行过程中,异常抛出,则then()返回promise的对象状态为rejected,reason为error</p>\n<p>若执行结果返回一个promise对象,则then()返回promise的对象状态为执行函数返回的promise状态决定,resolved为resolved,rejected为rejected</p>\n<ol start=\"6\">\n<li>执行多个串联的同步&#x2F;异步任务</li>\n</ol>\n<!-- .... -->\n\n<ol start=\"7\">\n<li>Promise的异常穿透&#x2F;中断链式调用链</li>\n</ol>\n<p>异常穿透实现的原因是因为当我们没有为then指定onRejected函数时,该值默认为reason&#x3D;&gt;{throw reason}</p>\n<p>中断链式调用链只要返回pending状态的promise即可</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><pre><code class=\"js\">class Promise &#123;\n\n  constructor(executor) &#123;\n\n      const self = this;\n      self.status = PENDING;\n      self.callbacks = [];\n\n      function resolve(value) &#123;\n          if (self.status !== PENDING) &#123;\n              return\n          &#125;\n          self.status = RESOLVED;\n          self.data = value;\n          if (self.callbacks.length &gt; 0) &#123;\n              setTimeout(() =&gt; &#123;\n                  self.callbacks.forEach((callbackObj) =&gt; &#123;\n                      callbackObj.onResolved(value);\n                  &#125;)\n              &#125;)\n          &#125;\n      &#125;\n\n      function reject(reason) &#123;\n          if (self.status !== PENDING) &#123;\n              return\n          &#125;\n          self.status = REJECTED;\n          self.data = reason;\n          if (self.callbacks.length &gt; 0) &#123;\n              setTimeout(() =&gt; &#123;\n                  self.callbacks.forEach((callbackObj) =&gt; &#123;\n                      callbackObj.onRejected(reason);\n                  &#125;)\n              &#125;)\n          &#125;\n      &#125;\n\n      try &#123;\n          executor(resolve, reject)\n      &#125; catch (error) &#123;\n          reject(error);\n      &#125;\n\n  &#125;\n\n  then(onResolved, onRejected) &#123;\n\n      onResolved = typeof onResolved === &quot;function&quot; ? onResolved : value =&gt; value;\n      onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123; throw reason &#125;;\n\n      const self = this;\n\n      return new Promise((resolve, reject) =&gt; &#123;\n          function handle(callback) &#123;\n              try &#123;\n                  const result = callback(self.data);\n                  result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n              &#125; catch (error) &#123;\n                  reject(error)\n              &#125;\n          &#125;\n          switch (this.status) &#123;\n              case PENDING:\n                  self.callbacks.push(&#123;\n                      onResolved(value) &#123;\n                          handle(onResolved);\n                      &#125;,\n                      onRejected(reason) &#123;\n                          handle(onRejected);\n                      &#125;\n                  &#125;);\n                  break;\n              case RESOLVED:\n                  setTimeout(() =&gt; &#123; handle(onResolved) &#125;);\n                  break;\n              case REJECTED:\n                  setTimeout(() =&gt; &#123; handle(onRejected) &#125;);\n                  break;\n          &#125;\n      &#125;)\n  &#125;\n\n  catch(onRejected) &#123;\n      return this.then(undefined, onRejected);\n  &#125;\n\n  static resolve(value) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          value instanceof Promise ? value.then(resolve, reject) : resolve(value);\n      &#125;)\n  &#125;\n\n  static reject(reason) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          reject(reason);\n      &#125;)\n  &#125;\n\n  static all(promises) &#123;\n\n      const values = new Array(promises.length);\n      let resolveCount = 0;\n\n      return new Promise((resolve, reject) =&gt; &#123;\n          promises.forEach((p, index) =&gt; &#123;\n              Promise.resolve(p).then(\n                  value =&gt; &#123;\n                      values[index] = value;\n                      resolveCount++;\n                      if (resolveCount === promises.length) &#123;\n                          resolve(values);\n                      &#125;\n                  &#125;,\n                  reason =&gt; &#123;\n                      reject(reason);\n                  &#125;\n              )\n          &#125;)\n      &#125;)\n\n  &#125;\n\n  static race(promises) &#123;\n      return new Promise((resolve, reject) =&gt; &#123;\n          promises.forEach((p) =&gt; &#123;\n              Promise.resolve(p).then(resolve, reject);\n          &#125;)\n      &#125;)\n  &#125;\n\n&#125;\n</code></pre>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>![Promise思维导图](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/Promise%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/Promise认识</a> 01.jpg)</p>\n"},{"title":"Symbol对象","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES6","date":"2019-12-29T16:00:00.000Z","comments":0,"description":"Symbol对象","photos":["http://p2.qhimg.com/bdm/960_593_0/t014817280afeb31136.jpg"],"_content":"---\n## 基本使用\n\n​\tSymbol是es6新增的一个基本的数据类型。增加该类型的主要目的是为了能够实现对象的属性名能够唯一化。\n\n```\n最新的ECMAScript标准定义了8中数据类型\n7种基本数据类型\n- 布尔值(Boolean):true/false\n- null:一个表示null的特殊关键字\n- undefined,和null一样特殊的关键字，undefined表示变量未定义时的属性\n- 数字(Number)，整数或者浮点数\n- 任意精度的整数(BigInt),可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。\n- 字符串(String),字符串是一串表示文本值的字符序列，例如\"helloworld\"\n- 代表(Symbol,在Es6新添加的基本数据类型)，一种实例是唯一且不可改变的数据类型\n以及对象(Object)\n```\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t来自[MDM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types)\n\n也正式因为Symbol对象的存在，在es6种m对象的属性名现在可以分为两种\n\n1. 字符串\n2. Symbol实例\n\n而接下来就是演示Symbol的基本使用（以代码为主）\n\n```js\n// 注意,Symbol不能与关键字new使用\nlet s = Symbol(\"对于该属性的一些文字描述，用英文\");\n// 定义对象\nvar o = {\n    a:1,\n    // 在为一个对象添加Symbol属性时，要用[]包裹Symbol实例对象\n    [s]:\"hello world\"\n}\n// 输出结果\nconsole.log(o);\n```\n\n但是Symbol属性名是无法被for...in等方法调用，所有我们需要知道如何去获取对象的Symbol属性。下面有一些方法可以获取一个对象的Symbol属性\n\n```js\n1. Object.getOwnPropertySymbols(obj) // 获取obj对象上的所有Symbol属性\n2. Reflect.ownKeys(obj) // 获取obj对象上的所有属性，包括Symbol \n```\n\n\n\n## 高级使用(该部分来自阮一峰老师的[es6](http://es6.ruanyifeng.com/#docs/symbol))\n\n#### 1. 魔术字符串的消除\n\n​\t魔术字符串：是指在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数组\n\n​\t而为了后期修改那些常值的方便，我们应该使用变量来代替代码中经常出现的常值。这样，如果以后要修改这些常常值，我们只需要修改变量的值就能达到修改那些常值的效果\n\n​\t而因为Symbol实例的唯一性，它就非常适合充当魔术字符串的变量\n\n```js\nconst shapeType = {\n  triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n  let area = 0;\n  switch (shape) {\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  }\n  return area;\n}\n\ngetArea(shapeType.triangle, { width: 100, height: 100 });\n```\n\n#### 2. 模块的Singleton模式\n\n​\tSingleton模式指的是调用一个类，在任何时候返回的都是一个实例\n\n​\t个人理解就是在引入调用一个类时，应该返回的都是同一个实例，而不是再基于该类重新创建新的对象。\n\n​\t那么如何使用Symbol来实现Singleton\n\n​\t具体内容：http://es6.ruanyifeng.com/#docs/symbol\n\n## Symbol常用属性的使用\n\n​\t\tSymbol原型上有一些属性，可以方便我们使用。在这里，我提几个我个人认为非常实用的一些属性\n\n#### 1. Symbol.iterator(Object)\n\n```\n该属性为每一个对象定义一个默认的迭代器。该迭代器可以被for...of循环使用。\n我们可以使用该属性为该对象设置默认的迭代器\n```\n\n```js\nvar o = {\n    // 定义对象o的默认迭代器\n    // 其属性值是一个Generator函数\n    [Symbol.iterator]: function* () {\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n};\n// [1,2,3]\nconsole.log([...o]);\n```\n\n#### 2. Symbol.toPrimitive（Object）\n\n```\n该属性是一个内置的Symbol值，它是作为对象的函数值属性存在的，当对象转换为对应的原始值时，会调用此函数\n控制该对象被强制转换成其他数据类型时的处理方法\n```\n\n```js\nvar o = {\n    // hint为当将该对象强制转换时所要被强制转换的类型，string\n    [Symbol.toPrimitive]:function(hint){\n        // 可自行输出看看hint的内容\n        // console.log(hint);\n        \n        // 如果是number类型\n        if(hint==\"number\"){\n            return 42;\n        }\n        // 如果是string类型\n        if(hint==\"string\"){\n            return \"hello world\";\n        }\n        // 其他类型\n        return true;\n    }\n};\n// Number{42}\nconsole.log(new Number(o));\n// String{\"hello world\"}\nconsole.log(new String(o));\n// Boolean{true}\nconsole.log(new Boolean(o));\n```\n\n#### 3.Symbol.toStringTag(Class)\n\n\n该属性是一个内置属性，它通常作为对象的属性键使用，对应的属性名应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，只有内置的Object.prototype.toString()方法会去读取这个标签并把它包含在自己的返回值里\n\n\n```js\nclass A{\n    // Symbol.toStringTag是定义在对象的类上\n    // 我们可以通过该属性可以自定义类添加一个自己定义的标签\n    get [Symbol.toStringTag](){\n        return \"This is A class\"\n    }\n}\n// [object This is A class]\nconsole.log(Object.prototype.toString.call(new A()));\n```\n\n#### 4. **Symbol.spcies**\n\n\n该属性是一个函数值属性，其被构造函数用于创建派生对象\n该属性可以允许子类覆盖对象的默认构造函数\n\n\n```js\n// 来自https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species\nclass MyArray extends Array {\n    // 覆盖 species 到父级的 Array 构造函数上\n    static get [Symbol.species]() {\n        return Array;\n    }\n}\n\nvar a = new MyArray(1,2,3);\nvar mapped = a.map(x=>x*x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);  // true\n```\n\n## Symbol常用方法的使用\n\n#### 1. **Symbol.for()**\n\n\n该方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。\n\n\n```js\n// 创建一个 symbol 并放入 symbol 注册表中，键为 \"demo.A\"\nSymbol.for(\"demo.A\");\n// 从 symbol 注册表中读取键为\"demo.A\"的 symbol\nSymbol.for(\"demo.A\"); \n\n\n// true，证明了上面说的\nSymbol.for(\"demo.B\") === Symbol.for(\"demo.B\"); \n// false，Symbol() 函数每次都会返回新的一个 symbol\nSymbol(\"demo.B\") === Symbol(\"demo.B\");\n```\n\n#### 2. **Symbol.keyFor()**\n\n\n该方法用来获取 symbol 注册表中与某个 symbol 关联的键。\n\n\n```js\n// 创建一个 symbol 并放入 Symbol 注册表，key 为 \"demo.A\"\nvar globalSym = Symbol.for(\"demo.A\");\n// demo.A\nconsole.log(Symbol.keyFor(globalSym));\n\n// 创建一个 symbol，但不放入 symbol 注册表中\nvar localSym = Symbol();\n// undefined\nconsole.log(Symbol.keyFor(localSym));\n\n// undefined\nconsole.log(Symbol.keyFor(Symbol.iterator));\n```\n","source":"_posts/前端/ES6/Symbol对象.md","raw":"---\ntitle: Symbol对象\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - ES6\nkeywords: ES6\ndate: 2019-12-30\ncomments: false\ndescription: Symbol对象\nphotos: http://p2.qhimg.com/bdm/960_593_0/t014817280afeb31136.jpg\n---\n---\n## 基本使用\n\n​\tSymbol是es6新增的一个基本的数据类型。增加该类型的主要目的是为了能够实现对象的属性名能够唯一化。\n\n```\n最新的ECMAScript标准定义了8中数据类型\n7种基本数据类型\n- 布尔值(Boolean):true/false\n- null:一个表示null的特殊关键字\n- undefined,和null一样特殊的关键字，undefined表示变量未定义时的属性\n- 数字(Number)，整数或者浮点数\n- 任意精度的整数(BigInt),可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。\n- 字符串(String),字符串是一串表示文本值的字符序列，例如\"helloworld\"\n- 代表(Symbol,在Es6新添加的基本数据类型)，一种实例是唯一且不可改变的数据类型\n以及对象(Object)\n```\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t来自[MDM](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types)\n\n也正式因为Symbol对象的存在，在es6种m对象的属性名现在可以分为两种\n\n1. 字符串\n2. Symbol实例\n\n而接下来就是演示Symbol的基本使用（以代码为主）\n\n```js\n// 注意,Symbol不能与关键字new使用\nlet s = Symbol(\"对于该属性的一些文字描述，用英文\");\n// 定义对象\nvar o = {\n    a:1,\n    // 在为一个对象添加Symbol属性时，要用[]包裹Symbol实例对象\n    [s]:\"hello world\"\n}\n// 输出结果\nconsole.log(o);\n```\n\n但是Symbol属性名是无法被for...in等方法调用，所有我们需要知道如何去获取对象的Symbol属性。下面有一些方法可以获取一个对象的Symbol属性\n\n```js\n1. Object.getOwnPropertySymbols(obj) // 获取obj对象上的所有Symbol属性\n2. Reflect.ownKeys(obj) // 获取obj对象上的所有属性，包括Symbol \n```\n\n\n\n## 高级使用(该部分来自阮一峰老师的[es6](http://es6.ruanyifeng.com/#docs/symbol))\n\n#### 1. 魔术字符串的消除\n\n​\t魔术字符串：是指在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数组\n\n​\t而为了后期修改那些常值的方便，我们应该使用变量来代替代码中经常出现的常值。这样，如果以后要修改这些常常值，我们只需要修改变量的值就能达到修改那些常值的效果\n\n​\t而因为Symbol实例的唯一性，它就非常适合充当魔术字符串的变量\n\n```js\nconst shapeType = {\n  triangle: Symbol()\n};\n\nfunction getArea(shape, options) {\n  let area = 0;\n  switch (shape) {\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  }\n  return area;\n}\n\ngetArea(shapeType.triangle, { width: 100, height: 100 });\n```\n\n#### 2. 模块的Singleton模式\n\n​\tSingleton模式指的是调用一个类，在任何时候返回的都是一个实例\n\n​\t个人理解就是在引入调用一个类时，应该返回的都是同一个实例，而不是再基于该类重新创建新的对象。\n\n​\t那么如何使用Symbol来实现Singleton\n\n​\t具体内容：http://es6.ruanyifeng.com/#docs/symbol\n\n## Symbol常用属性的使用\n\n​\t\tSymbol原型上有一些属性，可以方便我们使用。在这里，我提几个我个人认为非常实用的一些属性\n\n#### 1. Symbol.iterator(Object)\n\n```\n该属性为每一个对象定义一个默认的迭代器。该迭代器可以被for...of循环使用。\n我们可以使用该属性为该对象设置默认的迭代器\n```\n\n```js\nvar o = {\n    // 定义对象o的默认迭代器\n    // 其属性值是一个Generator函数\n    [Symbol.iterator]: function* () {\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n};\n// [1,2,3]\nconsole.log([...o]);\n```\n\n#### 2. Symbol.toPrimitive（Object）\n\n```\n该属性是一个内置的Symbol值，它是作为对象的函数值属性存在的，当对象转换为对应的原始值时，会调用此函数\n控制该对象被强制转换成其他数据类型时的处理方法\n```\n\n```js\nvar o = {\n    // hint为当将该对象强制转换时所要被强制转换的类型，string\n    [Symbol.toPrimitive]:function(hint){\n        // 可自行输出看看hint的内容\n        // console.log(hint);\n        \n        // 如果是number类型\n        if(hint==\"number\"){\n            return 42;\n        }\n        // 如果是string类型\n        if(hint==\"string\"){\n            return \"hello world\";\n        }\n        // 其他类型\n        return true;\n    }\n};\n// Number{42}\nconsole.log(new Number(o));\n// String{\"hello world\"}\nconsole.log(new String(o));\n// Boolean{true}\nconsole.log(new Boolean(o));\n```\n\n#### 3.Symbol.toStringTag(Class)\n\n\n该属性是一个内置属性，它通常作为对象的属性键使用，对应的属性名应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，只有内置的Object.prototype.toString()方法会去读取这个标签并把它包含在自己的返回值里\n\n\n```js\nclass A{\n    // Symbol.toStringTag是定义在对象的类上\n    // 我们可以通过该属性可以自定义类添加一个自己定义的标签\n    get [Symbol.toStringTag](){\n        return \"This is A class\"\n    }\n}\n// [object This is A class]\nconsole.log(Object.prototype.toString.call(new A()));\n```\n\n#### 4. **Symbol.spcies**\n\n\n该属性是一个函数值属性，其被构造函数用于创建派生对象\n该属性可以允许子类覆盖对象的默认构造函数\n\n\n```js\n// 来自https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species\nclass MyArray extends Array {\n    // 覆盖 species 到父级的 Array 构造函数上\n    static get [Symbol.species]() {\n        return Array;\n    }\n}\n\nvar a = new MyArray(1,2,3);\nvar mapped = a.map(x=>x*x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);  // true\n```\n\n## Symbol常用方法的使用\n\n#### 1. **Symbol.for()**\n\n\n该方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。\n\n\n```js\n// 创建一个 symbol 并放入 symbol 注册表中，键为 \"demo.A\"\nSymbol.for(\"demo.A\");\n// 从 symbol 注册表中读取键为\"demo.A\"的 symbol\nSymbol.for(\"demo.A\"); \n\n\n// true，证明了上面说的\nSymbol.for(\"demo.B\") === Symbol.for(\"demo.B\"); \n// false，Symbol() 函数每次都会返回新的一个 symbol\nSymbol(\"demo.B\") === Symbol(\"demo.B\");\n```\n\n#### 2. **Symbol.keyFor()**\n\n\n该方法用来获取 symbol 注册表中与某个 symbol 关联的键。\n\n\n```js\n// 创建一个 symbol 并放入 Symbol 注册表，key 为 \"demo.A\"\nvar globalSym = Symbol.for(\"demo.A\");\n// demo.A\nconsole.log(Symbol.keyFor(globalSym));\n\n// 创建一个 symbol，但不放入 symbol 注册表中\nvar localSym = Symbol();\n// undefined\nconsole.log(Symbol.keyFor(localSym));\n\n// undefined\nconsole.log(Symbol.keyFor(Symbol.iterator));\n```\n","slug":"前端/ES6/Symbol对象","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2s00172h172aujb0sk","content":"<hr>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>​\tSymbol是es6新增的一个基本的数据类型。增加该类型的主要目的是为了能够实现对象的属性名能够唯一化。</p>\n<pre><code>最新的ECMAScript标准定义了8中数据类型\n7种基本数据类型\n- 布尔值(Boolean):true/false\n- null:一个表示null的特殊关键字\n- undefined,和null一样特殊的关键字，undefined表示变量未定义时的属性\n- 数字(Number)，整数或者浮点数\n- 任意精度的整数(BigInt),可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。\n- 字符串(String),字符串是一串表示文本值的字符序列，例如&quot;helloworld&quot;\n- 代表(Symbol,在Es6新添加的基本数据类型)，一种实例是唯一且不可改变的数据类型\n以及对象(Object)\n</code></pre>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t来自<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types\">MDM</a></p>\n<p>也正式因为Symbol对象的存在，在es6种m对象的属性名现在可以分为两种</p>\n<ol>\n<li>字符串</li>\n<li>Symbol实例</li>\n</ol>\n<p>而接下来就是演示Symbol的基本使用（以代码为主）</p>\n<pre><code class=\"js\">// 注意,Symbol不能与关键字new使用\nlet s = Symbol(&quot;对于该属性的一些文字描述，用英文&quot;);\n// 定义对象\nvar o = &#123;\n    a:1,\n    // 在为一个对象添加Symbol属性时，要用[]包裹Symbol实例对象\n    [s]:&quot;hello world&quot;\n&#125;\n// 输出结果\nconsole.log(o);\n</code></pre>\n<p>但是Symbol属性名是无法被for…in等方法调用，所有我们需要知道如何去获取对象的Symbol属性。下面有一些方法可以获取一个对象的Symbol属性</p>\n<pre><code class=\"js\">1. Object.getOwnPropertySymbols(obj) // 获取obj对象上的所有Symbol属性\n2. Reflect.ownKeys(obj) // 获取obj对象上的所有属性，包括Symbol \n</code></pre>\n<h2 id=\"高级使用-该部分来自阮一峰老师的es6\"><a href=\"#高级使用-该部分来自阮一峰老师的es6\" class=\"headerlink\" title=\"高级使用(该部分来自阮一峰老师的es6)\"></a>高级使用(该部分来自阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/symbol\">es6</a>)</h2><h4 id=\"1-魔术字符串的消除\"><a href=\"#1-魔术字符串的消除\" class=\"headerlink\" title=\"1. 魔术字符串的消除\"></a>1. 魔术字符串的消除</h4><p>​\t魔术字符串：是指在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数组</p>\n<p>​\t而为了后期修改那些常值的方便，我们应该使用变量来代替代码中经常出现的常值。这样，如果以后要修改这些常常值，我们只需要修改变量的值就能达到修改那些常值的效果</p>\n<p>​\t而因为Symbol实例的唯一性，它就非常适合充当魔术字符串的变量</p>\n<pre><code class=\"js\">const shapeType = &#123;\n  triangle: Symbol()\n&#125;;\n\nfunction getArea(shape, options) &#123;\n  let area = 0;\n  switch (shape) &#123;\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  &#125;\n  return area;\n&#125;\n\ngetArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);\n</code></pre>\n<h4 id=\"2-模块的Singleton模式\"><a href=\"#2-模块的Singleton模式\" class=\"headerlink\" title=\"2. 模块的Singleton模式\"></a>2. 模块的Singleton模式</h4><p>​\tSingleton模式指的是调用一个类，在任何时候返回的都是一个实例</p>\n<p>​\t个人理解就是在引入调用一个类时，应该返回的都是同一个实例，而不是再基于该类重新创建新的对象。</p>\n<p>​\t那么如何使用Symbol来实现Singleton</p>\n<p>​\t具体内容：<a href=\"http://es6.ruanyifeng.com/#docs/symbol\">http://es6.ruanyifeng.com/#docs/symbol</a></p>\n<h2 id=\"Symbol常用属性的使用\"><a href=\"#Symbol常用属性的使用\" class=\"headerlink\" title=\"Symbol常用属性的使用\"></a>Symbol常用属性的使用</h2><p>​\t\tSymbol原型上有一些属性，可以方便我们使用。在这里，我提几个我个人认为非常实用的一些属性</p>\n<h4 id=\"1-Symbol-iterator-Object\"><a href=\"#1-Symbol-iterator-Object\" class=\"headerlink\" title=\"1. Symbol.iterator(Object)\"></a>1. Symbol.iterator(Object)</h4><pre><code>该属性为每一个对象定义一个默认的迭代器。该迭代器可以被for...of循环使用。\n我们可以使用该属性为该对象设置默认的迭代器\n</code></pre>\n<pre><code class=\"js\">var o = &#123;\n    // 定义对象o的默认迭代器\n    // 其属性值是一个Generator函数\n    [Symbol.iterator]: function* () &#123;\n        yield 1;\n        yield 2;\n        yield 3;\n    &#125;\n&#125;;\n// [1,2,3]\nconsole.log([...o]);\n</code></pre>\n<h4 id=\"2-Symbol-toPrimitive（Object）\"><a href=\"#2-Symbol-toPrimitive（Object）\" class=\"headerlink\" title=\"2. Symbol.toPrimitive（Object）\"></a>2. Symbol.toPrimitive（Object）</h4><pre><code>该属性是一个内置的Symbol值，它是作为对象的函数值属性存在的，当对象转换为对应的原始值时，会调用此函数\n控制该对象被强制转换成其他数据类型时的处理方法\n</code></pre>\n<pre><code class=\"js\">var o = &#123;\n    // hint为当将该对象强制转换时所要被强制转换的类型，string\n    [Symbol.toPrimitive]:function(hint)&#123;\n        // 可自行输出看看hint的内容\n        // console.log(hint);\n        \n        // 如果是number类型\n        if(hint==&quot;number&quot;)&#123;\n            return 42;\n        &#125;\n        // 如果是string类型\n        if(hint==&quot;string&quot;)&#123;\n            return &quot;hello world&quot;;\n        &#125;\n        // 其他类型\n        return true;\n    &#125;\n&#125;;\n// Number&#123;42&#125;\nconsole.log(new Number(o));\n// String&#123;&quot;hello world&quot;&#125;\nconsole.log(new String(o));\n// Boolean&#123;true&#125;\nconsole.log(new Boolean(o));\n</code></pre>\n<h4 id=\"3-Symbol-toStringTag-Class\"><a href=\"#3-Symbol-toStringTag-Class\" class=\"headerlink\" title=\"3.Symbol.toStringTag(Class)\"></a>3.Symbol.toStringTag(Class)</h4><p>该属性是一个内置属性，它通常作为对象的属性键使用，对应的属性名应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，只有内置的Object.prototype.toString()方法会去读取这个标签并把它包含在自己的返回值里</p>\n<pre><code class=\"js\">class A&#123;\n    // Symbol.toStringTag是定义在对象的类上\n    // 我们可以通过该属性可以自定义类添加一个自己定义的标签\n    get [Symbol.toStringTag]()&#123;\n        return &quot;This is A class&quot;\n    &#125;\n&#125;\n// [object This is A class]\nconsole.log(Object.prototype.toString.call(new A()));\n</code></pre>\n<h4 id=\"4-Symbol-spcies\"><a href=\"#4-Symbol-spcies\" class=\"headerlink\" title=\"4. Symbol.spcies\"></a>4. <strong>Symbol.spcies</strong></h4><p>该属性是一个函数值属性，其被构造函数用于创建派生对象<br>该属性可以允许子类覆盖对象的默认构造函数</p>\n<pre><code class=\"js\">// 来自https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species\nclass MyArray extends Array &#123;\n    // 覆盖 species 到父级的 Array 构造函数上\n    static get [Symbol.species]() &#123;\n        return Array;\n    &#125;\n&#125;\n\nvar a = new MyArray(1,2,3);\nvar mapped = a.map(x=&gt;x*x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);  // true\n</code></pre>\n<h2 id=\"Symbol常用方法的使用\"><a href=\"#Symbol常用方法的使用\" class=\"headerlink\" title=\"Symbol常用方法的使用\"></a>Symbol常用方法的使用</h2><h4 id=\"1-Symbol-for\"><a href=\"#1-Symbol-for\" class=\"headerlink\" title=\"1. Symbol.for()\"></a>1. <strong>Symbol.for()</strong></h4><p>该方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。</p>\n<pre><code class=\"js\">// 创建一个 symbol 并放入 symbol 注册表中，键为 &quot;demo.A&quot;\nSymbol.for(&quot;demo.A&quot;);\n// 从 symbol 注册表中读取键为&quot;demo.A&quot;的 symbol\nSymbol.for(&quot;demo.A&quot;); \n\n\n// true，证明了上面说的\nSymbol.for(&quot;demo.B&quot;) === Symbol.for(&quot;demo.B&quot;); \n// false，Symbol() 函数每次都会返回新的一个 symbol\nSymbol(&quot;demo.B&quot;) === Symbol(&quot;demo.B&quot;);\n</code></pre>\n<h4 id=\"2-Symbol-keyFor\"><a href=\"#2-Symbol-keyFor\" class=\"headerlink\" title=\"2. Symbol.keyFor()\"></a>2. <strong>Symbol.keyFor()</strong></h4><p>该方法用来获取 symbol 注册表中与某个 symbol 关联的键。</p>\n<pre><code class=\"js\">// 创建一个 symbol 并放入 Symbol 注册表，key 为 &quot;demo.A&quot;\nvar globalSym = Symbol.for(&quot;demo.A&quot;);\n// demo.A\nconsole.log(Symbol.keyFor(globalSym));\n\n// 创建一个 symbol，但不放入 symbol 注册表中\nvar localSym = Symbol();\n// undefined\nconsole.log(Symbol.keyFor(localSym));\n\n// undefined\nconsole.log(Symbol.keyFor(Symbol.iterator));\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>​\tSymbol是es6新增的一个基本的数据类型。增加该类型的主要目的是为了能够实现对象的属性名能够唯一化。</p>\n<pre><code>最新的ECMAScript标准定义了8中数据类型\n7种基本数据类型\n- 布尔值(Boolean):true/false\n- null:一个表示null的特殊关键字\n- undefined,和null一样特殊的关键字，undefined表示变量未定义时的属性\n- 数字(Number)，整数或者浮点数\n- 任意精度的整数(BigInt),可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。\n- 字符串(String),字符串是一串表示文本值的字符序列，例如&quot;helloworld&quot;\n- 代表(Symbol,在Es6新添加的基本数据类型)，一种实例是唯一且不可改变的数据类型\n以及对象(Object)\n</code></pre>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t来自<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types\">MDM</a></p>\n<p>也正式因为Symbol对象的存在，在es6种m对象的属性名现在可以分为两种</p>\n<ol>\n<li>字符串</li>\n<li>Symbol实例</li>\n</ol>\n<p>而接下来就是演示Symbol的基本使用（以代码为主）</p>\n<pre><code class=\"js\">// 注意,Symbol不能与关键字new使用\nlet s = Symbol(&quot;对于该属性的一些文字描述，用英文&quot;);\n// 定义对象\nvar o = &#123;\n    a:1,\n    // 在为一个对象添加Symbol属性时，要用[]包裹Symbol实例对象\n    [s]:&quot;hello world&quot;\n&#125;\n// 输出结果\nconsole.log(o);\n</code></pre>\n<p>但是Symbol属性名是无法被for…in等方法调用，所有我们需要知道如何去获取对象的Symbol属性。下面有一些方法可以获取一个对象的Symbol属性</p>\n<pre><code class=\"js\">1. Object.getOwnPropertySymbols(obj) // 获取obj对象上的所有Symbol属性\n2. Reflect.ownKeys(obj) // 获取obj对象上的所有属性，包括Symbol \n</code></pre>\n<h2 id=\"高级使用-该部分来自阮一峰老师的es6\"><a href=\"#高级使用-该部分来自阮一峰老师的es6\" class=\"headerlink\" title=\"高级使用(该部分来自阮一峰老师的es6)\"></a>高级使用(该部分来自阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/symbol\">es6</a>)</h2><h4 id=\"1-魔术字符串的消除\"><a href=\"#1-魔术字符串的消除\" class=\"headerlink\" title=\"1. 魔术字符串的消除\"></a>1. 魔术字符串的消除</h4><p>​\t魔术字符串：是指在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数组</p>\n<p>​\t而为了后期修改那些常值的方便，我们应该使用变量来代替代码中经常出现的常值。这样，如果以后要修改这些常常值，我们只需要修改变量的值就能达到修改那些常值的效果</p>\n<p>​\t而因为Symbol实例的唯一性，它就非常适合充当魔术字符串的变量</p>\n<pre><code class=\"js\">const shapeType = &#123;\n  triangle: Symbol()\n&#125;;\n\nfunction getArea(shape, options) &#123;\n  let area = 0;\n  switch (shape) &#123;\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  &#125;\n  return area;\n&#125;\n\ngetArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);\n</code></pre>\n<h4 id=\"2-模块的Singleton模式\"><a href=\"#2-模块的Singleton模式\" class=\"headerlink\" title=\"2. 模块的Singleton模式\"></a>2. 模块的Singleton模式</h4><p>​\tSingleton模式指的是调用一个类，在任何时候返回的都是一个实例</p>\n<p>​\t个人理解就是在引入调用一个类时，应该返回的都是同一个实例，而不是再基于该类重新创建新的对象。</p>\n<p>​\t那么如何使用Symbol来实现Singleton</p>\n<p>​\t具体内容：<a href=\"http://es6.ruanyifeng.com/#docs/symbol\">http://es6.ruanyifeng.com/#docs/symbol</a></p>\n<h2 id=\"Symbol常用属性的使用\"><a href=\"#Symbol常用属性的使用\" class=\"headerlink\" title=\"Symbol常用属性的使用\"></a>Symbol常用属性的使用</h2><p>​\t\tSymbol原型上有一些属性，可以方便我们使用。在这里，我提几个我个人认为非常实用的一些属性</p>\n<h4 id=\"1-Symbol-iterator-Object\"><a href=\"#1-Symbol-iterator-Object\" class=\"headerlink\" title=\"1. Symbol.iterator(Object)\"></a>1. Symbol.iterator(Object)</h4><pre><code>该属性为每一个对象定义一个默认的迭代器。该迭代器可以被for...of循环使用。\n我们可以使用该属性为该对象设置默认的迭代器\n</code></pre>\n<pre><code class=\"js\">var o = &#123;\n    // 定义对象o的默认迭代器\n    // 其属性值是一个Generator函数\n    [Symbol.iterator]: function* () &#123;\n        yield 1;\n        yield 2;\n        yield 3;\n    &#125;\n&#125;;\n// [1,2,3]\nconsole.log([...o]);\n</code></pre>\n<h4 id=\"2-Symbol-toPrimitive（Object）\"><a href=\"#2-Symbol-toPrimitive（Object）\" class=\"headerlink\" title=\"2. Symbol.toPrimitive（Object）\"></a>2. Symbol.toPrimitive（Object）</h4><pre><code>该属性是一个内置的Symbol值，它是作为对象的函数值属性存在的，当对象转换为对应的原始值时，会调用此函数\n控制该对象被强制转换成其他数据类型时的处理方法\n</code></pre>\n<pre><code class=\"js\">var o = &#123;\n    // hint为当将该对象强制转换时所要被强制转换的类型，string\n    [Symbol.toPrimitive]:function(hint)&#123;\n        // 可自行输出看看hint的内容\n        // console.log(hint);\n        \n        // 如果是number类型\n        if(hint==&quot;number&quot;)&#123;\n            return 42;\n        &#125;\n        // 如果是string类型\n        if(hint==&quot;string&quot;)&#123;\n            return &quot;hello world&quot;;\n        &#125;\n        // 其他类型\n        return true;\n    &#125;\n&#125;;\n// Number&#123;42&#125;\nconsole.log(new Number(o));\n// String&#123;&quot;hello world&quot;&#125;\nconsole.log(new String(o));\n// Boolean&#123;true&#125;\nconsole.log(new Boolean(o));\n</code></pre>\n<h4 id=\"3-Symbol-toStringTag-Class\"><a href=\"#3-Symbol-toStringTag-Class\" class=\"headerlink\" title=\"3.Symbol.toStringTag(Class)\"></a>3.Symbol.toStringTag(Class)</h4><p>该属性是一个内置属性，它通常作为对象的属性键使用，对应的属性名应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，只有内置的Object.prototype.toString()方法会去读取这个标签并把它包含在自己的返回值里</p>\n<pre><code class=\"js\">class A&#123;\n    // Symbol.toStringTag是定义在对象的类上\n    // 我们可以通过该属性可以自定义类添加一个自己定义的标签\n    get [Symbol.toStringTag]()&#123;\n        return &quot;This is A class&quot;\n    &#125;\n&#125;\n// [object This is A class]\nconsole.log(Object.prototype.toString.call(new A()));\n</code></pre>\n<h4 id=\"4-Symbol-spcies\"><a href=\"#4-Symbol-spcies\" class=\"headerlink\" title=\"4. Symbol.spcies\"></a>4. <strong>Symbol.spcies</strong></h4><p>该属性是一个函数值属性，其被构造函数用于创建派生对象<br>该属性可以允许子类覆盖对象的默认构造函数</p>\n<pre><code class=\"js\">// 来自https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species\nclass MyArray extends Array &#123;\n    // 覆盖 species 到父级的 Array 构造函数上\n    static get [Symbol.species]() &#123;\n        return Array;\n    &#125;\n&#125;\n\nvar a = new MyArray(1,2,3);\nvar mapped = a.map(x=&gt;x*x);\n\nconsole.log(mapped instanceof MyArray); // false\nconsole.log(mapped instanceof Array);  // true\n</code></pre>\n<h2 id=\"Symbol常用方法的使用\"><a href=\"#Symbol常用方法的使用\" class=\"headerlink\" title=\"Symbol常用方法的使用\"></a>Symbol常用方法的使用</h2><h4 id=\"1-Symbol-for\"><a href=\"#1-Symbol-for\" class=\"headerlink\" title=\"1. Symbol.for()\"></a>1. <strong>Symbol.for()</strong></h4><p>该方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。</p>\n<pre><code class=\"js\">// 创建一个 symbol 并放入 symbol 注册表中，键为 &quot;demo.A&quot;\nSymbol.for(&quot;demo.A&quot;);\n// 从 symbol 注册表中读取键为&quot;demo.A&quot;的 symbol\nSymbol.for(&quot;demo.A&quot;); \n\n\n// true，证明了上面说的\nSymbol.for(&quot;demo.B&quot;) === Symbol.for(&quot;demo.B&quot;); \n// false，Symbol() 函数每次都会返回新的一个 symbol\nSymbol(&quot;demo.B&quot;) === Symbol(&quot;demo.B&quot;);\n</code></pre>\n<h4 id=\"2-Symbol-keyFor\"><a href=\"#2-Symbol-keyFor\" class=\"headerlink\" title=\"2. Symbol.keyFor()\"></a>2. <strong>Symbol.keyFor()</strong></h4><p>该方法用来获取 symbol 注册表中与某个 symbol 关联的键。</p>\n<pre><code class=\"js\">// 创建一个 symbol 并放入 Symbol 注册表，key 为 &quot;demo.A&quot;\nvar globalSym = Symbol.for(&quot;demo.A&quot;);\n// demo.A\nconsole.log(Symbol.keyFor(globalSym));\n\n// 创建一个 symbol，但不放入 symbol 注册表中\nvar localSym = Symbol();\n// undefined\nconsole.log(Symbol.keyFor(localSym));\n\n// undefined\nconsole.log(Symbol.keyFor(Symbol.iterator));\n</code></pre>\n"},{"title":"自定义深拷贝","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES6","date":"2020-07-22T16:00:00.000Z","comments":0,"description":"自定义深拷贝","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/自定义深拷贝.png"],"_content":"\n\n## 代码实现\n```js\n/**\n * 获取value的数据类型\n * @param {Any} value 值\n */\nfunction toRawType(value) {\n    const _toString = Object.prototype.toString;\n    const str = _toString.call(value);\n    return str.slice(8, -1);\n}\n\n\n/**\n * 克隆非迭代对象\n * 这样写就可以如果要添加一个克隆Promise的对象,就可以直接在这里处理\n * @param {Boolean|Number|String|Error|Date|RegExp|Symbol|Function} target 被克隆对象\n * @param {String} type 被克隆对象类型\n */\nfunction cloneOtherType(target, type) {\n\n    // 获取被克隆对象的构造函数\n    const constrFun = target.constructor;\n\n    /**\n     * 克隆正则对象\n     * @param {RegExp} target 被克隆对象\n     */\n    function cloneReg(target) {\n        const reFlag = /\\w*$/;\n        const result = target.constructor(target.source, reFlag.exec(target));\n        result.lastIndex = target.lastIndex;\n        return result;\n    }\n\n    /**\n     * 克隆Symbol对象\n     * @param {Symbol} target 被克隆对象\n     */\n    function cloneSymbol(target) {\n        return Object(Symbol.prototype.valueOf.call(target));\n    }\n\n    switch (type) {\n        case \"Boolean\":\n        case \"Number\":\n        case \"String\":\n        case \"Error\":\n        case \"Date\":\n            return new constrFun(target);\n        case \"RegExp\":\n            return cloneReg(target);\n        case \"Symbol\":\n            return cloneSymbol(target);\n        case \"Function\":\n            return target;\n        default:\n            return null;\n    }\n\n\n}\n\n\n/**\n * \n * @param {Array} array 数组\n * @param {Function} cb 回调函数\n */\nfunction forEach(array, cb) {\n    let index = -1;\n    let length = array.length;\n    while (++index < length) {\n        cb(array[index], index);\n    }\n    return array;\n}\n\n\n/**\n * core clone\n * @param {Any} target 被克隆对象\n * @param {WeakMap} map 当前克隆对象与克隆出来对象之间的关系表，记录这关系可以在一定程度上加快克隆速度\n */\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆基本数据类型\n    if (typeof target !== \"object\" || target === null) {\n        return target;\n    }\n\n    // 获取当前target的数据类型\n    const type = toRawType(target);\n    let cloneTarget = null;\n\n    // 如果可以在克隆记录表中找到此时被克隆对象所对应的记录，则直接返回\n    if (map.get(target)) {\n        return map.get(target);\n    }\n\n    // 添加此时被克隆对象与生成克隆对象记录\n    map.set(target, cloneTarget);\n\n    if (type !== \"Set\" && type !== \"Map\" && type !== \"Array\" && type !== \"Object\") {\n        return cloneOtherType(target, type);\n    }\n\n    // clone Set\n    if (type === \"Set\") {\n        cloneTarget = new Set();\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        })\n        return cloneTarget;\n    }\n\n    // clone Map\n    if (type === \"Map\") {\n        cloneTarget = new Map();\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        })\n        return cloneTarget;\n    }\n\n    // clone Array\n    if (type === \"Array\") {\n        cloneTarget = new Array();\n        forEach(target, (value, index) => {\n            cloneTarget[index] = clone(value, map);\n        })\n        return cloneTarget;\n    }\n\n    // clone Object\n    if (type === \"Object\") {\n        cloneTarget = new Object();\n        forEach(Object.keys(target), key => {\n            cloneTarget[key] = clone(target[key], map);\n        })\n        return cloneTarget;\n    }\n\n}\n```","source":"_posts/前端/ES6/自定义深拷贝.md","raw":"---\ntitle: 自定义深拷贝\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - ES6\nkeywords: ES6\ndate: 2020-07-23\ncomments: false\ndescription: 自定义深拷贝\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/自定义深拷贝.png\n---\n\n\n## 代码实现\n```js\n/**\n * 获取value的数据类型\n * @param {Any} value 值\n */\nfunction toRawType(value) {\n    const _toString = Object.prototype.toString;\n    const str = _toString.call(value);\n    return str.slice(8, -1);\n}\n\n\n/**\n * 克隆非迭代对象\n * 这样写就可以如果要添加一个克隆Promise的对象,就可以直接在这里处理\n * @param {Boolean|Number|String|Error|Date|RegExp|Symbol|Function} target 被克隆对象\n * @param {String} type 被克隆对象类型\n */\nfunction cloneOtherType(target, type) {\n\n    // 获取被克隆对象的构造函数\n    const constrFun = target.constructor;\n\n    /**\n     * 克隆正则对象\n     * @param {RegExp} target 被克隆对象\n     */\n    function cloneReg(target) {\n        const reFlag = /\\w*$/;\n        const result = target.constructor(target.source, reFlag.exec(target));\n        result.lastIndex = target.lastIndex;\n        return result;\n    }\n\n    /**\n     * 克隆Symbol对象\n     * @param {Symbol} target 被克隆对象\n     */\n    function cloneSymbol(target) {\n        return Object(Symbol.prototype.valueOf.call(target));\n    }\n\n    switch (type) {\n        case \"Boolean\":\n        case \"Number\":\n        case \"String\":\n        case \"Error\":\n        case \"Date\":\n            return new constrFun(target);\n        case \"RegExp\":\n            return cloneReg(target);\n        case \"Symbol\":\n            return cloneSymbol(target);\n        case \"Function\":\n            return target;\n        default:\n            return null;\n    }\n\n\n}\n\n\n/**\n * \n * @param {Array} array 数组\n * @param {Function} cb 回调函数\n */\nfunction forEach(array, cb) {\n    let index = -1;\n    let length = array.length;\n    while (++index < length) {\n        cb(array[index], index);\n    }\n    return array;\n}\n\n\n/**\n * core clone\n * @param {Any} target 被克隆对象\n * @param {WeakMap} map 当前克隆对象与克隆出来对象之间的关系表，记录这关系可以在一定程度上加快克隆速度\n */\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆基本数据类型\n    if (typeof target !== \"object\" || target === null) {\n        return target;\n    }\n\n    // 获取当前target的数据类型\n    const type = toRawType(target);\n    let cloneTarget = null;\n\n    // 如果可以在克隆记录表中找到此时被克隆对象所对应的记录，则直接返回\n    if (map.get(target)) {\n        return map.get(target);\n    }\n\n    // 添加此时被克隆对象与生成克隆对象记录\n    map.set(target, cloneTarget);\n\n    if (type !== \"Set\" && type !== \"Map\" && type !== \"Array\" && type !== \"Object\") {\n        return cloneOtherType(target, type);\n    }\n\n    // clone Set\n    if (type === \"Set\") {\n        cloneTarget = new Set();\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        })\n        return cloneTarget;\n    }\n\n    // clone Map\n    if (type === \"Map\") {\n        cloneTarget = new Map();\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        })\n        return cloneTarget;\n    }\n\n    // clone Array\n    if (type === \"Array\") {\n        cloneTarget = new Array();\n        forEach(target, (value, index) => {\n            cloneTarget[index] = clone(value, map);\n        })\n        return cloneTarget;\n    }\n\n    // clone Object\n    if (type === \"Object\") {\n        cloneTarget = new Object();\n        forEach(Object.keys(target), key => {\n            cloneTarget[key] = clone(target[key], map);\n        })\n        return cloneTarget;\n    }\n\n}\n```","slug":"前端/ES6/自定义深拷贝","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2t001b2h17fus4f84o","content":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"js\">/**\n * 获取value的数据类型\n * @param &#123;Any&#125; value 值\n */\nfunction toRawType(value) &#123;\n    const _toString = Object.prototype.toString;\n    const str = _toString.call(value);\n    return str.slice(8, -1);\n&#125;\n\n\n/**\n * 克隆非迭代对象\n * 这样写就可以如果要添加一个克隆Promise的对象,就可以直接在这里处理\n * @param &#123;Boolean|Number|String|Error|Date|RegExp|Symbol|Function&#125; target 被克隆对象\n * @param &#123;String&#125; type 被克隆对象类型\n */\nfunction cloneOtherType(target, type) &#123;\n\n    // 获取被克隆对象的构造函数\n    const constrFun = target.constructor;\n\n    /**\n     * 克隆正则对象\n     * @param &#123;RegExp&#125; target 被克隆对象\n     */\n    function cloneReg(target) &#123;\n        const reFlag = /\\w*$/;\n        const result = target.constructor(target.source, reFlag.exec(target));\n        result.lastIndex = target.lastIndex;\n        return result;\n    &#125;\n\n    /**\n     * 克隆Symbol对象\n     * @param &#123;Symbol&#125; target 被克隆对象\n     */\n    function cloneSymbol(target) &#123;\n        return Object(Symbol.prototype.valueOf.call(target));\n    &#125;\n\n    switch (type) &#123;\n        case &quot;Boolean&quot;:\n        case &quot;Number&quot;:\n        case &quot;String&quot;:\n        case &quot;Error&quot;:\n        case &quot;Date&quot;:\n            return new constrFun(target);\n        case &quot;RegExp&quot;:\n            return cloneReg(target);\n        case &quot;Symbol&quot;:\n            return cloneSymbol(target);\n        case &quot;Function&quot;:\n            return target;\n        default:\n            return null;\n    &#125;\n\n\n&#125;\n\n\n/**\n * \n * @param &#123;Array&#125; array 数组\n * @param &#123;Function&#125; cb 回调函数\n */\nfunction forEach(array, cb) &#123;\n    let index = -1;\n    let length = array.length;\n    while (++index &lt; length) &#123;\n        cb(array[index], index);\n    &#125;\n    return array;\n&#125;\n\n\n/**\n * core clone\n * @param &#123;Any&#125; target 被克隆对象\n * @param &#123;WeakMap&#125; map 当前克隆对象与克隆出来对象之间的关系表，记录这关系可以在一定程度上加快克隆速度\n */\nfunction clone(target, map = new WeakMap()) &#123;\n\n    // 克隆基本数据类型\n    if (typeof target !== &quot;object&quot; || target === null) &#123;\n        return target;\n    &#125;\n\n    // 获取当前target的数据类型\n    const type = toRawType(target);\n    let cloneTarget = null;\n\n    // 如果可以在克隆记录表中找到此时被克隆对象所对应的记录，则直接返回\n    if (map.get(target)) &#123;\n        return map.get(target);\n    &#125;\n\n    // 添加此时被克隆对象与生成克隆对象记录\n    map.set(target, cloneTarget);\n\n    if (type !== &quot;Set&quot; &amp;&amp; type !== &quot;Map&quot; &amp;&amp; type !== &quot;Array&quot; &amp;&amp; type !== &quot;Object&quot;) &#123;\n        return cloneOtherType(target, type);\n    &#125;\n\n    // clone Set\n    if (type === &quot;Set&quot;) &#123;\n        cloneTarget = new Set();\n        target.forEach(value =&gt; &#123;\n            cloneTarget.add(clone(value, map));\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Map\n    if (type === &quot;Map&quot;) &#123;\n        cloneTarget = new Map();\n        target.forEach((value, key) =&gt; &#123;\n            cloneTarget.set(key, clone(value, map));\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Array\n    if (type === &quot;Array&quot;) &#123;\n        cloneTarget = new Array();\n        forEach(target, (value, index) =&gt; &#123;\n            cloneTarget[index] = clone(value, map);\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Object\n    if (type === &quot;Object&quot;) &#123;\n        cloneTarget = new Object();\n        forEach(Object.keys(target), key =&gt; &#123;\n            cloneTarget[key] = clone(target[key], map);\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"js\">/**\n * 获取value的数据类型\n * @param &#123;Any&#125; value 值\n */\nfunction toRawType(value) &#123;\n    const _toString = Object.prototype.toString;\n    const str = _toString.call(value);\n    return str.slice(8, -1);\n&#125;\n\n\n/**\n * 克隆非迭代对象\n * 这样写就可以如果要添加一个克隆Promise的对象,就可以直接在这里处理\n * @param &#123;Boolean|Number|String|Error|Date|RegExp|Symbol|Function&#125; target 被克隆对象\n * @param &#123;String&#125; type 被克隆对象类型\n */\nfunction cloneOtherType(target, type) &#123;\n\n    // 获取被克隆对象的构造函数\n    const constrFun = target.constructor;\n\n    /**\n     * 克隆正则对象\n     * @param &#123;RegExp&#125; target 被克隆对象\n     */\n    function cloneReg(target) &#123;\n        const reFlag = /\\w*$/;\n        const result = target.constructor(target.source, reFlag.exec(target));\n        result.lastIndex = target.lastIndex;\n        return result;\n    &#125;\n\n    /**\n     * 克隆Symbol对象\n     * @param &#123;Symbol&#125; target 被克隆对象\n     */\n    function cloneSymbol(target) &#123;\n        return Object(Symbol.prototype.valueOf.call(target));\n    &#125;\n\n    switch (type) &#123;\n        case &quot;Boolean&quot;:\n        case &quot;Number&quot;:\n        case &quot;String&quot;:\n        case &quot;Error&quot;:\n        case &quot;Date&quot;:\n            return new constrFun(target);\n        case &quot;RegExp&quot;:\n            return cloneReg(target);\n        case &quot;Symbol&quot;:\n            return cloneSymbol(target);\n        case &quot;Function&quot;:\n            return target;\n        default:\n            return null;\n    &#125;\n\n\n&#125;\n\n\n/**\n * \n * @param &#123;Array&#125; array 数组\n * @param &#123;Function&#125; cb 回调函数\n */\nfunction forEach(array, cb) &#123;\n    let index = -1;\n    let length = array.length;\n    while (++index &lt; length) &#123;\n        cb(array[index], index);\n    &#125;\n    return array;\n&#125;\n\n\n/**\n * core clone\n * @param &#123;Any&#125; target 被克隆对象\n * @param &#123;WeakMap&#125; map 当前克隆对象与克隆出来对象之间的关系表，记录这关系可以在一定程度上加快克隆速度\n */\nfunction clone(target, map = new WeakMap()) &#123;\n\n    // 克隆基本数据类型\n    if (typeof target !== &quot;object&quot; || target === null) &#123;\n        return target;\n    &#125;\n\n    // 获取当前target的数据类型\n    const type = toRawType(target);\n    let cloneTarget = null;\n\n    // 如果可以在克隆记录表中找到此时被克隆对象所对应的记录，则直接返回\n    if (map.get(target)) &#123;\n        return map.get(target);\n    &#125;\n\n    // 添加此时被克隆对象与生成克隆对象记录\n    map.set(target, cloneTarget);\n\n    if (type !== &quot;Set&quot; &amp;&amp; type !== &quot;Map&quot; &amp;&amp; type !== &quot;Array&quot; &amp;&amp; type !== &quot;Object&quot;) &#123;\n        return cloneOtherType(target, type);\n    &#125;\n\n    // clone Set\n    if (type === &quot;Set&quot;) &#123;\n        cloneTarget = new Set();\n        target.forEach(value =&gt; &#123;\n            cloneTarget.add(clone(value, map));\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Map\n    if (type === &quot;Map&quot;) &#123;\n        cloneTarget = new Map();\n        target.forEach((value, key) =&gt; &#123;\n            cloneTarget.set(key, clone(value, map));\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Array\n    if (type === &quot;Array&quot;) &#123;\n        cloneTarget = new Array();\n        forEach(target, (value, index) =&gt; &#123;\n            cloneTarget[index] = clone(value, map);\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n    // clone Object\n    if (type === &quot;Object&quot;) &#123;\n        cloneTarget = new Object();\n        forEach(Object.keys(target), key =&gt; &#123;\n            cloneTarget[key] = clone(target[key], map);\n        &#125;)\n        return cloneTarget;\n    &#125;\n\n&#125;\n</code></pre>\n"},{"title":"Reflect对象","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES6","date":"2019-11-29T16:00:00.000Z","comments":0,"description":"Reflect对象","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/Reflect_bg.jpg"],"_content":"## 基本认识\n\n​\t**Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与[proxy handlers](https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)的方法相同。`Reflect`不是一个函数对象，因此它是不可构造的。\n\n​\t与大多数全局对象不同，`Reflect`不是一个构造函数。你不能将其与一个[new运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)一起使用，或者将`Reflect`对象作为一个函数来调用。`Reflect`的所有属性和方法都是静态的（就像[`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)对象）。\n\n​\t**Reflect**对象的出现，并不是增强了代码的功能，而是在我们编写代码的时候更具有**函数式编程**的风格。平常我们的对对象的操作，例如对象属性的读取和修改，函数的调用，都可以通过使用Reflect中的相关方法来达到同样的效果。我们的所有操作，通过使用Reflect对象，都可以通过**函数调用**来完成。\n\n## 基本用法\n\nReflect的方法很多，在这里就说一个我个人感觉比较常用的方法\n\n#### 1. Reflect.get(target,propertyKey,_receiver)\n\n该静态方法是返回被操作对象所对应属性名的属性值\n\n**参数解释**\n\n1. target：需要取值的目标对象\n2. propertyKey：需要获取的值的键值\n3. receiver(可省略)：如果`target`对象中指定了`getter`，`receiver`则为`getter`调用时的`this`值\n\n**返回值**\n\n被操作对象属性名所对应的值\n\n```js\n// 定义测试对象 obj\nvar obj = { a: 1, }\n// 1\nconsole.log(Reflect.get(obj, \"a\"));\n```\n\n#### 2. Reflect.set(target,propertyKey,value,_received)\n\n该静态方法是在被操作对象设置属性\n\n**参数解释**\n\n1. target：设置属性的目标对象\n2. propertyKey：设置的属性的名称\n3. value：设置的值\n4. receiver(可省略)：如果`target`对象中指定了`setter`，`receiver`则为`setter`调用时的`this`值\n\n**返回值**\n\n返回一个Boolean表明是否在被操作对象成功设置该属性\n\n```js\n// 定义测试对象 obj\nvar obj = { a: 1, }\n// 使用Reflect.set函数\nReflect.set(obj, \"b\", 2);\n// {a: 1, b: 2}\nconsole.log(obj);\n```\n\n#### 3. Relfect.apply(target,thisArguments,argumentsList)\n\n该静态方法是通过指定的参数列发起对目标函数的调用\n\n**参数解释**\n\n1. target：目标函数\n2. thisArgument：target函数调用时绑定的this对象\n3. argumentsList：target函数调用时传入的实参列表，该参数应该是一个类数组的对象\n\n**返回值**\n\n是调用完带着指定参数和this值的给定的函数后执行所返回的结果\n\n```js\n// 创建测试函数\nfunction f() {\n    // 打印当前调用该函数的对象\n    console.log(this);\n    // 循环打印调用该函数时所传入的参数\n    for (let i = 0; i < arguments.length; i++) {\n        console.log(arguments[i]);\n    }\n    // 函数返回值\n    return \"hello f\";\n}\n// 使用Reflect.apply函数\n// 打印f执行中当前this的值：{a: 1, b: 2}\n// 循环打印处f在执行时传入的参数\n// 1\n// 2\n// 3\n// 4\n// 5\n// 最终打印使用Reflect.apply所返回的结果：即执行f时所返回的结果：hello f\nconsole.log(Reflect.apply(f, { a: 1, b: 2 }, [1, 2, 3, 4, 5]));\n```\n\n## 高级用法\n\n#### 与proxy对象一起使用\n\n```js\n// 创建测试样例\nvar o = {\n    a:1\n}\n// 创建Proxy对象 op\nlet op = new Proxy(o,{\n    set:function(target,prop,value,_proxy){\n        // 使用Reflect对象的set方法\n        Reflect.set(target,prop,value);\n    },\n    get:function(target,prop,_proxy){\n        // 使用Reflect对象的get方法\n        return Reflect.get(target,prop);\n    }\n})\n// 修改对象op的a的值，会触发set方法\nop.a = 2;\n// 输出对象op,Proxy {a: 2}\nconsole.log(op);\n// 读取对象op的属性a的值，会触发get方法\n// 2\nconsole.log(op.a);\n```\n\n","source":"_posts/前端/ES6/Reflect对象.md","raw":"---\ntitle: Reflect对象\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - ES6\nkeywords: ES6\ndate: 2019-11-30\ncomments: false\ndescription: Reflect对象\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/Reflect_bg.jpg\n---\n## 基本认识\n\n​\t**Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与[proxy handlers](https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler)的方法相同。`Reflect`不是一个函数对象，因此它是不可构造的。\n\n​\t与大多数全局对象不同，`Reflect`不是一个构造函数。你不能将其与一个[new运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)一起使用，或者将`Reflect`对象作为一个函数来调用。`Reflect`的所有属性和方法都是静态的（就像[`Math`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)对象）。\n\n​\t**Reflect**对象的出现，并不是增强了代码的功能，而是在我们编写代码的时候更具有**函数式编程**的风格。平常我们的对对象的操作，例如对象属性的读取和修改，函数的调用，都可以通过使用Reflect中的相关方法来达到同样的效果。我们的所有操作，通过使用Reflect对象，都可以通过**函数调用**来完成。\n\n## 基本用法\n\nReflect的方法很多，在这里就说一个我个人感觉比较常用的方法\n\n#### 1. Reflect.get(target,propertyKey,_receiver)\n\n该静态方法是返回被操作对象所对应属性名的属性值\n\n**参数解释**\n\n1. target：需要取值的目标对象\n2. propertyKey：需要获取的值的键值\n3. receiver(可省略)：如果`target`对象中指定了`getter`，`receiver`则为`getter`调用时的`this`值\n\n**返回值**\n\n被操作对象属性名所对应的值\n\n```js\n// 定义测试对象 obj\nvar obj = { a: 1, }\n// 1\nconsole.log(Reflect.get(obj, \"a\"));\n```\n\n#### 2. Reflect.set(target,propertyKey,value,_received)\n\n该静态方法是在被操作对象设置属性\n\n**参数解释**\n\n1. target：设置属性的目标对象\n2. propertyKey：设置的属性的名称\n3. value：设置的值\n4. receiver(可省略)：如果`target`对象中指定了`setter`，`receiver`则为`setter`调用时的`this`值\n\n**返回值**\n\n返回一个Boolean表明是否在被操作对象成功设置该属性\n\n```js\n// 定义测试对象 obj\nvar obj = { a: 1, }\n// 使用Reflect.set函数\nReflect.set(obj, \"b\", 2);\n// {a: 1, b: 2}\nconsole.log(obj);\n```\n\n#### 3. Relfect.apply(target,thisArguments,argumentsList)\n\n该静态方法是通过指定的参数列发起对目标函数的调用\n\n**参数解释**\n\n1. target：目标函数\n2. thisArgument：target函数调用时绑定的this对象\n3. argumentsList：target函数调用时传入的实参列表，该参数应该是一个类数组的对象\n\n**返回值**\n\n是调用完带着指定参数和this值的给定的函数后执行所返回的结果\n\n```js\n// 创建测试函数\nfunction f() {\n    // 打印当前调用该函数的对象\n    console.log(this);\n    // 循环打印调用该函数时所传入的参数\n    for (let i = 0; i < arguments.length; i++) {\n        console.log(arguments[i]);\n    }\n    // 函数返回值\n    return \"hello f\";\n}\n// 使用Reflect.apply函数\n// 打印f执行中当前this的值：{a: 1, b: 2}\n// 循环打印处f在执行时传入的参数\n// 1\n// 2\n// 3\n// 4\n// 5\n// 最终打印使用Reflect.apply所返回的结果：即执行f时所返回的结果：hello f\nconsole.log(Reflect.apply(f, { a: 1, b: 2 }, [1, 2, 3, 4, 5]));\n```\n\n## 高级用法\n\n#### 与proxy对象一起使用\n\n```js\n// 创建测试样例\nvar o = {\n    a:1\n}\n// 创建Proxy对象 op\nlet op = new Proxy(o,{\n    set:function(target,prop,value,_proxy){\n        // 使用Reflect对象的set方法\n        Reflect.set(target,prop,value);\n    },\n    get:function(target,prop,_proxy){\n        // 使用Reflect对象的get方法\n        return Reflect.get(target,prop);\n    }\n})\n// 修改对象op的a的值，会触发set方法\nop.a = 2;\n// 输出对象op,Proxy {a: 2}\nconsole.log(op);\n// 读取对象op的属性a的值，会触发get方法\n// 2\nconsole.log(op.a);\n```\n\n","slug":"前端/ES6/Reflect对象","published":1,"updated":"2023-05-12T23:28:10.993Z","layout":"post","link":"","_id":"clhws1t2u001e2h173y3zbalc","content":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p>​\t<strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与<a href=\"https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler\">proxy handlers</a>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>\n<p>​\t与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\">new运算符</a>一起使用，或者将<code>Reflect</code>对象作为一个函数来调用。<code>Reflect</code>的所有属性和方法都是静态的（就像<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math\"><code>Math</code></a>对象）。</p>\n<p>​\t<strong>Reflect</strong>对象的出现，并不是增强了代码的功能，而是在我们编写代码的时候更具有<strong>函数式编程</strong>的风格。平常我们的对对象的操作，例如对象属性的读取和修改，函数的调用，都可以通过使用Reflect中的相关方法来达到同样的效果。我们的所有操作，通过使用Reflect对象，都可以通过<strong>函数调用</strong>来完成。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>Reflect的方法很多，在这里就说一个我个人感觉比较常用的方法</p>\n<h4 id=\"1-Reflect-get-target-propertyKey-receiver\"><a href=\"#1-Reflect-get-target-propertyKey-receiver\" class=\"headerlink\" title=\"1. Reflect.get(target,propertyKey,_receiver)\"></a>1. Reflect.get(target,propertyKey,_receiver)</h4><p>该静态方法是返回被操作对象所对应属性名的属性值</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：需要取值的目标对象</li>\n<li>propertyKey：需要获取的值的键值</li>\n<li>receiver(可省略)：如果<code>target</code>对象中指定了<code>getter</code>，<code>receiver</code>则为<code>getter</code>调用时的<code>this</code>值</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>被操作对象属性名所对应的值</p>\n<pre><code class=\"js\">// 定义测试对象 obj\nvar obj = &#123; a: 1, &#125;\n// 1\nconsole.log(Reflect.get(obj, &quot;a&quot;));\n</code></pre>\n<h4 id=\"2-Reflect-set-target-propertyKey-value-received\"><a href=\"#2-Reflect-set-target-propertyKey-value-received\" class=\"headerlink\" title=\"2. Reflect.set(target,propertyKey,value,_received)\"></a>2. Reflect.set(target,propertyKey,value,_received)</h4><p>该静态方法是在被操作对象设置属性</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：设置属性的目标对象</li>\n<li>propertyKey：设置的属性的名称</li>\n<li>value：设置的值</li>\n<li>receiver(可省略)：如果<code>target</code>对象中指定了<code>setter</code>，<code>receiver</code>则为<code>setter</code>调用时的<code>this</code>值</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>返回一个Boolean表明是否在被操作对象成功设置该属性</p>\n<pre><code class=\"js\">// 定义测试对象 obj\nvar obj = &#123; a: 1, &#125;\n// 使用Reflect.set函数\nReflect.set(obj, &quot;b&quot;, 2);\n// &#123;a: 1, b: 2&#125;\nconsole.log(obj);\n</code></pre>\n<h4 id=\"3-Relfect-apply-target-thisArguments-argumentsList\"><a href=\"#3-Relfect-apply-target-thisArguments-argumentsList\" class=\"headerlink\" title=\"3. Relfect.apply(target,thisArguments,argumentsList)\"></a>3. Relfect.apply(target,thisArguments,argumentsList)</h4><p>该静态方法是通过指定的参数列发起对目标函数的调用</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：目标函数</li>\n<li>thisArgument：target函数调用时绑定的this对象</li>\n<li>argumentsList：target函数调用时传入的实参列表，该参数应该是一个类数组的对象</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>是调用完带着指定参数和this值的给定的函数后执行所返回的结果</p>\n<pre><code class=\"js\">// 创建测试函数\nfunction f() &#123;\n    // 打印当前调用该函数的对象\n    console.log(this);\n    // 循环打印调用该函数时所传入的参数\n    for (let i = 0; i &lt; arguments.length; i++) &#123;\n        console.log(arguments[i]);\n    &#125;\n    // 函数返回值\n    return &quot;hello f&quot;;\n&#125;\n// 使用Reflect.apply函数\n// 打印f执行中当前this的值：&#123;a: 1, b: 2&#125;\n// 循环打印处f在执行时传入的参数\n// 1\n// 2\n// 3\n// 4\n// 5\n// 最终打印使用Reflect.apply所返回的结果：即执行f时所返回的结果：hello f\nconsole.log(Reflect.apply(f, &#123; a: 1, b: 2 &#125;, [1, 2, 3, 4, 5]));\n</code></pre>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h4 id=\"与proxy对象一起使用\"><a href=\"#与proxy对象一起使用\" class=\"headerlink\" title=\"与proxy对象一起使用\"></a>与proxy对象一起使用</h4><pre><code class=\"js\">// 创建测试样例\nvar o = &#123;\n    a:1\n&#125;\n// 创建Proxy对象 op\nlet op = new Proxy(o,&#123;\n    set:function(target,prop,value,_proxy)&#123;\n        // 使用Reflect对象的set方法\n        Reflect.set(target,prop,value);\n    &#125;,\n    get:function(target,prop,_proxy)&#123;\n        // 使用Reflect对象的get方法\n        return Reflect.get(target,prop);\n    &#125;\n&#125;)\n// 修改对象op的a的值，会触发set方法\nop.a = 2;\n// 输出对象op,Proxy &#123;a: 2&#125;\nconsole.log(op);\n// 读取对象op的属性a的值，会触发get方法\n// 2\nconsole.log(op.a);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p>​\t<strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与<a href=\"https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler\">proxy handlers</a>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>\n<p>​\t与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\">new运算符</a>一起使用，或者将<code>Reflect</code>对象作为一个函数来调用。<code>Reflect</code>的所有属性和方法都是静态的（就像<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math\"><code>Math</code></a>对象）。</p>\n<p>​\t<strong>Reflect</strong>对象的出现，并不是增强了代码的功能，而是在我们编写代码的时候更具有<strong>函数式编程</strong>的风格。平常我们的对对象的操作，例如对象属性的读取和修改，函数的调用，都可以通过使用Reflect中的相关方法来达到同样的效果。我们的所有操作，通过使用Reflect对象，都可以通过<strong>函数调用</strong>来完成。</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>Reflect的方法很多，在这里就说一个我个人感觉比较常用的方法</p>\n<h4 id=\"1-Reflect-get-target-propertyKey-receiver\"><a href=\"#1-Reflect-get-target-propertyKey-receiver\" class=\"headerlink\" title=\"1. Reflect.get(target,propertyKey,_receiver)\"></a>1. Reflect.get(target,propertyKey,_receiver)</h4><p>该静态方法是返回被操作对象所对应属性名的属性值</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：需要取值的目标对象</li>\n<li>propertyKey：需要获取的值的键值</li>\n<li>receiver(可省略)：如果<code>target</code>对象中指定了<code>getter</code>，<code>receiver</code>则为<code>getter</code>调用时的<code>this</code>值</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>被操作对象属性名所对应的值</p>\n<pre><code class=\"js\">// 定义测试对象 obj\nvar obj = &#123; a: 1, &#125;\n// 1\nconsole.log(Reflect.get(obj, &quot;a&quot;));\n</code></pre>\n<h4 id=\"2-Reflect-set-target-propertyKey-value-received\"><a href=\"#2-Reflect-set-target-propertyKey-value-received\" class=\"headerlink\" title=\"2. Reflect.set(target,propertyKey,value,_received)\"></a>2. Reflect.set(target,propertyKey,value,_received)</h4><p>该静态方法是在被操作对象设置属性</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：设置属性的目标对象</li>\n<li>propertyKey：设置的属性的名称</li>\n<li>value：设置的值</li>\n<li>receiver(可省略)：如果<code>target</code>对象中指定了<code>setter</code>，<code>receiver</code>则为<code>setter</code>调用时的<code>this</code>值</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>返回一个Boolean表明是否在被操作对象成功设置该属性</p>\n<pre><code class=\"js\">// 定义测试对象 obj\nvar obj = &#123; a: 1, &#125;\n// 使用Reflect.set函数\nReflect.set(obj, &quot;b&quot;, 2);\n// &#123;a: 1, b: 2&#125;\nconsole.log(obj);\n</code></pre>\n<h4 id=\"3-Relfect-apply-target-thisArguments-argumentsList\"><a href=\"#3-Relfect-apply-target-thisArguments-argumentsList\" class=\"headerlink\" title=\"3. Relfect.apply(target,thisArguments,argumentsList)\"></a>3. Relfect.apply(target,thisArguments,argumentsList)</h4><p>该静态方法是通过指定的参数列发起对目标函数的调用</p>\n<p><strong>参数解释</strong></p>\n<ol>\n<li>target：目标函数</li>\n<li>thisArgument：target函数调用时绑定的this对象</li>\n<li>argumentsList：target函数调用时传入的实参列表，该参数应该是一个类数组的对象</li>\n</ol>\n<p><strong>返回值</strong></p>\n<p>是调用完带着指定参数和this值的给定的函数后执行所返回的结果</p>\n<pre><code class=\"js\">// 创建测试函数\nfunction f() &#123;\n    // 打印当前调用该函数的对象\n    console.log(this);\n    // 循环打印调用该函数时所传入的参数\n    for (let i = 0; i &lt; arguments.length; i++) &#123;\n        console.log(arguments[i]);\n    &#125;\n    // 函数返回值\n    return &quot;hello f&quot;;\n&#125;\n// 使用Reflect.apply函数\n// 打印f执行中当前this的值：&#123;a: 1, b: 2&#125;\n// 循环打印处f在执行时传入的参数\n// 1\n// 2\n// 3\n// 4\n// 5\n// 最终打印使用Reflect.apply所返回的结果：即执行f时所返回的结果：hello f\nconsole.log(Reflect.apply(f, &#123; a: 1, b: 2 &#125;, [1, 2, 3, 4, 5]));\n</code></pre>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h4 id=\"与proxy对象一起使用\"><a href=\"#与proxy对象一起使用\" class=\"headerlink\" title=\"与proxy对象一起使用\"></a>与proxy对象一起使用</h4><pre><code class=\"js\">// 创建测试样例\nvar o = &#123;\n    a:1\n&#125;\n// 创建Proxy对象 op\nlet op = new Proxy(o,&#123;\n    set:function(target,prop,value,_proxy)&#123;\n        // 使用Reflect对象的set方法\n        Reflect.set(target,prop,value);\n    &#125;,\n    get:function(target,prop,_proxy)&#123;\n        // 使用Reflect对象的get方法\n        return Reflect.get(target,prop);\n    &#125;\n&#125;)\n// 修改对象op的a的值，会触发set方法\nop.a = 2;\n// 输出对象op,Proxy &#123;a: 2&#125;\nconsole.log(op);\n// 读取对象op的属性a的值，会触发get方法\n// 2\nconsole.log(op.a);\n</code></pre>\n"},{"title":"ES的简单认识","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES","date":"2020-07-10T16:00:00.000Z","comments":0,"description":"ES的简单认识","photos":["https://ae01.alicdn.com/kf/H8ac3295c4a524772a9a05aacf68648876.jpg"],"_content":"\n## 前言\n\n#### 名称解释\n1. ECMA(European Computer Manufacturers Association)，中文名称为欧洲计算机制造协会，1994年改名为Ecma\n2. ECMAScript，是由Ecma国际通过ECMA-262标准化的脚本程序设计语言\n3. ECMA-262则是ECMA制定的脚本语言标准\n\n#### ECMA-262的发展历史\n\n|  版本  |    年份    |                           相关内容                           |\n| :----: | :--------: | :----------------------------------------------------------: |\n| 第1版  |   1997年   |                     制定了语言的基本语法                     |\n| 第2版  |   1998年   |                           较小改动                           |\n| 第3版  |   1999年   |         引入正则，异常处理，格式化输入等。IE开始支持         |\n| 第4版  |   2007年   |                       过于激进，未发布                       |\n| 第5版  |   2009年   |  引入严格模式，JSON,扩展对象，数组，原型，字符串，日期方法   |\n| 第6版  | **2015年** | 模块化，面向对象语法，Promise，箭头函数，let，const,数组结果赋值等等 |\n| 第7版  |   2016年   |            幂运算符，数组扩展，Async/Await关键字             |\n| 第8版  |   2017年   |                   Async/Await，字符串扩展                    |\n| 第9版  |   2018年   |                    对象解构赋值，正则扩展                    |\n| 第10版 |   2019年   |                      扩展对象，数组方法                      |\n","source":"_posts/前端/ES总结/ES.md","raw":"---\ntitle: ES的简单认识\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - javascript\nkeywords: ES\ndate: 2020-07-11 \ncomments: false\ndescription: ES的简单认识\nphotos: https://ae01.alicdn.com/kf/H8ac3295c4a524772a9a05aacf68648876.jpg\n---\n\n## 前言\n\n#### 名称解释\n1. ECMA(European Computer Manufacturers Association)，中文名称为欧洲计算机制造协会，1994年改名为Ecma\n2. ECMAScript，是由Ecma国际通过ECMA-262标准化的脚本程序设计语言\n3. ECMA-262则是ECMA制定的脚本语言标准\n\n#### ECMA-262的发展历史\n\n|  版本  |    年份    |                           相关内容                           |\n| :----: | :--------: | :----------------------------------------------------------: |\n| 第1版  |   1997年   |                     制定了语言的基本语法                     |\n| 第2版  |   1998年   |                           较小改动                           |\n| 第3版  |   1999年   |         引入正则，异常处理，格式化输入等。IE开始支持         |\n| 第4版  |   2007年   |                       过于激进，未发布                       |\n| 第5版  |   2009年   |  引入严格模式，JSON,扩展对象，数组，原型，字符串，日期方法   |\n| 第6版  | **2015年** | 模块化，面向对象语法，Promise，箭头函数，let，const,数组结果赋值等等 |\n| 第7版  |   2016年   |            幂运算符，数组扩展，Async/Await关键字             |\n| 第8版  |   2017年   |                   Async/Await，字符串扩展                    |\n| 第9版  |   2018年   |                    对象解构赋值，正则扩展                    |\n| 第10版 |   2019年   |                      扩展对象，数组方法                      |\n","slug":"前端/ES总结/ES","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t2u001i2h1729w39p5r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h4 id=\"名称解释\"><a href=\"#名称解释\" class=\"headerlink\" title=\"名称解释\"></a>名称解释</h4><ol>\n<li>ECMA(European Computer Manufacturers Association)，中文名称为欧洲计算机制造协会，1994年改名为Ecma</li>\n<li>ECMAScript，是由Ecma国际通过ECMA-262标准化的脚本程序设计语言</li>\n<li>ECMA-262则是ECMA制定的脚本语言标准</li>\n</ol>\n<h4 id=\"ECMA-262的发展历史\"><a href=\"#ECMA-262的发展历史\" class=\"headerlink\" title=\"ECMA-262的发展历史\"></a>ECMA-262的发展历史</h4><table>\n<thead>\n<tr>\n<th align=\"center\">版本</th>\n<th align=\"center\">年份</th>\n<th align=\"center\">相关内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">第1版</td>\n<td align=\"center\">1997年</td>\n<td align=\"center\">制定了语言的基本语法</td>\n</tr>\n<tr>\n<td align=\"center\">第2版</td>\n<td align=\"center\">1998年</td>\n<td align=\"center\">较小改动</td>\n</tr>\n<tr>\n<td align=\"center\">第3版</td>\n<td align=\"center\">1999年</td>\n<td align=\"center\">引入正则，异常处理，格式化输入等。IE开始支持</td>\n</tr>\n<tr>\n<td align=\"center\">第4版</td>\n<td align=\"center\">2007年</td>\n<td align=\"center\">过于激进，未发布</td>\n</tr>\n<tr>\n<td align=\"center\">第5版</td>\n<td align=\"center\">2009年</td>\n<td align=\"center\">引入严格模式，JSON,扩展对象，数组，原型，字符串，日期方法</td>\n</tr>\n<tr>\n<td align=\"center\">第6版</td>\n<td align=\"center\"><strong>2015年</strong></td>\n<td align=\"center\">模块化，面向对象语法，Promise，箭头函数，let，const,数组结果赋值等等</td>\n</tr>\n<tr>\n<td align=\"center\">第7版</td>\n<td align=\"center\">2016年</td>\n<td align=\"center\">幂运算符，数组扩展，Async&#x2F;Await关键字</td>\n</tr>\n<tr>\n<td align=\"center\">第8版</td>\n<td align=\"center\">2017年</td>\n<td align=\"center\">Async&#x2F;Await，字符串扩展</td>\n</tr>\n<tr>\n<td align=\"center\">第9版</td>\n<td align=\"center\">2018年</td>\n<td align=\"center\">对象解构赋值，正则扩展</td>\n</tr>\n<tr>\n<td align=\"center\">第10版</td>\n<td align=\"center\">2019年</td>\n<td align=\"center\">扩展对象，数组方法</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h4 id=\"名称解释\"><a href=\"#名称解释\" class=\"headerlink\" title=\"名称解释\"></a>名称解释</h4><ol>\n<li>ECMA(European Computer Manufacturers Association)，中文名称为欧洲计算机制造协会，1994年改名为Ecma</li>\n<li>ECMAScript，是由Ecma国际通过ECMA-262标准化的脚本程序设计语言</li>\n<li>ECMA-262则是ECMA制定的脚本语言标准</li>\n</ol>\n<h4 id=\"ECMA-262的发展历史\"><a href=\"#ECMA-262的发展历史\" class=\"headerlink\" title=\"ECMA-262的发展历史\"></a>ECMA-262的发展历史</h4><table>\n<thead>\n<tr>\n<th align=\"center\">版本</th>\n<th align=\"center\">年份</th>\n<th align=\"center\">相关内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">第1版</td>\n<td align=\"center\">1997年</td>\n<td align=\"center\">制定了语言的基本语法</td>\n</tr>\n<tr>\n<td align=\"center\">第2版</td>\n<td align=\"center\">1998年</td>\n<td align=\"center\">较小改动</td>\n</tr>\n<tr>\n<td align=\"center\">第3版</td>\n<td align=\"center\">1999年</td>\n<td align=\"center\">引入正则，异常处理，格式化输入等。IE开始支持</td>\n</tr>\n<tr>\n<td align=\"center\">第4版</td>\n<td align=\"center\">2007年</td>\n<td align=\"center\">过于激进，未发布</td>\n</tr>\n<tr>\n<td align=\"center\">第5版</td>\n<td align=\"center\">2009年</td>\n<td align=\"center\">引入严格模式，JSON,扩展对象，数组，原型，字符串，日期方法</td>\n</tr>\n<tr>\n<td align=\"center\">第6版</td>\n<td align=\"center\"><strong>2015年</strong></td>\n<td align=\"center\">模块化，面向对象语法，Promise，箭头函数，let，const,数组结果赋值等等</td>\n</tr>\n<tr>\n<td align=\"center\">第7版</td>\n<td align=\"center\">2016年</td>\n<td align=\"center\">幂运算符，数组扩展，Async&#x2F;Await关键字</td>\n</tr>\n<tr>\n<td align=\"center\">第8版</td>\n<td align=\"center\">2017年</td>\n<td align=\"center\">Async&#x2F;Await，字符串扩展</td>\n</tr>\n<tr>\n<td align=\"center\">第9版</td>\n<td align=\"center\">2018年</td>\n<td align=\"center\">对象解构赋值，正则扩展</td>\n</tr>\n<tr>\n<td align=\"center\">第10版</td>\n<td align=\"center\">2019年</td>\n<td align=\"center\">扩展对象，数组方法</td>\n</tr>\n</tbody></table>\n"},{"title":"ES6 语法总结 01","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES","date":"2020-07-11T16:00:00.000Z","comments":0,"description":"ES6语法总结","photos":["https://ae01.alicdn.com/kf/H046403451c8b4efabd9f0a794de68422a.jpg"],"_content":"\n## 关键字 let\n\n描述：ES6定义了`let`关键字用于声明块级作用域变量\n\n#### 特点\n\n1. 变量不能重复声明\n2. 块级作用域(全局作用域，函数作用域，eval作用域)\n3. 不存在变量提升\n4. 不影响作用域链\n\n#### 案例场景\n\n1. 点击div换色\n\n现在页面中，有三个div，我们需要添加该功能，点击div时背景颜色变红\n\n```html\n<html>\n    <head>\n        <title>div点击变色</title>\n        <style>\n            div{\n                width:100px;\n                height:100px;\n                margin:40px;\n                float:left;\n            }\n        </style>\n    </head>\n    <body>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <script>\n            var divs = document.getElementByTagNames('div');\n            for(let i=0;i<divs.length;i++){\n                divs[i].onClick = function(){\n                    // this.style.background = 'pink';\n                    div[i].style.background = 'pink'; // **\n                }\n            }\n        </script>\n    </body>\n</html>\n```\n\n如果我们使用var来声明变量，那么其对于的点击事件函数内部就无法访问到与之对应的DOM元素。\n因为事件函数的执行是异步执行的，而var声明的变量是挂载到全局对象上的，\n当事件函数开始执行时，其i值为3,就无法访问到在最初注册该事件函数时与之对应的DOM对象\n\n\n而let声明因为其块级作用域，可以保留当时i的状态，\n因此在事件函数中定义是所使用的i保留其当时注册使用的值，也因为上述的代码可以满足我们的要求\n\n\n\n2. 定时器输出\n\n```js\nfor(let i=0;i<5;i++){\n    setTimeout(()=>{\n        console.log(i);\n    })\n}\n\n// 0,1,2,3,4\nfor(var i=0;i<5;i++){\n    setTimeout(()=>{\n        console.log(i);\n    })\n}\n// 5,5,5,5,5\n```\n\n\n这是一道非常常见的面试题\n\n在解决该问题之前，我们要清楚定时器里的函数是什么时候进行的：是在我们主线程代码结束后才会执行\n\n也因此,定时器里的函数执行是在for循环结果后才执行\n\n那么,为什么两种结果不一样：主要是因为var&let的不同\n\nlet声明的变量在函数使用的时候也会记录它当前的值，\n也因此let声明的i在函数中被使用，然后被调用输入的结果为0,1,2,3,4\n\nvar声明的变量会挂载在全局对象，\n函数执行的时候是直接找到了全局对象的i,而此时i的值在循环之后就变成了5，也因此函数执行的输出结果为5,5,5,5,5\n\n\n\n \n## 关键字 const\n\n描述：ES6定义了`const`关键字用于定义常量\n\n#### 特点\n\n1. 一定要赋初始值\n2. 一般常量使用大写(潜规则)\n3. 常量的值不能修改\n4. 块级作用域\n5. 对于元素和对象的元素成员修改，不算做对常量的修改，不会报错\n\n## 变量解构赋值\n\n描述：ES6允许按照一定模式从对象和数组提取值，对变量进行赋值\n\n#### 1. 数组的解构\n```js\nlet array = [1,2,3,4];\nconst [one,two,three,four] = array;\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\nconsole.log(four); // 4\n```\n\n#### 2. 对象的解构\n```js\nlet person = {\n    name:'zhangsan',\n    age:24,\n    sayHello:function(){\n        console.log('hello world');\n    }\n}\n\nconst { name,age,sayHello } = person;\nconsole.log(name); // 'zhangsan'\nconsole.log(age); // 24\nconsole.log(sayHello); // Function sayHello\nsayHello() // hello world\n```\n\n## 模板字符串\n\n描述：ES6引入新的声明字符串的方式 \n\n```js\n// 1. 声明\nlet str = `I am a string`;\nconsole.log(typeof str); // 'string'\n\n// 2. 内容可以直接出现换行符 \nlet htmlCode = `\n                <body>\n                    <h1>hello template string</h1>\n                </body>\n                `\n\n// 3. 变量拼接\nlet strValue = 'string';\nlet str = `I am a ${strValue}`;\nconsole.log(str); // I am a string\n```\n\n## 对象的简洁写法\n\n描述：ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法\n\n```js\nlet name = 'zhangsan';\nlet age = 24;\n\nlet person = {\n    name,\n    age\n}\n\nconsole.log(person) // {name:'zhangsan',age:24}\n```\n\n\n## 箭头函数\n\n描述：ES6允许使用箭头(=>)定义函数\n\n```js\nlet fn = () =>{\n    console.log('hello world');\n}\n\nfn();\n```\n\n#### 特点\n\n1. this是静态的，this始终指向函数声明时所在作用域下的this值\n2. 不能作为构造函数实例化对象\n3. 不能使用arguments变量\n4. 箭头函数的简写\n    1) 省略小括号，当形参有且只有一个的时候\n    2) 省略花括号，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值\n\n#### 应用场景\n\n1. 点击div 2s后颜色变红\n\n```html\n<html>\n    <head>\n        <title>箭头函数使用</title>\n        <style>\n            div{\n                width:100px;\n                height:100px;\n                background:blue;\n                margin:100px\n            }\n        </style>\n    </head>\n    <body>\n        <div id = \"test\"></div>\n        <script>\n            // 获取元素\n            let div = document.getElementById('test');\n            // 注册点击事件\n            div.addEventListener('click', function () {\n                setTimeout(() => {\n                    this.style.background = 'pink';\n                })\n            });\n        </script>\n    </body>\n</html>\n```\n2. 从数据返回偶数的元素\n\n```js\nconst array = [1,3,4,5,6,7,9];\n\nconst oddArr = array.filter(item=>item%2===0);\n\nconsole.log(oddArr) // [4,6];\n```\n\n箭头函数`适合与this无关的回调`(定时器，数组的方法回调)，`不适合与this有关的回调`(DOM事件，对象的方法)\n\n\n## 函数参数默认值\n\n描述：ES6允许给函数参数赋值初始值\n\n\n#### 特点\n\n1. 形参初始值，具有默认值的参数，一般位置要靠后(潜规则)\n2. 与解构赋值结合\n\n```js\nfunction fn(a,b,c=10){\n    console.log(a+b+c);\n}\n\nfn(1,2,3); // 6\n\nfn(1,2); // 13\n\n// -------------------------- // \n\nfunction fn2({name,age,sex='man'}){\n    console.log(`${name},${age},${sex}`);\n}\n\nvar person1 = {\n    name:'zhangsan',\n    age:24\n};\n\nvar person2 = {\n    name:'baimeigui',\n    age:24,\n    sex:'woman'\n};\n\nfn2(person1); // zhangsan,24,man\n\nfn2(person2); // baimeigui,24,woman\n```\n\n## rest参数\n\n描述：ES6引入rest参数，用于获取函数的实参，用来代替arguments\n\nrest参数必须放在参数的最后\n\n```js\nfunction es5F(){\n    console.log(arguments);\n}\n\nfunction es6F(...rest){\n    console.log(rest);\n}\n\nes5F(1,2,3,4,5); // 类数组 [1,2,3,4,5]\n\nes6F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n```\n\n## 扩展运算符\n\n描述：'...' 扩展运算符能够将数组转换为逗号分割的参数序列\n\n1. 可以将数组成员分解为一个个的参数序列\n\n#### 应用\n\n1. 数组的合并\n\n```js\nvar arr1 = [1,2,3];\n\nvar arr2 = [4,5,6];\n\nvar arr = [...arr1,...arr2];\n\nconsole.log(arr);// [1,2,3,4,5,6]\n```\n\n2. 数组的克隆\n\n```js\nlet arr1 = [1,2,3];\nlet arr2 = [...arr1];\n\nconsole.log(arr2); // [1,2,3]\n\nconsole.log(arr1===arr2); // false\n```\n\n3. 将伪数组转换为真正的数组\n\n```js\nfunction es5F(){\n    let args = [...arguments];\n    console.log(args);\n}\n\nes5F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n```","source":"_posts/前端/ES总结/ES6 语法总结 01.md","raw":"---\ntitle: ES6 语法总结 01\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - javascript\nkeywords: ES\ndate: 2020-07-12 \ncomments: false\ndescription: ES6语法总结\nphotos: https://ae01.alicdn.com/kf/H046403451c8b4efabd9f0a794de68422a.jpg\n---\n\n## 关键字 let\n\n描述：ES6定义了`let`关键字用于声明块级作用域变量\n\n#### 特点\n\n1. 变量不能重复声明\n2. 块级作用域(全局作用域，函数作用域，eval作用域)\n3. 不存在变量提升\n4. 不影响作用域链\n\n#### 案例场景\n\n1. 点击div换色\n\n现在页面中，有三个div，我们需要添加该功能，点击div时背景颜色变红\n\n```html\n<html>\n    <head>\n        <title>div点击变色</title>\n        <style>\n            div{\n                width:100px;\n                height:100px;\n                margin:40px;\n                float:left;\n            }\n        </style>\n    </head>\n    <body>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <script>\n            var divs = document.getElementByTagNames('div');\n            for(let i=0;i<divs.length;i++){\n                divs[i].onClick = function(){\n                    // this.style.background = 'pink';\n                    div[i].style.background = 'pink'; // **\n                }\n            }\n        </script>\n    </body>\n</html>\n```\n\n如果我们使用var来声明变量，那么其对于的点击事件函数内部就无法访问到与之对应的DOM元素。\n因为事件函数的执行是异步执行的，而var声明的变量是挂载到全局对象上的，\n当事件函数开始执行时，其i值为3,就无法访问到在最初注册该事件函数时与之对应的DOM对象\n\n\n而let声明因为其块级作用域，可以保留当时i的状态，\n因此在事件函数中定义是所使用的i保留其当时注册使用的值，也因为上述的代码可以满足我们的要求\n\n\n\n2. 定时器输出\n\n```js\nfor(let i=0;i<5;i++){\n    setTimeout(()=>{\n        console.log(i);\n    })\n}\n\n// 0,1,2,3,4\nfor(var i=0;i<5;i++){\n    setTimeout(()=>{\n        console.log(i);\n    })\n}\n// 5,5,5,5,5\n```\n\n\n这是一道非常常见的面试题\n\n在解决该问题之前，我们要清楚定时器里的函数是什么时候进行的：是在我们主线程代码结束后才会执行\n\n也因此,定时器里的函数执行是在for循环结果后才执行\n\n那么,为什么两种结果不一样：主要是因为var&let的不同\n\nlet声明的变量在函数使用的时候也会记录它当前的值，\n也因此let声明的i在函数中被使用，然后被调用输入的结果为0,1,2,3,4\n\nvar声明的变量会挂载在全局对象，\n函数执行的时候是直接找到了全局对象的i,而此时i的值在循环之后就变成了5，也因此函数执行的输出结果为5,5,5,5,5\n\n\n\n \n## 关键字 const\n\n描述：ES6定义了`const`关键字用于定义常量\n\n#### 特点\n\n1. 一定要赋初始值\n2. 一般常量使用大写(潜规则)\n3. 常量的值不能修改\n4. 块级作用域\n5. 对于元素和对象的元素成员修改，不算做对常量的修改，不会报错\n\n## 变量解构赋值\n\n描述：ES6允许按照一定模式从对象和数组提取值，对变量进行赋值\n\n#### 1. 数组的解构\n```js\nlet array = [1,2,3,4];\nconst [one,two,three,four] = array;\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\nconsole.log(four); // 4\n```\n\n#### 2. 对象的解构\n```js\nlet person = {\n    name:'zhangsan',\n    age:24,\n    sayHello:function(){\n        console.log('hello world');\n    }\n}\n\nconst { name,age,sayHello } = person;\nconsole.log(name); // 'zhangsan'\nconsole.log(age); // 24\nconsole.log(sayHello); // Function sayHello\nsayHello() // hello world\n```\n\n## 模板字符串\n\n描述：ES6引入新的声明字符串的方式 \n\n```js\n// 1. 声明\nlet str = `I am a string`;\nconsole.log(typeof str); // 'string'\n\n// 2. 内容可以直接出现换行符 \nlet htmlCode = `\n                <body>\n                    <h1>hello template string</h1>\n                </body>\n                `\n\n// 3. 变量拼接\nlet strValue = 'string';\nlet str = `I am a ${strValue}`;\nconsole.log(str); // I am a string\n```\n\n## 对象的简洁写法\n\n描述：ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法\n\n```js\nlet name = 'zhangsan';\nlet age = 24;\n\nlet person = {\n    name,\n    age\n}\n\nconsole.log(person) // {name:'zhangsan',age:24}\n```\n\n\n## 箭头函数\n\n描述：ES6允许使用箭头(=>)定义函数\n\n```js\nlet fn = () =>{\n    console.log('hello world');\n}\n\nfn();\n```\n\n#### 特点\n\n1. this是静态的，this始终指向函数声明时所在作用域下的this值\n2. 不能作为构造函数实例化对象\n3. 不能使用arguments变量\n4. 箭头函数的简写\n    1) 省略小括号，当形参有且只有一个的时候\n    2) 省略花括号，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值\n\n#### 应用场景\n\n1. 点击div 2s后颜色变红\n\n```html\n<html>\n    <head>\n        <title>箭头函数使用</title>\n        <style>\n            div{\n                width:100px;\n                height:100px;\n                background:blue;\n                margin:100px\n            }\n        </style>\n    </head>\n    <body>\n        <div id = \"test\"></div>\n        <script>\n            // 获取元素\n            let div = document.getElementById('test');\n            // 注册点击事件\n            div.addEventListener('click', function () {\n                setTimeout(() => {\n                    this.style.background = 'pink';\n                })\n            });\n        </script>\n    </body>\n</html>\n```\n2. 从数据返回偶数的元素\n\n```js\nconst array = [1,3,4,5,6,7,9];\n\nconst oddArr = array.filter(item=>item%2===0);\n\nconsole.log(oddArr) // [4,6];\n```\n\n箭头函数`适合与this无关的回调`(定时器，数组的方法回调)，`不适合与this有关的回调`(DOM事件，对象的方法)\n\n\n## 函数参数默认值\n\n描述：ES6允许给函数参数赋值初始值\n\n\n#### 特点\n\n1. 形参初始值，具有默认值的参数，一般位置要靠后(潜规则)\n2. 与解构赋值结合\n\n```js\nfunction fn(a,b,c=10){\n    console.log(a+b+c);\n}\n\nfn(1,2,3); // 6\n\nfn(1,2); // 13\n\n// -------------------------- // \n\nfunction fn2({name,age,sex='man'}){\n    console.log(`${name},${age},${sex}`);\n}\n\nvar person1 = {\n    name:'zhangsan',\n    age:24\n};\n\nvar person2 = {\n    name:'baimeigui',\n    age:24,\n    sex:'woman'\n};\n\nfn2(person1); // zhangsan,24,man\n\nfn2(person2); // baimeigui,24,woman\n```\n\n## rest参数\n\n描述：ES6引入rest参数，用于获取函数的实参，用来代替arguments\n\nrest参数必须放在参数的最后\n\n```js\nfunction es5F(){\n    console.log(arguments);\n}\n\nfunction es6F(...rest){\n    console.log(rest);\n}\n\nes5F(1,2,3,4,5); // 类数组 [1,2,3,4,5]\n\nes6F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n```\n\n## 扩展运算符\n\n描述：'...' 扩展运算符能够将数组转换为逗号分割的参数序列\n\n1. 可以将数组成员分解为一个个的参数序列\n\n#### 应用\n\n1. 数组的合并\n\n```js\nvar arr1 = [1,2,3];\n\nvar arr2 = [4,5,6];\n\nvar arr = [...arr1,...arr2];\n\nconsole.log(arr);// [1,2,3,4,5,6]\n```\n\n2. 数组的克隆\n\n```js\nlet arr1 = [1,2,3];\nlet arr2 = [...arr1];\n\nconsole.log(arr2); // [1,2,3]\n\nconsole.log(arr1===arr2); // false\n```\n\n3. 将伪数组转换为真正的数组\n\n```js\nfunction es5F(){\n    let args = [...arguments];\n    console.log(args);\n}\n\nes5F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n```","slug":"前端/ES总结/ES6 语法总结 01","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t2v001l2h17519jc4xc","content":"<h2 id=\"关键字-let\"><a href=\"#关键字-let\" class=\"headerlink\" title=\"关键字 let\"></a>关键字 let</h2><p>描述：ES6定义了<code>let</code>关键字用于声明块级作用域变量</p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>变量不能重复声明</li>\n<li>块级作用域(全局作用域，函数作用域，eval作用域)</li>\n<li>不存在变量提升</li>\n<li>不影响作用域链</li>\n</ol>\n<h4 id=\"案例场景\"><a href=\"#案例场景\" class=\"headerlink\" title=\"案例场景\"></a>案例场景</h4><ol>\n<li>点击div换色</li>\n</ol>\n<p>现在页面中，有三个div，我们需要添加该功能，点击div时背景颜色变红</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;div点击变色&lt;/title&gt;\n        &lt;style&gt;\n            div&#123;\n                width:100px;\n                height:100px;\n                margin:40px;\n                float:left;\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var divs = document.getElementByTagNames(&#39;div&#39;);\n            for(let i=0;i&lt;divs.length;i++)&#123;\n                divs[i].onClick = function()&#123;\n                    // this.style.background = &#39;pink&#39;;\n                    div[i].style.background = &#39;pink&#39;; // **\n                &#125;\n            &#125;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>如果我们使用var来声明变量，那么其对于的点击事件函数内部就无法访问到与之对应的DOM元素。<br>因为事件函数的执行是异步执行的，而var声明的变量是挂载到全局对象上的，<br>当事件函数开始执行时，其i值为3,就无法访问到在最初注册该事件函数时与之对应的DOM对象</p>\n<p>而let声明因为其块级作用域，可以保留当时i的状态，<br>因此在事件函数中定义是所使用的i保留其当时注册使用的值，也因为上述的代码可以满足我们的要求</p>\n<ol start=\"2\">\n<li>定时器输出</li>\n</ol>\n<pre><code class=\"js\">for(let i=0;i&lt;5;i++)&#123;\n    setTimeout(()=&gt;&#123;\n        console.log(i);\n    &#125;)\n&#125;\n\n// 0,1,2,3,4\nfor(var i=0;i&lt;5;i++)&#123;\n    setTimeout(()=&gt;&#123;\n        console.log(i);\n    &#125;)\n&#125;\n// 5,5,5,5,5\n</code></pre>\n<p>这是一道非常常见的面试题</p>\n<p>在解决该问题之前，我们要清楚定时器里的函数是什么时候进行的：是在我们主线程代码结束后才会执行</p>\n<p>也因此,定时器里的函数执行是在for循环结果后才执行</p>\n<p>那么,为什么两种结果不一样：主要是因为var&amp;let的不同</p>\n<p>let声明的变量在函数使用的时候也会记录它当前的值，<br>也因此let声明的i在函数中被使用，然后被调用输入的结果为0,1,2,3,4</p>\n<p>var声明的变量会挂载在全局对象，<br>函数执行的时候是直接找到了全局对象的i,而此时i的值在循环之后就变成了5，也因此函数执行的输出结果为5,5,5,5,5</p>\n<h2 id=\"关键字-const\"><a href=\"#关键字-const\" class=\"headerlink\" title=\"关键字 const\"></a>关键字 const</h2><p>描述：ES6定义了<code>const</code>关键字用于定义常量</p>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>一定要赋初始值</li>\n<li>一般常量使用大写(潜规则)</li>\n<li>常量的值不能修改</li>\n<li>块级作用域</li>\n<li>对于元素和对象的元素成员修改，不算做对常量的修改，不会报错</li>\n</ol>\n<h2 id=\"变量解构赋值\"><a href=\"#变量解构赋值\" class=\"headerlink\" title=\"变量解构赋值\"></a>变量解构赋值</h2><p>描述：ES6允许按照一定模式从对象和数组提取值，对变量进行赋值</p>\n<h4 id=\"1-数组的解构\"><a href=\"#1-数组的解构\" class=\"headerlink\" title=\"1. 数组的解构\"></a>1. 数组的解构</h4><pre><code class=\"js\">let array = [1,2,3,4];\nconst [one,two,three,four] = array;\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\nconsole.log(four); // 4\n</code></pre>\n<h4 id=\"2-对象的解构\"><a href=\"#2-对象的解构\" class=\"headerlink\" title=\"2. 对象的解构\"></a>2. 对象的解构</h4><pre><code class=\"js\">let person = &#123;\n    name:&#39;zhangsan&#39;,\n    age:24,\n    sayHello:function()&#123;\n        console.log(&#39;hello world&#39;);\n    &#125;\n&#125;\n\nconst &#123; name,age,sayHello &#125; = person;\nconsole.log(name); // &#39;zhangsan&#39;\nconsole.log(age); // 24\nconsole.log(sayHello); // Function sayHello\nsayHello() // hello world\n</code></pre>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>描述：ES6引入新的声明字符串的方式 </p>\n<pre><code class=\"js\">// 1. 声明\nlet str = `I am a string`;\nconsole.log(typeof str); // &#39;string&#39;\n\n// 2. 内容可以直接出现换行符 \nlet htmlCode = `\n                &lt;body&gt;\n                    &lt;h1&gt;hello template string&lt;/h1&gt;\n                &lt;/body&gt;\n                `\n\n// 3. 变量拼接\nlet strValue = &#39;string&#39;;\nlet str = `I am a $&#123;strValue&#125;`;\nconsole.log(str); // I am a string\n</code></pre>\n<h2 id=\"对象的简洁写法\"><a href=\"#对象的简洁写法\" class=\"headerlink\" title=\"对象的简洁写法\"></a>对象的简洁写法</h2><p>描述：ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p>\n<pre><code class=\"js\">let name = &#39;zhangsan&#39;;\nlet age = 24;\n\nlet person = &#123;\n    name,\n    age\n&#125;\n\nconsole.log(person) // &#123;name:&#39;zhangsan&#39;,age:24&#125;\n</code></pre>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>描述：ES6允许使用箭头(&#x3D;&gt;)定义函数</p>\n<pre><code class=\"js\">let fn = () =&gt;&#123;\n    console.log(&#39;hello world&#39;);\n&#125;\n\nfn();\n</code></pre>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>this是静态的，this始终指向函数声明时所在作用域下的this值</li>\n<li>不能作为构造函数实例化对象</li>\n<li>不能使用arguments变量</li>\n<li>箭头函数的简写<ol>\n<li>省略小括号，当形参有且只有一个的时候</li>\n<li>省略花括号，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ol>\n<li>点击div 2s后颜色变红</li>\n</ol>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;箭头函数使用&lt;/title&gt;\n        &lt;style&gt;\n            div&#123;\n                width:100px;\n                height:100px;\n                background:blue;\n                margin:100px\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = &quot;test&quot;&gt;&lt;/div&gt;\n        &lt;script&gt;\n            // 获取元素\n            let div = document.getElementById(&#39;test&#39;);\n            // 注册点击事件\n            div.addEventListener(&#39;click&#39;, function () &#123;\n                setTimeout(() =&gt; &#123;\n                    this.style.background = &#39;pink&#39;;\n                &#125;)\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"2\">\n<li>从数据返回偶数的元素</li>\n</ol>\n<pre><code class=\"js\">const array = [1,3,4,5,6,7,9];\n\nconst oddArr = array.filter(item=&gt;item%2===0);\n\nconsole.log(oddArr) // [4,6];\n</code></pre>\n<p>箭头函数<code>适合与this无关的回调</code>(定时器，数组的方法回调)，<code>不适合与this有关的回调</code>(DOM事件，对象的方法)</p>\n<h2 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h2><p>描述：ES6允许给函数参数赋值初始值</p>\n<h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>形参初始值，具有默认值的参数，一般位置要靠后(潜规则)</li>\n<li>与解构赋值结合</li>\n</ol>\n<pre><code class=\"js\">function fn(a,b,c=10)&#123;\n    console.log(a+b+c);\n&#125;\n\nfn(1,2,3); // 6\n\nfn(1,2); // 13\n\n// -------------------------- // \n\nfunction fn2(&#123;name,age,sex=&#39;man&#39;&#125;)&#123;\n    console.log(`$&#123;name&#125;,$&#123;age&#125;,$&#123;sex&#125;`);\n&#125;\n\nvar person1 = &#123;\n    name:&#39;zhangsan&#39;,\n    age:24\n&#125;;\n\nvar person2 = &#123;\n    name:&#39;baimeigui&#39;,\n    age:24,\n    sex:&#39;woman&#39;\n&#125;;\n\nfn2(person1); // zhangsan,24,man\n\nfn2(person2); // baimeigui,24,woman\n</code></pre>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>描述：ES6引入rest参数，用于获取函数的实参，用来代替arguments</p>\n<p>rest参数必须放在参数的最后</p>\n<pre><code class=\"js\">function es5F()&#123;\n    console.log(arguments);\n&#125;\n\nfunction es6F(...rest)&#123;\n    console.log(rest);\n&#125;\n\nes5F(1,2,3,4,5); // 类数组 [1,2,3,4,5]\n\nes6F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n</code></pre>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>描述：’…’ 扩展运算符能够将数组转换为逗号分割的参数序列</p>\n<ol>\n<li>可以将数组成员分解为一个个的参数序列</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>数组的合并</li>\n</ol>\n<pre><code class=\"js\">var arr1 = [1,2,3];\n\nvar arr2 = [4,5,6];\n\nvar arr = [...arr1,...arr2];\n\nconsole.log(arr);// [1,2,3,4,5,6]\n</code></pre>\n<ol start=\"2\">\n<li>数组的克隆</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,3];\nlet arr2 = [...arr1];\n\nconsole.log(arr2); // [1,2,3]\n\nconsole.log(arr1===arr2); // false\n</code></pre>\n<ol start=\"3\">\n<li>将伪数组转换为真正的数组</li>\n</ol>\n<pre><code class=\"js\">function es5F()&#123;\n    let args = [...arguments];\n    console.log(args);\n&#125;\n\nes5F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关键字-let\"><a href=\"#关键字-let\" class=\"headerlink\" title=\"关键字 let\"></a>关键字 let</h2><p>描述：ES6定义了<code>let</code>关键字用于声明块级作用域变量</p>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>变量不能重复声明</li>\n<li>块级作用域(全局作用域，函数作用域，eval作用域)</li>\n<li>不存在变量提升</li>\n<li>不影响作用域链</li>\n</ol>\n<h4 id=\"案例场景\"><a href=\"#案例场景\" class=\"headerlink\" title=\"案例场景\"></a>案例场景</h4><ol>\n<li>点击div换色</li>\n</ol>\n<p>现在页面中，有三个div，我们需要添加该功能，点击div时背景颜色变红</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;div点击变色&lt;/title&gt;\n        &lt;style&gt;\n            div&#123;\n                width:100px;\n                height:100px;\n                margin:40px;\n                float:left;\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var divs = document.getElementByTagNames(&#39;div&#39;);\n            for(let i=0;i&lt;divs.length;i++)&#123;\n                divs[i].onClick = function()&#123;\n                    // this.style.background = &#39;pink&#39;;\n                    div[i].style.background = &#39;pink&#39;; // **\n                &#125;\n            &#125;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>如果我们使用var来声明变量，那么其对于的点击事件函数内部就无法访问到与之对应的DOM元素。<br>因为事件函数的执行是异步执行的，而var声明的变量是挂载到全局对象上的，<br>当事件函数开始执行时，其i值为3,就无法访问到在最初注册该事件函数时与之对应的DOM对象</p>\n<p>而let声明因为其块级作用域，可以保留当时i的状态，<br>因此在事件函数中定义是所使用的i保留其当时注册使用的值，也因为上述的代码可以满足我们的要求</p>\n<ol start=\"2\">\n<li>定时器输出</li>\n</ol>\n<pre><code class=\"js\">for(let i=0;i&lt;5;i++)&#123;\n    setTimeout(()=&gt;&#123;\n        console.log(i);\n    &#125;)\n&#125;\n\n// 0,1,2,3,4\nfor(var i=0;i&lt;5;i++)&#123;\n    setTimeout(()=&gt;&#123;\n        console.log(i);\n    &#125;)\n&#125;\n// 5,5,5,5,5\n</code></pre>\n<p>这是一道非常常见的面试题</p>\n<p>在解决该问题之前，我们要清楚定时器里的函数是什么时候进行的：是在我们主线程代码结束后才会执行</p>\n<p>也因此,定时器里的函数执行是在for循环结果后才执行</p>\n<p>那么,为什么两种结果不一样：主要是因为var&amp;let的不同</p>\n<p>let声明的变量在函数使用的时候也会记录它当前的值，<br>也因此let声明的i在函数中被使用，然后被调用输入的结果为0,1,2,3,4</p>\n<p>var声明的变量会挂载在全局对象，<br>函数执行的时候是直接找到了全局对象的i,而此时i的值在循环之后就变成了5，也因此函数执行的输出结果为5,5,5,5,5</p>\n<h2 id=\"关键字-const\"><a href=\"#关键字-const\" class=\"headerlink\" title=\"关键字 const\"></a>关键字 const</h2><p>描述：ES6定义了<code>const</code>关键字用于定义常量</p>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>一定要赋初始值</li>\n<li>一般常量使用大写(潜规则)</li>\n<li>常量的值不能修改</li>\n<li>块级作用域</li>\n<li>对于元素和对象的元素成员修改，不算做对常量的修改，不会报错</li>\n</ol>\n<h2 id=\"变量解构赋值\"><a href=\"#变量解构赋值\" class=\"headerlink\" title=\"变量解构赋值\"></a>变量解构赋值</h2><p>描述：ES6允许按照一定模式从对象和数组提取值，对变量进行赋值</p>\n<h4 id=\"1-数组的解构\"><a href=\"#1-数组的解构\" class=\"headerlink\" title=\"1. 数组的解构\"></a>1. 数组的解构</h4><pre><code class=\"js\">let array = [1,2,3,4];\nconst [one,two,three,four] = array;\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\nconsole.log(four); // 4\n</code></pre>\n<h4 id=\"2-对象的解构\"><a href=\"#2-对象的解构\" class=\"headerlink\" title=\"2. 对象的解构\"></a>2. 对象的解构</h4><pre><code class=\"js\">let person = &#123;\n    name:&#39;zhangsan&#39;,\n    age:24,\n    sayHello:function()&#123;\n        console.log(&#39;hello world&#39;);\n    &#125;\n&#125;\n\nconst &#123; name,age,sayHello &#125; = person;\nconsole.log(name); // &#39;zhangsan&#39;\nconsole.log(age); // 24\nconsole.log(sayHello); // Function sayHello\nsayHello() // hello world\n</code></pre>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>描述：ES6引入新的声明字符串的方式 </p>\n<pre><code class=\"js\">// 1. 声明\nlet str = `I am a string`;\nconsole.log(typeof str); // &#39;string&#39;\n\n// 2. 内容可以直接出现换行符 \nlet htmlCode = `\n                &lt;body&gt;\n                    &lt;h1&gt;hello template string&lt;/h1&gt;\n                &lt;/body&gt;\n                `\n\n// 3. 变量拼接\nlet strValue = &#39;string&#39;;\nlet str = `I am a $&#123;strValue&#125;`;\nconsole.log(str); // I am a string\n</code></pre>\n<h2 id=\"对象的简洁写法\"><a href=\"#对象的简洁写法\" class=\"headerlink\" title=\"对象的简洁写法\"></a>对象的简洁写法</h2><p>描述：ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p>\n<pre><code class=\"js\">let name = &#39;zhangsan&#39;;\nlet age = 24;\n\nlet person = &#123;\n    name,\n    age\n&#125;\n\nconsole.log(person) // &#123;name:&#39;zhangsan&#39;,age:24&#125;\n</code></pre>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>描述：ES6允许使用箭头(&#x3D;&gt;)定义函数</p>\n<pre><code class=\"js\">let fn = () =&gt;&#123;\n    console.log(&#39;hello world&#39;);\n&#125;\n\nfn();\n</code></pre>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>this是静态的，this始终指向函数声明时所在作用域下的this值</li>\n<li>不能作为构造函数实例化对象</li>\n<li>不能使用arguments变量</li>\n<li>箭头函数的简写<ol>\n<li>省略小括号，当形参有且只有一个的时候</li>\n<li>省略花括号，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是函数的返回值</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ol>\n<li>点击div 2s后颜色变红</li>\n</ol>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;箭头函数使用&lt;/title&gt;\n        &lt;style&gt;\n            div&#123;\n                width:100px;\n                height:100px;\n                background:blue;\n                margin:100px\n            &#125;\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id = &quot;test&quot;&gt;&lt;/div&gt;\n        &lt;script&gt;\n            // 获取元素\n            let div = document.getElementById(&#39;test&#39;);\n            // 注册点击事件\n            div.addEventListener(&#39;click&#39;, function () &#123;\n                setTimeout(() =&gt; &#123;\n                    this.style.background = &#39;pink&#39;;\n                &#125;)\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"2\">\n<li>从数据返回偶数的元素</li>\n</ol>\n<pre><code class=\"js\">const array = [1,3,4,5,6,7,9];\n\nconst oddArr = array.filter(item=&gt;item%2===0);\n\nconsole.log(oddArr) // [4,6];\n</code></pre>\n<p>箭头函数<code>适合与this无关的回调</code>(定时器，数组的方法回调)，<code>不适合与this有关的回调</code>(DOM事件，对象的方法)</p>\n<h2 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h2><p>描述：ES6允许给函数参数赋值初始值</p>\n<h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ol>\n<li>形参初始值，具有默认值的参数，一般位置要靠后(潜规则)</li>\n<li>与解构赋值结合</li>\n</ol>\n<pre><code class=\"js\">function fn(a,b,c=10)&#123;\n    console.log(a+b+c);\n&#125;\n\nfn(1,2,3); // 6\n\nfn(1,2); // 13\n\n// -------------------------- // \n\nfunction fn2(&#123;name,age,sex=&#39;man&#39;&#125;)&#123;\n    console.log(`$&#123;name&#125;,$&#123;age&#125;,$&#123;sex&#125;`);\n&#125;\n\nvar person1 = &#123;\n    name:&#39;zhangsan&#39;,\n    age:24\n&#125;;\n\nvar person2 = &#123;\n    name:&#39;baimeigui&#39;,\n    age:24,\n    sex:&#39;woman&#39;\n&#125;;\n\nfn2(person1); // zhangsan,24,man\n\nfn2(person2); // baimeigui,24,woman\n</code></pre>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>描述：ES6引入rest参数，用于获取函数的实参，用来代替arguments</p>\n<p>rest参数必须放在参数的最后</p>\n<pre><code class=\"js\">function es5F()&#123;\n    console.log(arguments);\n&#125;\n\nfunction es6F(...rest)&#123;\n    console.log(rest);\n&#125;\n\nes5F(1,2,3,4,5); // 类数组 [1,2,3,4,5]\n\nes6F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n</code></pre>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>描述：’…’ 扩展运算符能够将数组转换为逗号分割的参数序列</p>\n<ol>\n<li>可以将数组成员分解为一个个的参数序列</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>数组的合并</li>\n</ol>\n<pre><code class=\"js\">var arr1 = [1,2,3];\n\nvar arr2 = [4,5,6];\n\nvar arr = [...arr1,...arr2];\n\nconsole.log(arr);// [1,2,3,4,5,6]\n</code></pre>\n<ol start=\"2\">\n<li>数组的克隆</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,3];\nlet arr2 = [...arr1];\n\nconsole.log(arr2); // [1,2,3]\n\nconsole.log(arr1===arr2); // false\n</code></pre>\n<ol start=\"3\">\n<li>将伪数组转换为真正的数组</li>\n</ol>\n<pre><code class=\"js\">function es5F()&#123;\n    let args = [...arguments];\n    console.log(args);\n&#125;\n\nes5F(1,2,3,4,5); // 真数组 [1,2,3,4,5]\n</code></pre>\n"},{"title":"ES6 语法总结 02","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES","date":"2020-07-13T16:00:00.000Z","comments":0,"description":"ES6语法总结","photos":["https://yanxuan.nosdn.127.net/1c1dc163d7fe8d55fa18bf3df8948797.jpg"],"_content":"\n\n## Symbol\n\n#### 前言\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。\n\n它是JavaScript语言的第七种数据类型，是一种类似字符串的数据类型\n\nSymbol的特点\n1. Symbol的值是唯一的，用来解决命名冲突问题\n2. Symbol值不能与其他数据进行运算（包括自己）\n3. Symbol定义的对象属性不能使用for...in循环遍历，但是可以实体Reflect.ownKeys来获取对象的所有键名\n\n#### 创建Symbol\n\n```js\n// 创建Symbol\nlet s = Symbol();\nconsole.log(s,typeof s); // 'Symbol() symbol'\n\n// Symbol唯一\nlet s1 = Symbol('s');\nlet s2 = Symbol('s');\nconsole.log(s1===s2); // false\n\n// Symbol.for创建\nlet s4 = Symbol.for('ss');\nlet s5 = Symbol.for('ss');\nconsole.log(s4===s5); // true\n```\n\n\n#### 使用Symbol\n\n给一个属性方法未知的对象安全的添加属性和方法\n```js\nlet obj = {...}\n\nlet methods = {\n    up:Symbol(),\n    down:Symbol()\n};\n\nobj[methods.up] = function(){\n    ...\n}\n\nobj[methods.down] = function(){\n    ...\n}\n\n// -------------------- //\nlet youxi = {\n    name:'狼人杀',\n    [Symbol('xixi')]:function(){\n        console.log('嘻嘻')\n    },\n    [Symbol('haha')]:function(){\n        console.log('哈哈')\n    },\n}\n\n```\n\n\n#### 内置Symbol值\n\nES6内置了11个Symbol值，指向语言内部的使用方法\n\n|          属性名           |                             作用                             |\n| :-----------------------: | :----------------------------------------------------------: |\n|    Symbol.hasInstance     | 当其他对象使用instanceof运算符，判断师范为该对象的实例时，会调用这个方法 |\n| Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开 |\n|    Symbol.unscopables     |     该对象指定了使用with关键字，哪些属性会被with环境排除     |\n|       Symbol.match        | 当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 |\n|      Symbol.replace       |      当执行str.replace(myObject)时，返回该方法的返回值       |\n|       Symbol.search       |       当执行str.search(myObject)时，返回该方法的返回值       |\n|       Symbol.split        |       当执行str.split(myObject)时，返回该方法的返回值        |\n|      Symbol.iterator      | 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器 |\n|    Symbol.toPrimitive     | 该对象被转换为原始类型的值时，会调用这个方法，返回该对象对于的原始类型值 |\n|    Symbol.toStringTag     |      在该对象上面调用toString方法时，返回该方法的返回值      |\n|      Symbol.species       |                 创建衍生对象时，会使用该属性                 |\n\n\n```js\n// Symbol.instanceof\n\nclass Person{\n    static [Symbol.hasInstance](params){\n        console.log(params);\n        console.log('我被用来检测了');\n        return false;\n    }\n}\n\nlet o = {};\n\no instanceof Person // {} 我被用来检测了\n\n// Symbol.isConcatSpreadable\nlet arr1 = [1,2,3];\nlet arr2 = [4,5,6];\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,4,5,6]\n\narr2[Symbol.isConcatSpreadable] = false;\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,[4,5,6]]\n```\n\n## 迭代器\n\n#### 认识\n\n迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。\n任何数据结构只要部署Iterator接口，就可以完成遍历操作\n\n1. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要是给for...of消费\n2. ES6内置Iterator的对象\n    1. Array\n    2. Set\n    3. Map\n    4. Arguments\n    5. String\n    6. TypeArray\n    7. NodeList\n3. 工作原理\n    1. 创建一个指针对象，指向当前数据结构的起始位置\n    2. 第一次调用对象的next方法，指针自动指向数据结构的第一个成员\n    3. 接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员\n    4. 每调用next方法返回一个包含value和done属性的对象\n    注：需要自定义遍历数据的时候，要想到迭代器\n\n#### 应用\n\n自定义遍历数据\n```js\n// 需求\n// 遍历下面对象的colors数组,每次遍历返回数组的元素成员 使用for...of遍历\n// 要符合面对对象的思想，我们不能直接对对象的成员进行操作\n\nconst person = {\n    colors:['white','black','yellow'],\n    [Symbol.iterator](){\n        // 索引变量\n        let index = 0;\n        \n        return {\n            next:()=>{\n                return {\n                    if(index<this.colors.length){\n                        const result = {value:this.colors[index],done:false};\n                        index++;\n                        return result;\n                    }\n                    return {value:undefined,done:true}\n                }\n            }\n        };\n    }\n}\n\n\nfor(let c of person){\n    console.log(c);\n}\n\n```\n\n## 生成器\n\n#### 认识\n\n生成器其实就是一个特殊(定义特殊，执行特殊)的函数，是用于处理异步的一种解决方案\n\n而关键字`yield`可以暂停生成器函数的运行\n\n生成器函数执行返回的是一个迭代器对象，用于控制函数的执行过程，此时函数并没有开始执行\n\n生成器函数参数跟普通函数参数相同，而迭代器对象的next方法可以传入参数，用作函数yield关键字的返回值(第2次调用next则next传入的值会给函数第一个yield后面的变量)\n\n生成器函数实例(异步编程)\n\n```js\n// 异步顺序执行定时器\n// 1s(1) --> 2s(2) --> 3s(3) \n\nfunction outputNumberAsync(number) {\n    setTimeout(() => {\n        console.log(number);\n        iterator.next();\n    }, number * 1000)\n}\n\nfunction* gen() {\n    yield outputNumberAsync(1);\n    yield outputNumberAsync(2);\n    yield outputNumberAsync(3);\n}\n\nconst iterator = gen();\n\niterator.next(); // 让函数开始执行\n```\n\n```js\n// 模拟获取 用户数据 订单数据 商品数据\nfunction getUsers(){\n    setTimeout(()=>{\n        let data = '用户数据';\n        iterator.next(data);\n    },1000);\n};\n\nfunction getOrders(){\n    setTimeout(()=>{\n        let data = '订单数据';\n        iterator.next(data);\n    },1000)\n}\n\nfunction getGoods(){\n    setTimeout(()=>{\n        let data = '商品数据';\n        iterator.next(data);\n    },1000)\n}\n\nfunction *gen(){\n    let users = yield getUsers();\n    console.log(users);\n    let orders = yield getOrders();\n    console.log(orders);\n    let goods =yield getGoods();\n    console.log(goods);\n}\n```\n\n\n## Promise\n\n#### 认识\n\nPromise是ES6用于处理异步编程的新的解决方案，语法上Promise是一个构造函数，用于封装异步操作并可以获取其成功获或者失败的结果\n\nPromise的出现主要是为了解决回调函数处理异步操作的两个巨大的缺点\n\n1. 回调地狱：代码书写十分令人难以理解\n2. 控制返回：异步操作所对应的回调函数的执行并不是由我们控制，而是有第三方控制。即我们发出异步操作，并且指定异步完成之后所要执行的函数，但是函数的执行我们无法控制\n\n也因此，在Promise中就出现了反控制反转(控制回调函数的执行时机)\n\n#### 应用\n\n1. 进行ajax请求\n\n```js\n// 接口 https://api.github.com/\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\nlet p = new Promise((resolve, reject) => {\n    sendRequest('https://api.github.com/', resolve, reject);\n})\n\np.then(\n    value => console.log(value),\n    reason => console.log(reason)\n)\n```\n\n2. 同时进行多个ajax请求\n\n```js\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\nlet urls = ['url1','url2','url3'];\n\nconst promises = urls.map(url=>new Promise((resolve, reject) => {\n    sendRequest('https://api.github.com/', resolve, reject);\n}));\n\n\n// Promise.all: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\nPromise.all(promises).then(\n    values=>console.log(values),\n    reason=>console.log(reason)\n)\n\n```\n\n3. 顺序进行ajax请求\n\n```js\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\n\nlet urls = ['url1','url2','url3'];\n\nnew Promise((resolve,reject)=>{\n    sendRequest('url1',resolve,reject);\n}).then(\n    value=>{\n        console.log(value);\n        return new Promise((resolve,reject)=>{\n            sendRequest('url2',resolve,reject);\n        })\n    }\n).then(\n    value=>{\n        console.log(value);\n        return new Promise((resolve,reject)=>{\n            sendRequest('url3',resolve,reject);\n        })\n    }\n).catch(reason=>{\n    console.log(reason);\n})\n\n\n// es7 async/await\nconst urls = ['url1','url2','url3']\n\nasync f(urls){\n    let values = [];\n    for(let i=0;i<urls.length;i++){\n        try{\n            const value = await new Promise((resolve,reject)=>{\n                sendRequest(urls[i],resolve,reject);\n            })\n            values.push(value);\n        }catch(e){\n            throw e;\n        }\n    }\n}\n\nf(urls).then(\n    values=>{\n        console.log(values);\n    },\n    reason=>{\n        console.log(reason);\n    }\n)\n```","source":"_posts/前端/ES总结/ES6 语法总结 02.md","raw":"---\ntitle: ES6 语法总结 02\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - javascript\nkeywords: ES\ndate: 2020-07-14 \ncomments: false\ndescription: ES6语法总结\nphotos: https://yanxuan.nosdn.127.net/1c1dc163d7fe8d55fa18bf3df8948797.jpg\n---\n\n\n## Symbol\n\n#### 前言\n\nES6引入了一种新的原始数据类型Symbol，表示独一无二的值。\n\n它是JavaScript语言的第七种数据类型，是一种类似字符串的数据类型\n\nSymbol的特点\n1. Symbol的值是唯一的，用来解决命名冲突问题\n2. Symbol值不能与其他数据进行运算（包括自己）\n3. Symbol定义的对象属性不能使用for...in循环遍历，但是可以实体Reflect.ownKeys来获取对象的所有键名\n\n#### 创建Symbol\n\n```js\n// 创建Symbol\nlet s = Symbol();\nconsole.log(s,typeof s); // 'Symbol() symbol'\n\n// Symbol唯一\nlet s1 = Symbol('s');\nlet s2 = Symbol('s');\nconsole.log(s1===s2); // false\n\n// Symbol.for创建\nlet s4 = Symbol.for('ss');\nlet s5 = Symbol.for('ss');\nconsole.log(s4===s5); // true\n```\n\n\n#### 使用Symbol\n\n给一个属性方法未知的对象安全的添加属性和方法\n```js\nlet obj = {...}\n\nlet methods = {\n    up:Symbol(),\n    down:Symbol()\n};\n\nobj[methods.up] = function(){\n    ...\n}\n\nobj[methods.down] = function(){\n    ...\n}\n\n// -------------------- //\nlet youxi = {\n    name:'狼人杀',\n    [Symbol('xixi')]:function(){\n        console.log('嘻嘻')\n    },\n    [Symbol('haha')]:function(){\n        console.log('哈哈')\n    },\n}\n\n```\n\n\n#### 内置Symbol值\n\nES6内置了11个Symbol值，指向语言内部的使用方法\n\n|          属性名           |                             作用                             |\n| :-----------------------: | :----------------------------------------------------------: |\n|    Symbol.hasInstance     | 当其他对象使用instanceof运算符，判断师范为该对象的实例时，会调用这个方法 |\n| Symbol.isConcatSpreadable | 对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开 |\n|    Symbol.unscopables     |     该对象指定了使用with关键字，哪些属性会被with环境排除     |\n|       Symbol.match        | 当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 |\n|      Symbol.replace       |      当执行str.replace(myObject)时，返回该方法的返回值       |\n|       Symbol.search       |       当执行str.search(myObject)时，返回该方法的返回值       |\n|       Symbol.split        |       当执行str.split(myObject)时，返回该方法的返回值        |\n|      Symbol.iterator      | 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器 |\n|    Symbol.toPrimitive     | 该对象被转换为原始类型的值时，会调用这个方法，返回该对象对于的原始类型值 |\n|    Symbol.toStringTag     |      在该对象上面调用toString方法时，返回该方法的返回值      |\n|      Symbol.species       |                 创建衍生对象时，会使用该属性                 |\n\n\n```js\n// Symbol.instanceof\n\nclass Person{\n    static [Symbol.hasInstance](params){\n        console.log(params);\n        console.log('我被用来检测了');\n        return false;\n    }\n}\n\nlet o = {};\n\no instanceof Person // {} 我被用来检测了\n\n// Symbol.isConcatSpreadable\nlet arr1 = [1,2,3];\nlet arr2 = [4,5,6];\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,4,5,6]\n\narr2[Symbol.isConcatSpreadable] = false;\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,[4,5,6]]\n```\n\n## 迭代器\n\n#### 认识\n\n迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。\n任何数据结构只要部署Iterator接口，就可以完成遍历操作\n\n1. ES6创造了一种新的遍历命令for...of循环，Iterator接口主要是给for...of消费\n2. ES6内置Iterator的对象\n    1. Array\n    2. Set\n    3. Map\n    4. Arguments\n    5. String\n    6. TypeArray\n    7. NodeList\n3. 工作原理\n    1. 创建一个指针对象，指向当前数据结构的起始位置\n    2. 第一次调用对象的next方法，指针自动指向数据结构的第一个成员\n    3. 接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员\n    4. 每调用next方法返回一个包含value和done属性的对象\n    注：需要自定义遍历数据的时候，要想到迭代器\n\n#### 应用\n\n自定义遍历数据\n```js\n// 需求\n// 遍历下面对象的colors数组,每次遍历返回数组的元素成员 使用for...of遍历\n// 要符合面对对象的思想，我们不能直接对对象的成员进行操作\n\nconst person = {\n    colors:['white','black','yellow'],\n    [Symbol.iterator](){\n        // 索引变量\n        let index = 0;\n        \n        return {\n            next:()=>{\n                return {\n                    if(index<this.colors.length){\n                        const result = {value:this.colors[index],done:false};\n                        index++;\n                        return result;\n                    }\n                    return {value:undefined,done:true}\n                }\n            }\n        };\n    }\n}\n\n\nfor(let c of person){\n    console.log(c);\n}\n\n```\n\n## 生成器\n\n#### 认识\n\n生成器其实就是一个特殊(定义特殊，执行特殊)的函数，是用于处理异步的一种解决方案\n\n而关键字`yield`可以暂停生成器函数的运行\n\n生成器函数执行返回的是一个迭代器对象，用于控制函数的执行过程，此时函数并没有开始执行\n\n生成器函数参数跟普通函数参数相同，而迭代器对象的next方法可以传入参数，用作函数yield关键字的返回值(第2次调用next则next传入的值会给函数第一个yield后面的变量)\n\n生成器函数实例(异步编程)\n\n```js\n// 异步顺序执行定时器\n// 1s(1) --> 2s(2) --> 3s(3) \n\nfunction outputNumberAsync(number) {\n    setTimeout(() => {\n        console.log(number);\n        iterator.next();\n    }, number * 1000)\n}\n\nfunction* gen() {\n    yield outputNumberAsync(1);\n    yield outputNumberAsync(2);\n    yield outputNumberAsync(3);\n}\n\nconst iterator = gen();\n\niterator.next(); // 让函数开始执行\n```\n\n```js\n// 模拟获取 用户数据 订单数据 商品数据\nfunction getUsers(){\n    setTimeout(()=>{\n        let data = '用户数据';\n        iterator.next(data);\n    },1000);\n};\n\nfunction getOrders(){\n    setTimeout(()=>{\n        let data = '订单数据';\n        iterator.next(data);\n    },1000)\n}\n\nfunction getGoods(){\n    setTimeout(()=>{\n        let data = '商品数据';\n        iterator.next(data);\n    },1000)\n}\n\nfunction *gen(){\n    let users = yield getUsers();\n    console.log(users);\n    let orders = yield getOrders();\n    console.log(orders);\n    let goods =yield getGoods();\n    console.log(goods);\n}\n```\n\n\n## Promise\n\n#### 认识\n\nPromise是ES6用于处理异步编程的新的解决方案，语法上Promise是一个构造函数，用于封装异步操作并可以获取其成功获或者失败的结果\n\nPromise的出现主要是为了解决回调函数处理异步操作的两个巨大的缺点\n\n1. 回调地狱：代码书写十分令人难以理解\n2. 控制返回：异步操作所对应的回调函数的执行并不是由我们控制，而是有第三方控制。即我们发出异步操作，并且指定异步完成之后所要执行的函数，但是函数的执行我们无法控制\n\n也因此，在Promise中就出现了反控制反转(控制回调函数的执行时机)\n\n#### 应用\n\n1. 进行ajax请求\n\n```js\n// 接口 https://api.github.com/\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\nlet p = new Promise((resolve, reject) => {\n    sendRequest('https://api.github.com/', resolve, reject);\n})\n\np.then(\n    value => console.log(value),\n    reason => console.log(reason)\n)\n```\n\n2. 同时进行多个ajax请求\n\n```js\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\nlet urls = ['url1','url2','url3'];\n\nconst promises = urls.map(url=>new Promise((resolve, reject) => {\n    sendRequest('https://api.github.com/', resolve, reject);\n}));\n\n\n// Promise.all: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\nPromise.all(promises).then(\n    values=>console.log(values),\n    reason=>console.log(reason)\n)\n\n```\n\n3. 顺序进行ajax请求\n\n```js\nfunction sendRequest(url, resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"get\", url);\n    xhr.onreadystatechange = function () {\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n            resolve(xhr.responseText);\n        } else {\n            reject('something error');\n        }\n    }\n}\n\n\nlet urls = ['url1','url2','url3'];\n\nnew Promise((resolve,reject)=>{\n    sendRequest('url1',resolve,reject);\n}).then(\n    value=>{\n        console.log(value);\n        return new Promise((resolve,reject)=>{\n            sendRequest('url2',resolve,reject);\n        })\n    }\n).then(\n    value=>{\n        console.log(value);\n        return new Promise((resolve,reject)=>{\n            sendRequest('url3',resolve,reject);\n        })\n    }\n).catch(reason=>{\n    console.log(reason);\n})\n\n\n// es7 async/await\nconst urls = ['url1','url2','url3']\n\nasync f(urls){\n    let values = [];\n    for(let i=0;i<urls.length;i++){\n        try{\n            const value = await new Promise((resolve,reject)=>{\n                sendRequest(urls[i],resolve,reject);\n            })\n            values.push(value);\n        }catch(e){\n            throw e;\n        }\n    }\n}\n\nf(urls).then(\n    values=>{\n        console.log(values);\n    },\n    reason=>{\n        console.log(reason);\n    }\n)\n```","slug":"前端/ES总结/ES6 语法总结 02","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t2w001o2h173zywcov3","content":"<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。</p>\n<p>它是JavaScript语言的第七种数据类型，是一种类似字符串的数据类型</p>\n<p>Symbol的特点</p>\n<ol>\n<li>Symbol的值是唯一的，用来解决命名冲突问题</li>\n<li>Symbol值不能与其他数据进行运算（包括自己）</li>\n<li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以实体Reflect.ownKeys来获取对象的所有键名</li>\n</ol>\n<h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><pre><code class=\"js\">// 创建Symbol\nlet s = Symbol();\nconsole.log(s,typeof s); // &#39;Symbol() symbol&#39;\n\n// Symbol唯一\nlet s1 = Symbol(&#39;s&#39;);\nlet s2 = Symbol(&#39;s&#39;);\nconsole.log(s1===s2); // false\n\n// Symbol.for创建\nlet s4 = Symbol.for(&#39;ss&#39;);\nlet s5 = Symbol.for(&#39;ss&#39;);\nconsole.log(s4===s5); // true\n</code></pre>\n<h4 id=\"使用Symbol\"><a href=\"#使用Symbol\" class=\"headerlink\" title=\"使用Symbol\"></a>使用Symbol</h4><p>给一个属性方法未知的对象安全的添加属性和方法</p>\n<pre><code class=\"js\">let obj = &#123;...&#125;\n\nlet methods = &#123;\n    up:Symbol(),\n    down:Symbol()\n&#125;;\n\nobj[methods.up] = function()&#123;\n    ...\n&#125;\n\nobj[methods.down] = function()&#123;\n    ...\n&#125;\n\n// -------------------- //\nlet youxi = &#123;\n    name:&#39;狼人杀&#39;,\n    [Symbol(&#39;xixi&#39;)]:function()&#123;\n        console.log(&#39;嘻嘻&#39;)\n    &#125;,\n    [Symbol(&#39;haha&#39;)]:function()&#123;\n        console.log(&#39;哈哈&#39;)\n    &#125;,\n&#125;\n</code></pre>\n<h4 id=\"内置Symbol值\"><a href=\"#内置Symbol值\" class=\"headerlink\" title=\"内置Symbol值\"></a>内置Symbol值</h4><p>ES6内置了11个Symbol值，指向语言内部的使用方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Symbol.hasInstance</td>\n<td align=\"center\">当其他对象使用instanceof运算符，判断师范为该对象的实例时，会调用这个方法</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.isConcatSpreadable</td>\n<td align=\"center\">对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.unscopables</td>\n<td align=\"center\">该对象指定了使用with关键字，哪些属性会被with环境排除</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.match</td>\n<td align=\"center\">当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.replace</td>\n<td align=\"center\">当执行str.replace(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.search</td>\n<td align=\"center\">当执行str.search(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.split</td>\n<td align=\"center\">当执行str.split(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.iterator</td>\n<td align=\"center\">对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.toPrimitive</td>\n<td align=\"center\">该对象被转换为原始类型的值时，会调用这个方法，返回该对象对于的原始类型值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.toStringTag</td>\n<td align=\"center\">在该对象上面调用toString方法时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.species</td>\n<td align=\"center\">创建衍生对象时，会使用该属性</td>\n</tr>\n</tbody></table>\n<pre><code class=\"js\">// Symbol.instanceof\n\nclass Person&#123;\n    static [Symbol.hasInstance](params)&#123;\n        console.log(params);\n        console.log(&#39;我被用来检测了&#39;);\n        return false;\n    &#125;\n&#125;\n\nlet o = &#123;&#125;;\n\no instanceof Person // &#123;&#125; 我被用来检测了\n\n// Symbol.isConcatSpreadable\nlet arr1 = [1,2,3];\nlet arr2 = [4,5,6];\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,4,5,6]\n\narr2[Symbol.isConcatSpreadable] = false;\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,[4,5,6]]\n</code></pre>\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><h4 id=\"认识\"><a href=\"#认识\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。<br>任何数据结构只要部署Iterator接口，就可以完成遍历操作</p>\n<ol>\n<li>ES6创造了一种新的遍历命令for…of循环，Iterator接口主要是给for…of消费</li>\n<li>ES6内置Iterator的对象<ol>\n<li>Array</li>\n<li>Set</li>\n<li>Map</li>\n<li>Arguments</li>\n<li>String</li>\n<li>TypeArray</li>\n<li>NodeList</li>\n</ol>\n</li>\n<li>工作原理<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置</li>\n<li>第一次调用对象的next方法，指针自动指向数据结构的第一个成员</li>\n<li>接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员</li>\n<li>每调用next方法返回一个包含value和done属性的对象<br> 注：需要自定义遍历数据的时候，要想到迭代器</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>自定义遍历数据</p>\n<pre><code class=\"js\">// 需求\n// 遍历下面对象的colors数组,每次遍历返回数组的元素成员 使用for...of遍历\n// 要符合面对对象的思想，我们不能直接对对象的成员进行操作\n\nconst person = &#123;\n    colors:[&#39;white&#39;,&#39;black&#39;,&#39;yellow&#39;],\n    [Symbol.iterator]()&#123;\n        // 索引变量\n        let index = 0;\n        \n        return &#123;\n            next:()=&gt;&#123;\n                return &#123;\n                    if(index&lt;this.colors.length)&#123;\n                        const result = &#123;value:this.colors[index],done:false&#125;;\n                        index++;\n                        return result;\n                    &#125;\n                    return &#123;value:undefined,done:true&#125;\n                &#125;\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n\nfor(let c of person)&#123;\n    console.log(c);\n&#125;\n</code></pre>\n<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><h4 id=\"认识-1\"><a href=\"#认识-1\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>生成器其实就是一个特殊(定义特殊，执行特殊)的函数，是用于处理异步的一种解决方案</p>\n<p>而关键字<code>yield</code>可以暂停生成器函数的运行</p>\n<p>生成器函数执行返回的是一个迭代器对象，用于控制函数的执行过程，此时函数并没有开始执行</p>\n<p>生成器函数参数跟普通函数参数相同，而迭代器对象的next方法可以传入参数，用作函数yield关键字的返回值(第2次调用next则next传入的值会给函数第一个yield后面的变量)</p>\n<p>生成器函数实例(异步编程)</p>\n<pre><code class=\"js\">// 异步顺序执行定时器\n// 1s(1) --&gt; 2s(2) --&gt; 3s(3) \n\nfunction outputNumberAsync(number) &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(number);\n        iterator.next();\n    &#125;, number * 1000)\n&#125;\n\nfunction* gen() &#123;\n    yield outputNumberAsync(1);\n    yield outputNumberAsync(2);\n    yield outputNumberAsync(3);\n&#125;\n\nconst iterator = gen();\n\niterator.next(); // 让函数开始执行\n</code></pre>\n<pre><code class=\"js\">// 模拟获取 用户数据 订单数据 商品数据\nfunction getUsers()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;用户数据&#39;;\n        iterator.next(data);\n    &#125;,1000);\n&#125;;\n\nfunction getOrders()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;订单数据&#39;;\n        iterator.next(data);\n    &#125;,1000)\n&#125;\n\nfunction getGoods()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;商品数据&#39;;\n        iterator.next(data);\n    &#125;,1000)\n&#125;\n\nfunction *gen()&#123;\n    let users = yield getUsers();\n    console.log(users);\n    let orders = yield getOrders();\n    console.log(orders);\n    let goods =yield getGoods();\n    console.log(goods);\n&#125;\n</code></pre>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h4 id=\"认识-2\"><a href=\"#认识-2\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>Promise是ES6用于处理异步编程的新的解决方案，语法上Promise是一个构造函数，用于封装异步操作并可以获取其成功获或者失败的结果</p>\n<p>Promise的出现主要是为了解决回调函数处理异步操作的两个巨大的缺点</p>\n<ol>\n<li>回调地狱：代码书写十分令人难以理解</li>\n<li>控制返回：异步操作所对应的回调函数的执行并不是由我们控制，而是有第三方控制。即我们发出异步操作，并且指定异步完成之后所要执行的函数，但是函数的执行我们无法控制</li>\n</ol>\n<p>也因此，在Promise中就出现了反控制反转(控制回调函数的执行时机)</p>\n<h4 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>进行ajax请求</li>\n</ol>\n<pre><code class=\"js\">// 接口 https://api.github.com/\nfunction sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\nlet p = new Promise((resolve, reject) =&gt; &#123;\n    sendRequest(&#39;https://api.github.com/&#39;, resolve, reject);\n&#125;)\n\np.then(\n    value =&gt; console.log(value),\n    reason =&gt; console.log(reason)\n)\n</code></pre>\n<ol start=\"2\">\n<li>同时进行多个ajax请求</li>\n</ol>\n<pre><code class=\"js\">function sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\nlet urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;];\n\nconst promises = urls.map(url=&gt;new Promise((resolve, reject) =&gt; &#123;\n    sendRequest(&#39;https://api.github.com/&#39;, resolve, reject);\n&#125;));\n\n\n// Promise.all: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\nPromise.all(promises).then(\n    values=&gt;console.log(values),\n    reason=&gt;console.log(reason)\n)\n</code></pre>\n<ol start=\"3\">\n<li>顺序进行ajax请求</li>\n</ol>\n<pre><code class=\"js\">function sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\n\nlet urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;];\n\nnew Promise((resolve,reject)=&gt;&#123;\n    sendRequest(&#39;url1&#39;,resolve,reject);\n&#125;).then(\n    value=&gt;&#123;\n        console.log(value);\n        return new Promise((resolve,reject)=&gt;&#123;\n            sendRequest(&#39;url2&#39;,resolve,reject);\n        &#125;)\n    &#125;\n).then(\n    value=&gt;&#123;\n        console.log(value);\n        return new Promise((resolve,reject)=&gt;&#123;\n            sendRequest(&#39;url3&#39;,resolve,reject);\n        &#125;)\n    &#125;\n).catch(reason=&gt;&#123;\n    console.log(reason);\n&#125;)\n\n\n// es7 async/await\nconst urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;]\n\nasync f(urls)&#123;\n    let values = [];\n    for(let i=0;i&lt;urls.length;i++)&#123;\n        try&#123;\n            const value = await new Promise((resolve,reject)=&gt;&#123;\n                sendRequest(urls[i],resolve,reject);\n            &#125;)\n            values.push(value);\n        &#125;catch(e)&#123;\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\nf(urls).then(\n    values=&gt;&#123;\n        console.log(values);\n    &#125;,\n    reason=&gt;&#123;\n        console.log(reason);\n    &#125;\n)\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。</p>\n<p>它是JavaScript语言的第七种数据类型，是一种类似字符串的数据类型</p>\n<p>Symbol的特点</p>\n<ol>\n<li>Symbol的值是唯一的，用来解决命名冲突问题</li>\n<li>Symbol值不能与其他数据进行运算（包括自己）</li>\n<li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以实体Reflect.ownKeys来获取对象的所有键名</li>\n</ol>\n<h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><pre><code class=\"js\">// 创建Symbol\nlet s = Symbol();\nconsole.log(s,typeof s); // &#39;Symbol() symbol&#39;\n\n// Symbol唯一\nlet s1 = Symbol(&#39;s&#39;);\nlet s2 = Symbol(&#39;s&#39;);\nconsole.log(s1===s2); // false\n\n// Symbol.for创建\nlet s4 = Symbol.for(&#39;ss&#39;);\nlet s5 = Symbol.for(&#39;ss&#39;);\nconsole.log(s4===s5); // true\n</code></pre>\n<h4 id=\"使用Symbol\"><a href=\"#使用Symbol\" class=\"headerlink\" title=\"使用Symbol\"></a>使用Symbol</h4><p>给一个属性方法未知的对象安全的添加属性和方法</p>\n<pre><code class=\"js\">let obj = &#123;...&#125;\n\nlet methods = &#123;\n    up:Symbol(),\n    down:Symbol()\n&#125;;\n\nobj[methods.up] = function()&#123;\n    ...\n&#125;\n\nobj[methods.down] = function()&#123;\n    ...\n&#125;\n\n// -------------------- //\nlet youxi = &#123;\n    name:&#39;狼人杀&#39;,\n    [Symbol(&#39;xixi&#39;)]:function()&#123;\n        console.log(&#39;嘻嘻&#39;)\n    &#125;,\n    [Symbol(&#39;haha&#39;)]:function()&#123;\n        console.log(&#39;哈哈&#39;)\n    &#125;,\n&#125;\n</code></pre>\n<h4 id=\"内置Symbol值\"><a href=\"#内置Symbol值\" class=\"headerlink\" title=\"内置Symbol值\"></a>内置Symbol值</h4><p>ES6内置了11个Symbol值，指向语言内部的使用方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Symbol.hasInstance</td>\n<td align=\"center\">当其他对象使用instanceof运算符，判断师范为该对象的实例时，会调用这个方法</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.isConcatSpreadable</td>\n<td align=\"center\">对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.unscopables</td>\n<td align=\"center\">该对象指定了使用with关键字，哪些属性会被with环境排除</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.match</td>\n<td align=\"center\">当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.replace</td>\n<td align=\"center\">当执行str.replace(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.search</td>\n<td align=\"center\">当执行str.search(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.split</td>\n<td align=\"center\">当执行str.split(myObject)时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.iterator</td>\n<td align=\"center\">对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.toPrimitive</td>\n<td align=\"center\">该对象被转换为原始类型的值时，会调用这个方法，返回该对象对于的原始类型值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.toStringTag</td>\n<td align=\"center\">在该对象上面调用toString方法时，返回该方法的返回值</td>\n</tr>\n<tr>\n<td align=\"center\">Symbol.species</td>\n<td align=\"center\">创建衍生对象时，会使用该属性</td>\n</tr>\n</tbody></table>\n<pre><code class=\"js\">// Symbol.instanceof\n\nclass Person&#123;\n    static [Symbol.hasInstance](params)&#123;\n        console.log(params);\n        console.log(&#39;我被用来检测了&#39;);\n        return false;\n    &#125;\n&#125;\n\nlet o = &#123;&#125;;\n\no instanceof Person // &#123;&#125; 我被用来检测了\n\n// Symbol.isConcatSpreadable\nlet arr1 = [1,2,3];\nlet arr2 = [4,5,6];\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,4,5,6]\n\narr2[Symbol.isConcatSpreadable] = false;\n\nconsole.log(arr1.concat(arr2)); // [1,2,3,[4,5,6]]\n</code></pre>\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><h4 id=\"认识\"><a href=\"#认识\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。<br>任何数据结构只要部署Iterator接口，就可以完成遍历操作</p>\n<ol>\n<li>ES6创造了一种新的遍历命令for…of循环，Iterator接口主要是给for…of消费</li>\n<li>ES6内置Iterator的对象<ol>\n<li>Array</li>\n<li>Set</li>\n<li>Map</li>\n<li>Arguments</li>\n<li>String</li>\n<li>TypeArray</li>\n<li>NodeList</li>\n</ol>\n</li>\n<li>工作原理<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置</li>\n<li>第一次调用对象的next方法，指针自动指向数据结构的第一个成员</li>\n<li>接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员</li>\n<li>每调用next方法返回一个包含value和done属性的对象<br> 注：需要自定义遍历数据的时候，要想到迭代器</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>自定义遍历数据</p>\n<pre><code class=\"js\">// 需求\n// 遍历下面对象的colors数组,每次遍历返回数组的元素成员 使用for...of遍历\n// 要符合面对对象的思想，我们不能直接对对象的成员进行操作\n\nconst person = &#123;\n    colors:[&#39;white&#39;,&#39;black&#39;,&#39;yellow&#39;],\n    [Symbol.iterator]()&#123;\n        // 索引变量\n        let index = 0;\n        \n        return &#123;\n            next:()=&gt;&#123;\n                return &#123;\n                    if(index&lt;this.colors.length)&#123;\n                        const result = &#123;value:this.colors[index],done:false&#125;;\n                        index++;\n                        return result;\n                    &#125;\n                    return &#123;value:undefined,done:true&#125;\n                &#125;\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\n\nfor(let c of person)&#123;\n    console.log(c);\n&#125;\n</code></pre>\n<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><h4 id=\"认识-1\"><a href=\"#认识-1\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>生成器其实就是一个特殊(定义特殊，执行特殊)的函数，是用于处理异步的一种解决方案</p>\n<p>而关键字<code>yield</code>可以暂停生成器函数的运行</p>\n<p>生成器函数执行返回的是一个迭代器对象，用于控制函数的执行过程，此时函数并没有开始执行</p>\n<p>生成器函数参数跟普通函数参数相同，而迭代器对象的next方法可以传入参数，用作函数yield关键字的返回值(第2次调用next则next传入的值会给函数第一个yield后面的变量)</p>\n<p>生成器函数实例(异步编程)</p>\n<pre><code class=\"js\">// 异步顺序执行定时器\n// 1s(1) --&gt; 2s(2) --&gt; 3s(3) \n\nfunction outputNumberAsync(number) &#123;\n    setTimeout(() =&gt; &#123;\n        console.log(number);\n        iterator.next();\n    &#125;, number * 1000)\n&#125;\n\nfunction* gen() &#123;\n    yield outputNumberAsync(1);\n    yield outputNumberAsync(2);\n    yield outputNumberAsync(3);\n&#125;\n\nconst iterator = gen();\n\niterator.next(); // 让函数开始执行\n</code></pre>\n<pre><code class=\"js\">// 模拟获取 用户数据 订单数据 商品数据\nfunction getUsers()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;用户数据&#39;;\n        iterator.next(data);\n    &#125;,1000);\n&#125;;\n\nfunction getOrders()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;订单数据&#39;;\n        iterator.next(data);\n    &#125;,1000)\n&#125;\n\nfunction getGoods()&#123;\n    setTimeout(()=&gt;&#123;\n        let data = &#39;商品数据&#39;;\n        iterator.next(data);\n    &#125;,1000)\n&#125;\n\nfunction *gen()&#123;\n    let users = yield getUsers();\n    console.log(users);\n    let orders = yield getOrders();\n    console.log(orders);\n    let goods =yield getGoods();\n    console.log(goods);\n&#125;\n</code></pre>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h4 id=\"认识-2\"><a href=\"#认识-2\" class=\"headerlink\" title=\"认识\"></a>认识</h4><p>Promise是ES6用于处理异步编程的新的解决方案，语法上Promise是一个构造函数，用于封装异步操作并可以获取其成功获或者失败的结果</p>\n<p>Promise的出现主要是为了解决回调函数处理异步操作的两个巨大的缺点</p>\n<ol>\n<li>回调地狱：代码书写十分令人难以理解</li>\n<li>控制返回：异步操作所对应的回调函数的执行并不是由我们控制，而是有第三方控制。即我们发出异步操作，并且指定异步完成之后所要执行的函数，但是函数的执行我们无法控制</li>\n</ol>\n<p>也因此，在Promise中就出现了反控制反转(控制回调函数的执行时机)</p>\n<h4 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>进行ajax请求</li>\n</ol>\n<pre><code class=\"js\">// 接口 https://api.github.com/\nfunction sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\nlet p = new Promise((resolve, reject) =&gt; &#123;\n    sendRequest(&#39;https://api.github.com/&#39;, resolve, reject);\n&#125;)\n\np.then(\n    value =&gt; console.log(value),\n    reason =&gt; console.log(reason)\n)\n</code></pre>\n<ol start=\"2\">\n<li>同时进行多个ajax请求</li>\n</ol>\n<pre><code class=\"js\">function sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\nlet urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;];\n\nconst promises = urls.map(url=&gt;new Promise((resolve, reject) =&gt; &#123;\n    sendRequest(&#39;https://api.github.com/&#39;, resolve, reject);\n&#125;));\n\n\n// Promise.all: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\nPromise.all(promises).then(\n    values=&gt;console.log(values),\n    reason=&gt;console.log(reason)\n)\n</code></pre>\n<ol start=\"3\">\n<li>顺序进行ajax请求</li>\n</ol>\n<pre><code class=\"js\">function sendRequest(url, resolve, reject) &#123;\n    let xhr = new XMLHttpRequest();\n    xhr.open(&quot;get&quot;, url);\n    xhr.onreadystatechange = function () &#123;\n        console.log(xhr);\n        if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;\n            resolve(xhr.responseText);\n        &#125; else &#123;\n            reject(&#39;something error&#39;);\n        &#125;\n    &#125;\n&#125;\n\n\nlet urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;];\n\nnew Promise((resolve,reject)=&gt;&#123;\n    sendRequest(&#39;url1&#39;,resolve,reject);\n&#125;).then(\n    value=&gt;&#123;\n        console.log(value);\n        return new Promise((resolve,reject)=&gt;&#123;\n            sendRequest(&#39;url2&#39;,resolve,reject);\n        &#125;)\n    &#125;\n).then(\n    value=&gt;&#123;\n        console.log(value);\n        return new Promise((resolve,reject)=&gt;&#123;\n            sendRequest(&#39;url3&#39;,resolve,reject);\n        &#125;)\n    &#125;\n).catch(reason=&gt;&#123;\n    console.log(reason);\n&#125;)\n\n\n// es7 async/await\nconst urls = [&#39;url1&#39;,&#39;url2&#39;,&#39;url3&#39;]\n\nasync f(urls)&#123;\n    let values = [];\n    for(let i=0;i&lt;urls.length;i++)&#123;\n        try&#123;\n            const value = await new Promise((resolve,reject)=&gt;&#123;\n                sendRequest(urls[i],resolve,reject);\n            &#125;)\n            values.push(value);\n        &#125;catch(e)&#123;\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\nf(urls).then(\n    values=&gt;&#123;\n        console.log(values);\n    &#125;,\n    reason=&gt;&#123;\n        console.log(reason);\n    &#125;\n)\n</code></pre>\n"},{"title":"ES6 语法总结 03","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"ES","date":"2020-07-16T16:00:00.000Z","comments":0,"description":"ES6语法总结","photos":["https://ae01.alicdn.com/kf/Heca4a9627eb34f6b8099401eab7fb012Z.jpg"],"_content":"\n\n\n## Set\n\nES6提供新的数据结果Set,该数据结构的特点就是其内部不会存在重复的元素，类似于数组，成员的值都是唯一的\n\n集合实现了iterator接口，所以可以使用扩展运算符和for...of进行遍历\n\n\n#### 属性方法\n1. size 返回集合的元素个数\n2. add  增加啊一个元素，返回当前集合\n3. delete   删除元素，返回boolean值\n4. has  检测集合中是否包含某个元素，返回boolean值\n5. clear 清空集合\n\n#### 应用\n\n1. 数组去重\n\n```js\nlet test = [1,2,2,3,4,5,6,6];\nlet result = [...new Set(test)];\nconsole.log(result); // [1,2,3,4,5,6]\n```\n2. 交集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5];\nlet arr2 = [2,2,3,3,4,4];\nlet result = [...new Set(arr1)].filter(item=>new Set(arr2).has(item));\nconsole.log(result); // [2,3,4]\n```\n3. 并集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet union = [...new Set([...arr1,...arr2])];\nconsole.log(union); // [1,2,3,4,5,7,6,10];\n```\n4. 差集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet diff = [...new Set(arr1)].filter(item=>!new Set(arr2).has(item));\nconsole.log(diff); // [1,5,7,6,10];\n```\n\n## Map\n\nES6提供了Map数据结构。它类似于对象，也是键值对的几个。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n\nMap也实现了iterator接口，所以可以使用扩展运算符和for...of进行遍历\n\n#### 属性方法\n1. size 返回Map的元素个数\n2. set  增加一个新的元素，返回当前的Map\n3. get  返回键名对象的键值\n4. has  检测Map中是否包含某个元素，返回boolean值\n5. clear    清空Map,返回undefined","source":"_posts/前端/ES总结/ES6 语法总结 03.md","raw":"---\ntitle: ES6 语法总结 03\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - javascript\nkeywords: ES\ndate: 2020-07-17 \ncomments: false\ndescription: ES6语法总结\nphotos: https://ae01.alicdn.com/kf/Heca4a9627eb34f6b8099401eab7fb012Z.jpg\n---\n\n\n\n## Set\n\nES6提供新的数据结果Set,该数据结构的特点就是其内部不会存在重复的元素，类似于数组，成员的值都是唯一的\n\n集合实现了iterator接口，所以可以使用扩展运算符和for...of进行遍历\n\n\n#### 属性方法\n1. size 返回集合的元素个数\n2. add  增加啊一个元素，返回当前集合\n3. delete   删除元素，返回boolean值\n4. has  检测集合中是否包含某个元素，返回boolean值\n5. clear 清空集合\n\n#### 应用\n\n1. 数组去重\n\n```js\nlet test = [1,2,2,3,4,5,6,6];\nlet result = [...new Set(test)];\nconsole.log(result); // [1,2,3,4,5,6]\n```\n2. 交集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5];\nlet arr2 = [2,2,3,3,4,4];\nlet result = [...new Set(arr1)].filter(item=>new Set(arr2).has(item));\nconsole.log(result); // [2,3,4]\n```\n3. 并集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet union = [...new Set([...arr1,...arr2])];\nconsole.log(union); // [1,2,3,4,5,7,6,10];\n```\n4. 差集\n\n```js\nlet arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet diff = [...new Set(arr1)].filter(item=>!new Set(arr2).has(item));\nconsole.log(diff); // [1,5,7,6,10];\n```\n\n## Map\n\nES6提供了Map数据结构。它类似于对象，也是键值对的几个。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n\nMap也实现了iterator接口，所以可以使用扩展运算符和for...of进行遍历\n\n#### 属性方法\n1. size 返回Map的元素个数\n2. set  增加一个新的元素，返回当前的Map\n3. get  返回键名对象的键值\n4. has  检测Map中是否包含某个元素，返回boolean值\n5. clear    清空Map,返回undefined","slug":"前端/ES总结/ES6 语法总结 03","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t2w001r2h1728msfcnl","content":"<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>ES6提供新的数据结果Set,该数据结构的特点就是其内部不会存在重复的元素，类似于数组，成员的值都是唯一的</p>\n<p>集合实现了iterator接口，所以可以使用扩展运算符和for…of进行遍历</p>\n<h4 id=\"属性方法\"><a href=\"#属性方法\" class=\"headerlink\" title=\"属性方法\"></a>属性方法</h4><ol>\n<li>size 返回集合的元素个数</li>\n<li>add  增加啊一个元素，返回当前集合</li>\n<li>delete   删除元素，返回boolean值</li>\n<li>has  检测集合中是否包含某个元素，返回boolean值</li>\n<li>clear 清空集合</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>数组去重</li>\n</ol>\n<pre><code class=\"js\">let test = [1,2,2,3,4,5,6,6];\nlet result = [...new Set(test)];\nconsole.log(result); // [1,2,3,4,5,6]\n</code></pre>\n<ol start=\"2\">\n<li>交集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5];\nlet arr2 = [2,2,3,3,4,4];\nlet result = [...new Set(arr1)].filter(item=&gt;new Set(arr2).has(item));\nconsole.log(result); // [2,3,4]\n</code></pre>\n<ol start=\"3\">\n<li>并集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet union = [...new Set([...arr1,...arr2])];\nconsole.log(union); // [1,2,3,4,5,7,6,10];\n</code></pre>\n<ol start=\"4\">\n<li>差集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet diff = [...new Set(arr1)].filter(item=&gt;!new Set(arr2).has(item));\nconsole.log(diff); // [1,5,7,6,10];\n</code></pre>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>ES6提供了Map数据结构。它类似于对象，也是键值对的几个。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>\n<p>Map也实现了iterator接口，所以可以使用扩展运算符和for…of进行遍历</p>\n<h4 id=\"属性方法-1\"><a href=\"#属性方法-1\" class=\"headerlink\" title=\"属性方法\"></a>属性方法</h4><ol>\n<li>size 返回Map的元素个数</li>\n<li>set  增加一个新的元素，返回当前的Map</li>\n<li>get  返回键名对象的键值</li>\n<li>has  检测Map中是否包含某个元素，返回boolean值</li>\n<li>clear    清空Map,返回undefined</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>ES6提供新的数据结果Set,该数据结构的特点就是其内部不会存在重复的元素，类似于数组，成员的值都是唯一的</p>\n<p>集合实现了iterator接口，所以可以使用扩展运算符和for…of进行遍历</p>\n<h4 id=\"属性方法\"><a href=\"#属性方法\" class=\"headerlink\" title=\"属性方法\"></a>属性方法</h4><ol>\n<li>size 返回集合的元素个数</li>\n<li>add  增加啊一个元素，返回当前集合</li>\n<li>delete   删除元素，返回boolean值</li>\n<li>has  检测集合中是否包含某个元素，返回boolean值</li>\n<li>clear 清空集合</li>\n</ol>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ol>\n<li>数组去重</li>\n</ol>\n<pre><code class=\"js\">let test = [1,2,2,3,4,5,6,6];\nlet result = [...new Set(test)];\nconsole.log(result); // [1,2,3,4,5,6]\n</code></pre>\n<ol start=\"2\">\n<li>交集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5];\nlet arr2 = [2,2,3,3,4,4];\nlet result = [...new Set(arr1)].filter(item=&gt;new Set(arr2).has(item));\nconsole.log(result); // [2,3,4]\n</code></pre>\n<ol start=\"3\">\n<li>并集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet union = [...new Set([...arr1,...arr2])];\nconsole.log(union); // [1,2,3,4,5,7,6,10];\n</code></pre>\n<ol start=\"4\">\n<li>差集</li>\n</ol>\n<pre><code class=\"js\">let arr1 = [1,2,2,3,4,4,5,7,6,10];\nlet arr2 = [2,2,3,3,4,4];\nlet diff = [...new Set(arr1)].filter(item=&gt;!new Set(arr2).has(item));\nconsole.log(diff); // [1,5,7,6,10];\n</code></pre>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>ES6提供了Map数据结构。它类似于对象，也是键值对的几个。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>\n<p>Map也实现了iterator接口，所以可以使用扩展运算符和for…of进行遍历</p>\n<h4 id=\"属性方法-1\"><a href=\"#属性方法-1\" class=\"headerlink\" title=\"属性方法\"></a>属性方法</h4><ol>\n<li>size 返回Map的元素个数</li>\n<li>set  增加一个新的元素，返回当前的Map</li>\n<li>get  返回键名对象的键值</li>\n<li>has  检测Map中是否包含某个元素，返回boolean值</li>\n<li>clear    清空Map,返回undefined</li>\n</ol>\n"},{"title":"vue2 computed&watch","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-06-07T16:00:00.000Z","comments":0,"description":"vue2 computed&watch","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n## computed\n\n1. 特点:\n\ncomputed是计算属性,依赖于其它属性值,并且computed的值有缓存,只有它依赖的属性值发生变化时,下一次获取computed的值时才会重新计算computed的值\n但是如果被依赖的属性值来自外部,那么该属性值发生改变,计算属性\n\n\n2. 适用场景\n\n当我们需要进行数值计算,并且依赖于其他数据时,应该使用computed,因为可以利用computed的缓存特性,并没每次获取值,都要重新计算\n\n\n3. 语法\n\n```js\ncomputed:{ [key: string]: Function | { get: Function, set: Function } }\n```\n\n4. 使用样例\n\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // 仅读取\n    aDouble: function () {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // => 2\nvm.aPlus = 3\nvm.a       // => 2\nvm.aDouble // => 4\n```\n\n\n## watch\n\n1. 特点\n\n没有缓存行,更多的是观察的作用,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作；\n当我们需要深度监听对象的属性时,可以打开deep:true选项,这样便会对对象中的每一项进行监听\n注意:Vue实例在初始化的时候会调用$watch(),遍历watch对象的每一个属性\n\n如果我们使用箭头函数来定义watch的函数,那么我们就无法在函数内部访问当前实例,因此我们最好避免使用箭头函数来定义watch的函数\n\n2. 适用场景\n\n当我们需要在数据变化时进行异步或开销较大的操作时,应该使用watch,使用watch选项允许我们执行异步操作(访问一个api),限制我们执行该操作的频率,并且在我们得到最终结果前,设置中间状态。\n这些都是计算属性无法做到的\n\n\n3. 语法\n\n```js\nwatch:{ [key: string]: string | Function | Object | Array }\n```\n\n4. 使用样例\n\n```js\nvar vm = new Vue({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4,\n    e: {\n      f: {\n        g: 5\n      }\n    }\n  },\n  watch: {\n    a: function (val, oldVal) {\n      console.log('new: %s, old: %s', val, oldVal)\n    },\n    // 方法名\n    b: 'someMethod',\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    },\n    // 该回调将会在侦听开始之后被立即调用\n    d: {\n      handler: 'someMethod',\n      immediate: true\n    },\n    // 你可以传入回调数组，它们会被逐一调用\n    e: [\n      'handle1',\n      function handle2 (val, oldVal) { /* ... */ },\n      {\n        handler: function handle3 (val, oldVal) { /* ... */ },\n        /* ... */\n      }\n    ],\n    // watch vm.e.f's value: {g: 5}\n    'e.f': function (val, oldVal) { /* ... */ }\n  }\n})\nvm.a = 2 // => new: 2, old: 1\n```","source":"_posts/前端/vue/vue2 computed&watch.md","raw":"---\ntitle: vue2 computed&watch\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-06-08\ncomments: false\ndescription: vue2 computed&watch\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n## computed\n\n1. 特点:\n\ncomputed是计算属性,依赖于其它属性值,并且computed的值有缓存,只有它依赖的属性值发生变化时,下一次获取computed的值时才会重新计算computed的值\n但是如果被依赖的属性值来自外部,那么该属性值发生改变,计算属性\n\n\n2. 适用场景\n\n当我们需要进行数值计算,并且依赖于其他数据时,应该使用computed,因为可以利用computed的缓存特性,并没每次获取值,都要重新计算\n\n\n3. 语法\n\n```js\ncomputed:{ [key: string]: Function | { get: Function, set: Function } }\n```\n\n4. 使用样例\n\n```js\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // 仅读取\n    aDouble: function () {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // => 2\nvm.aPlus = 3\nvm.a       // => 2\nvm.aDouble // => 4\n```\n\n\n## watch\n\n1. 特点\n\n没有缓存行,更多的是观察的作用,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作；\n当我们需要深度监听对象的属性时,可以打开deep:true选项,这样便会对对象中的每一项进行监听\n注意:Vue实例在初始化的时候会调用$watch(),遍历watch对象的每一个属性\n\n如果我们使用箭头函数来定义watch的函数,那么我们就无法在函数内部访问当前实例,因此我们最好避免使用箭头函数来定义watch的函数\n\n2. 适用场景\n\n当我们需要在数据变化时进行异步或开销较大的操作时,应该使用watch,使用watch选项允许我们执行异步操作(访问一个api),限制我们执行该操作的频率,并且在我们得到最终结果前,设置中间状态。\n这些都是计算属性无法做到的\n\n\n3. 语法\n\n```js\nwatch:{ [key: string]: string | Function | Object | Array }\n```\n\n4. 使用样例\n\n```js\nvar vm = new Vue({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4,\n    e: {\n      f: {\n        g: 5\n      }\n    }\n  },\n  watch: {\n    a: function (val, oldVal) {\n      console.log('new: %s, old: %s', val, oldVal)\n    },\n    // 方法名\n    b: 'someMethod',\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    },\n    // 该回调将会在侦听开始之后被立即调用\n    d: {\n      handler: 'someMethod',\n      immediate: true\n    },\n    // 你可以传入回调数组，它们会被逐一调用\n    e: [\n      'handle1',\n      function handle2 (val, oldVal) { /* ... */ },\n      {\n        handler: function handle3 (val, oldVal) { /* ... */ },\n        /* ... */\n      }\n    ],\n    // watch vm.e.f's value: {g: 5}\n    'e.f': function (val, oldVal) { /* ... */ }\n  }\n})\nvm.a = 2 // => new: 2, old: 1\n```","slug":"前端/vue/vue2 computed&watch","published":1,"updated":"2023-05-12T23:28:10.995Z","layout":"post","link":"","_id":"clhws1t2x001t2h17amnw4vhy","content":"<h2 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h2><ol>\n<li>特点:</li>\n</ol>\n<p>computed是计算属性,依赖于其它属性值,并且computed的值有缓存,只有它依赖的属性值发生变化时,下一次获取computed的值时才会重新计算computed的值<br>但是如果被依赖的属性值来自外部,那么该属性值发生改变,计算属性</p>\n<ol start=\"2\">\n<li>适用场景</li>\n</ol>\n<p>当我们需要进行数值计算,并且依赖于其他数据时,应该使用computed,因为可以利用computed的缓存特性,并没每次获取值,都要重新计算</p>\n<ol start=\"3\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">computed:&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;\n</code></pre>\n<ol start=\"4\">\n<li>使用样例</li>\n</ol>\n<pre><code class=\"js\">var vm = new Vue(&#123;\n  data: &#123; a: 1 &#125;,\n  computed: &#123;\n    // 仅读取\n    aDouble: function () &#123;\n      return this.a * 2\n    &#125;,\n    // 读取和设置\n    aPlus: &#123;\n      get: function () &#123;\n        return this.a + 1\n      &#125;,\n      set: function (v) &#123;\n        this.a = v - 1\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   // =&gt; 2\nvm.aPlus = 3\nvm.a       // =&gt; 2\nvm.aDouble // =&gt; 4\n</code></pre>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><ol>\n<li>特点</li>\n</ol>\n<p>没有缓存行,更多的是观察的作用,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作；<br>当我们需要深度监听对象的属性时,可以打开deep:true选项,这样便会对对象中的每一项进行监听<br>注意:Vue实例在初始化的时候会调用$watch(),遍历watch对象的每一个属性</p>\n<p>如果我们使用箭头函数来定义watch的函数,那么我们就无法在函数内部访问当前实例,因此我们最好避免使用箭头函数来定义watch的函数</p>\n<ol start=\"2\">\n<li>适用场景</li>\n</ol>\n<p>当我们需要在数据变化时进行异步或开销较大的操作时,应该使用watch,使用watch选项允许我们执行异步操作(访问一个api),限制我们执行该操作的频率,并且在我们得到最终结果前,设置中间状态。<br>这些都是计算属性无法做到的</p>\n<ol start=\"3\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">watch:&#123; [key: string]: string | Function | Object | Array &#125;\n</code></pre>\n<ol start=\"4\">\n<li>使用样例</li>\n</ol>\n<pre><code class=\"js\">var vm = new Vue(&#123;\n  data: &#123;\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4,\n    e: &#123;\n      f: &#123;\n        g: 5\n      &#125;\n    &#125;\n  &#125;,\n  watch: &#123;\n    a: function (val, oldVal) &#123;\n      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    &#125;,\n    // 方法名\n    b: &#39;someMethod&#39;,\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: &#123;\n      handler: function (val, oldVal) &#123; /* ... */ &#125;,\n      deep: true\n    &#125;,\n    // 该回调将会在侦听开始之后被立即调用\n    d: &#123;\n      handler: &#39;someMethod&#39;,\n      immediate: true\n    &#125;,\n    // 你可以传入回调数组，它们会被逐一调用\n    e: [\n      &#39;handle1&#39;,\n      function handle2 (val, oldVal) &#123; /* ... */ &#125;,\n      &#123;\n        handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;,\n        /* ... */\n      &#125;\n    ],\n    // watch vm.e.f&#39;s value: &#123;g: 5&#125;\n    &#39;e.f&#39;: function (val, oldVal) &#123; /* ... */ &#125;\n  &#125;\n&#125;)\nvm.a = 2 // =&gt; new: 2, old: 1\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h2><ol>\n<li>特点:</li>\n</ol>\n<p>computed是计算属性,依赖于其它属性值,并且computed的值有缓存,只有它依赖的属性值发生变化时,下一次获取computed的值时才会重新计算computed的值<br>但是如果被依赖的属性值来自外部,那么该属性值发生改变,计算属性</p>\n<ol start=\"2\">\n<li>适用场景</li>\n</ol>\n<p>当我们需要进行数值计算,并且依赖于其他数据时,应该使用computed,因为可以利用computed的缓存特性,并没每次获取值,都要重新计算</p>\n<ol start=\"3\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">computed:&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;\n</code></pre>\n<ol start=\"4\">\n<li>使用样例</li>\n</ol>\n<pre><code class=\"js\">var vm = new Vue(&#123;\n  data: &#123; a: 1 &#125;,\n  computed: &#123;\n    // 仅读取\n    aDouble: function () &#123;\n      return this.a * 2\n    &#125;,\n    // 读取和设置\n    aPlus: &#123;\n      get: function () &#123;\n        return this.a + 1\n      &#125;,\n      set: function (v) &#123;\n        this.a = v - 1\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   // =&gt; 2\nvm.aPlus = 3\nvm.a       // =&gt; 2\nvm.aDouble // =&gt; 4\n</code></pre>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><ol>\n<li>特点</li>\n</ol>\n<p>没有缓存行,更多的是观察的作用,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作；<br>当我们需要深度监听对象的属性时,可以打开deep:true选项,这样便会对对象中的每一项进行监听<br>注意:Vue实例在初始化的时候会调用$watch(),遍历watch对象的每一个属性</p>\n<p>如果我们使用箭头函数来定义watch的函数,那么我们就无法在函数内部访问当前实例,因此我们最好避免使用箭头函数来定义watch的函数</p>\n<ol start=\"2\">\n<li>适用场景</li>\n</ol>\n<p>当我们需要在数据变化时进行异步或开销较大的操作时,应该使用watch,使用watch选项允许我们执行异步操作(访问一个api),限制我们执行该操作的频率,并且在我们得到最终结果前,设置中间状态。<br>这些都是计算属性无法做到的</p>\n<ol start=\"3\">\n<li>语法</li>\n</ol>\n<pre><code class=\"js\">watch:&#123; [key: string]: string | Function | Object | Array &#125;\n</code></pre>\n<ol start=\"4\">\n<li>使用样例</li>\n</ol>\n<pre><code class=\"js\">var vm = new Vue(&#123;\n  data: &#123;\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4,\n    e: &#123;\n      f: &#123;\n        g: 5\n      &#125;\n    &#125;\n  &#125;,\n  watch: &#123;\n    a: function (val, oldVal) &#123;\n      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    &#125;,\n    // 方法名\n    b: &#39;someMethod&#39;,\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: &#123;\n      handler: function (val, oldVal) &#123; /* ... */ &#125;,\n      deep: true\n    &#125;,\n    // 该回调将会在侦听开始之后被立即调用\n    d: &#123;\n      handler: &#39;someMethod&#39;,\n      immediate: true\n    &#125;,\n    // 你可以传入回调数组，它们会被逐一调用\n    e: [\n      &#39;handle1&#39;,\n      function handle2 (val, oldVal) &#123; /* ... */ &#125;,\n      &#123;\n        handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;,\n        /* ... */\n      &#125;\n    ],\n    // watch vm.e.f&#39;s value: &#123;g: 5&#125;\n    &#39;e.f&#39;: function (val, oldVal) &#123; /* ... */ &#125;\n  &#125;\n&#125;)\nvm.a = 2 // =&gt; new: 2, old: 1\n</code></pre>\n"},{"title":"vue2 v-slot","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-02-05T16:00:00.000Z","comments":0,"description":"vue2 v-slot","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n## 前言\n\nvue的插槽灵感来自于Web Component,将 `<slot>` 元素作为承载分发内容的出口。\n\nslot标签也是我们UI组件化的一个方法,我们可以通过slot标签向组件传递标签数据(意思就是我们可以将组件作为数据传递给另一个组件)\n\n## 插槽的基本使用\n先来一个最简单的使用Demo\n1. 定义\n\n```vue\n<template>\n  <div>\n    <slot>Hello Slot</slot>\n  </div>\n</template>\n```\n这里,定义了一个带有slot标签的组件,我们可以使用特定的方法在使用该组件时向该组件传递组件标签数据\n\n2. 使用\n\n```vue\n<template>\n  <div>\n    <!----使用组件----> \n    <SlotComponent>\n      <!----传递标签数据----> \n      <template>\n        <h1>Hello Template</h1>\n      </template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\n// 引入组件\nimport SlotComponent from \"componentPath\";\n\nexport default {\n  // 注册组件\n  components: {\n    SlotComponent\n  }\n};\n</script>\n```\n这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n在使用该组件的使用,我们使用`<template>`标签,然后通过该标签将标签数据(也就是`<h1>Hello Template</h1>`)传递给了SlotComponent组件,然后接收到标签数据的组件会将该标签分发到slot标签里。\n\n效果如下\n\n![v-slot1](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令01.png)\n\n假如我们没有向SlotComponent组件传递参数,那么slot那区域所显示的内容就是SlotComponent组件slot标签原本的内容。  \n\n在这里是`Hello Slot`\n\n效果如下\n\n![v-slot2](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令02.png)\n\n\n## 插槽命名\n\n然而,在我们的实际应用中,我们的一个组件会多出使用到slot标签,那么这是我们就需要为slot命名 --> 插槽命名\n\n1. 定义组件\n\n```vue\n<template>\n  <div>\n    <slot name=\"header\">\n      <h1>header</h1>\n    </slot>\n    <slot>\n      <h1>default</h1>\n    </slot>\n    <slot name=\"footer\">\n      <h1>footer</h1>\n    </slot>\n  </div>\n</template>\n```\n\n在这里,我们定义了三个插槽,并分别为这三个插槽命名,不取名默认为'default'。\n\n在这里这三个插槽的名称分别为`header`,`default`,`footer`\n\n然后,接下来就是使用该组件\n\n2. 使用组件\n\n```vue\n<template>\n  <div id=\"app\">\n    <SlotComponent>\n      <template v-slot:header>Hello header</template>\n      <template>Hello default</template>\n      <template v-slot:footer>Hello footer</template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\nimport SlotComponent from \"./components/SlotComponent\";\n\nexport default {\n  components: {\n    SlotComponent\n  },\n  data() {}\n};\n</script>\n```\n\n这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n然后,在这里,我们不仅使用了`template`标签,还使用了v-slot指令,该指令指定template所包含的标签数据应该传给那个slot\n\nv-slot后面的值为slot插槽的名称。并且该指令只能使用在template标签上\n\n这样,vue就会帮我们把template所包含的标签数据传递给相应的slot中\n\n效果如下图\n\n![v-slot3](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令03.png\n)\n## 插槽的作用域\n\n有时候,我们需要使用组件的外部组件访问到组件内部数据,我们需要访问其slot所绑定的数据\n\n那么，我们可以按照以下步骤\n\n1. 定义组件\n\n```vue\n<template>\n  <div>\n    <slot v-bind:user=\"user\">\n      <!-- default slot value -->\n      {{user.firstName}}\n    </slot>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      user: {\n        firstName: \"Jack\",\n        lastName: \"Black\"\n      }\n    };\n  }\n};\n</script>\n```\n在这里,我们定义了一个对象user，并且我们将user.firstName作为插槽的默认值\n\n然后我们在slot标签上绑定一个属性名为user,属性值为user\n\n这样,就完成了组件的定义\n\n2. 使用组件\n\n```vue\n<template>\n  <div id=\"app\">\n    <SlotComponent>\n      <template v-slot:default=\"slotProp\">{{slotProp.user.lastName}}</template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\nimport SlotComponent from \"./components/SlotComponent\";\n\nexport default {\n  components: {\n    SlotComponent\n  },\n};\n</script>\n```\n\n在这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n然后我们在template标签上使用v-slot获取slot所绑定的所有属性,格式为`v-slot:slotName=\"props\"`。\n\nslotName为插槽的名称,props为该插槽所绑定的所有属性,在这里是`{user}`\n\n然后我们就可以通过props来获取slot所绑定的值\n\n最后效果如下\n\n![v-slot4](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令04.png)","source":"_posts/前端/vue/vue2 v-slot.md","raw":"---\ntitle: vue2 v-slot\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-02-06\ncomments: false\ndescription: vue2 v-slot\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n## 前言\n\nvue的插槽灵感来自于Web Component,将 `<slot>` 元素作为承载分发内容的出口。\n\nslot标签也是我们UI组件化的一个方法,我们可以通过slot标签向组件传递标签数据(意思就是我们可以将组件作为数据传递给另一个组件)\n\n## 插槽的基本使用\n先来一个最简单的使用Demo\n1. 定义\n\n```vue\n<template>\n  <div>\n    <slot>Hello Slot</slot>\n  </div>\n</template>\n```\n这里,定义了一个带有slot标签的组件,我们可以使用特定的方法在使用该组件时向该组件传递组件标签数据\n\n2. 使用\n\n```vue\n<template>\n  <div>\n    <!----使用组件----> \n    <SlotComponent>\n      <!----传递标签数据----> \n      <template>\n        <h1>Hello Template</h1>\n      </template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\n// 引入组件\nimport SlotComponent from \"componentPath\";\n\nexport default {\n  // 注册组件\n  components: {\n    SlotComponent\n  }\n};\n</script>\n```\n这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n在使用该组件的使用,我们使用`<template>`标签,然后通过该标签将标签数据(也就是`<h1>Hello Template</h1>`)传递给了SlotComponent组件,然后接收到标签数据的组件会将该标签分发到slot标签里。\n\n效果如下\n\n![v-slot1](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令01.png)\n\n假如我们没有向SlotComponent组件传递参数,那么slot那区域所显示的内容就是SlotComponent组件slot标签原本的内容。  \n\n在这里是`Hello Slot`\n\n效果如下\n\n![v-slot2](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令02.png)\n\n\n## 插槽命名\n\n然而,在我们的实际应用中,我们的一个组件会多出使用到slot标签,那么这是我们就需要为slot命名 --> 插槽命名\n\n1. 定义组件\n\n```vue\n<template>\n  <div>\n    <slot name=\"header\">\n      <h1>header</h1>\n    </slot>\n    <slot>\n      <h1>default</h1>\n    </slot>\n    <slot name=\"footer\">\n      <h1>footer</h1>\n    </slot>\n  </div>\n</template>\n```\n\n在这里,我们定义了三个插槽,并分别为这三个插槽命名,不取名默认为'default'。\n\n在这里这三个插槽的名称分别为`header`,`default`,`footer`\n\n然后,接下来就是使用该组件\n\n2. 使用组件\n\n```vue\n<template>\n  <div id=\"app\">\n    <SlotComponent>\n      <template v-slot:header>Hello header</template>\n      <template>Hello default</template>\n      <template v-slot:footer>Hello footer</template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\nimport SlotComponent from \"./components/SlotComponent\";\n\nexport default {\n  components: {\n    SlotComponent\n  },\n  data() {}\n};\n</script>\n```\n\n这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n然后,在这里,我们不仅使用了`template`标签,还使用了v-slot指令,该指令指定template所包含的标签数据应该传给那个slot\n\nv-slot后面的值为slot插槽的名称。并且该指令只能使用在template标签上\n\n这样,vue就会帮我们把template所包含的标签数据传递给相应的slot中\n\n效果如下图\n\n![v-slot3](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令03.png\n)\n## 插槽的作用域\n\n有时候,我们需要使用组件的外部组件访问到组件内部数据,我们需要访问其slot所绑定的数据\n\n那么，我们可以按照以下步骤\n\n1. 定义组件\n\n```vue\n<template>\n  <div>\n    <slot v-bind:user=\"user\">\n      <!-- default slot value -->\n      {{user.firstName}}\n    </slot>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      user: {\n        firstName: \"Jack\",\n        lastName: \"Black\"\n      }\n    };\n  }\n};\n</script>\n```\n在这里,我们定义了一个对象user，并且我们将user.firstName作为插槽的默认值\n\n然后我们在slot标签上绑定一个属性名为user,属性值为user\n\n这样,就完成了组件的定义\n\n2. 使用组件\n\n```vue\n<template>\n  <div id=\"app\">\n    <SlotComponent>\n      <template v-slot:default=\"slotProp\">{{slotProp.user.lastName}}</template>\n    </SlotComponent>\n  </div>\n</template>\n\n<script>\nimport SlotComponent from \"./components/SlotComponent\";\n\nexport default {\n  components: {\n    SlotComponent\n  },\n};\n</script>\n```\n\n在这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它\n\n然后我们在template标签上使用v-slot获取slot所绑定的所有属性,格式为`v-slot:slotName=\"props\"`。\n\nslotName为插槽的名称,props为该插槽所绑定的所有属性,在这里是`{user}`\n\n然后我们就可以通过props来获取slot所绑定的值\n\n最后效果如下\n\n![v-slot4](https://gitee.com/trueLoving/cdn/raw/master/img/v-slot指令04.png)","slug":"前端/vue/vue2 v-slot","published":1,"updated":"2023-05-12T23:28:10.996Z","layout":"post","link":"","_id":"clhws1t2y001x2h17hezag1fo","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>vue的插槽灵感来自于Web Component,将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>\n<p>slot标签也是我们UI组件化的一个方法,我们可以通过slot标签向组件传递标签数据(意思就是我们可以将组件作为数据传递给另一个组件)</p>\n<h2 id=\"插槽的基本使用\"><a href=\"#插槽的基本使用\" class=\"headerlink\" title=\"插槽的基本使用\"></a>插槽的基本使用</h2><p>先来一个最简单的使用Demo</p>\n<ol>\n<li>定义</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot&gt;Hello Slot&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>这里,定义了一个带有slot标签的组件,我们可以使用特定的方法在使用该组件时向该组件传递组件标签数据</p>\n<ol start=\"2\">\n<li>使用</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;!----使用组件----&gt; \n    &lt;SlotComponent&gt;\n      &lt;!----传递标签数据----&gt; \n      &lt;template&gt;\n        &lt;h1&gt;Hello Template&lt;/h1&gt;\n      &lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 引入组件\nimport SlotComponent from &quot;componentPath&quot;;\n\nexport default &#123;\n  // 注册组件\n  components: &#123;\n    SlotComponent\n  &#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>在使用该组件的使用,我们使用<code>&lt;template&gt;</code>标签,然后通过该标签将标签数据(也就是<code>&lt;h1&gt;Hello Template&lt;/h1&gt;</code>)传递给了SlotComponent组件,然后接收到标签数据的组件会将该标签分发到slot标签里。</p>\n<p>效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A401.png\" alt=\"v-slot1\"></p>\n<p>假如我们没有向SlotComponent组件传递参数,那么slot那区域所显示的内容就是SlotComponent组件slot标签原本的内容。  </p>\n<p>在这里是<code>Hello Slot</code></p>\n<p>效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A402.png\" alt=\"v-slot2\"></p>\n<h2 id=\"插槽命名\"><a href=\"#插槽命名\" class=\"headerlink\" title=\"插槽命名\"></a>插槽命名</h2><p>然而,在我们的实际应用中,我们的一个组件会多出使用到slot标签,那么这是我们就需要为slot命名 –&gt; 插槽命名</p>\n<ol>\n<li>定义组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot name=&quot;header&quot;&gt;\n      &lt;h1&gt;header&lt;/h1&gt;\n    &lt;/slot&gt;\n    &lt;slot&gt;\n      &lt;h1&gt;default&lt;/h1&gt;\n    &lt;/slot&gt;\n    &lt;slot name=&quot;footer&quot;&gt;\n      &lt;h1&gt;footer&lt;/h1&gt;\n    &lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>在这里,我们定义了三个插槽,并分别为这三个插槽命名,不取名默认为’default’。</p>\n<p>在这里这三个插槽的名称分别为<code>header</code>,<code>default</code>,<code>footer</code></p>\n<p>然后,接下来就是使用该组件</p>\n<ol start=\"2\">\n<li>使用组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;SlotComponent&gt;\n      &lt;template v-slot:header&gt;Hello header&lt;/template&gt;\n      &lt;template&gt;Hello default&lt;/template&gt;\n      &lt;template v-slot:footer&gt;Hello footer&lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport SlotComponent from &quot;./components/SlotComponent&quot;;\n\nexport default &#123;\n  components: &#123;\n    SlotComponent\n  &#125;,\n  data() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>然后,在这里,我们不仅使用了<code>template</code>标签,还使用了v-slot指令,该指令指定template所包含的标签数据应该传给那个slot</p>\n<p>v-slot后面的值为slot插槽的名称。并且该指令只能使用在template标签上</p>\n<p>这样,vue就会帮我们把template所包含的标签数据传递给相应的slot中</p>\n<p>效果如下图</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A403.png\" alt=\"v-slot3\"></p>\n<h2 id=\"插槽的作用域\"><a href=\"#插槽的作用域\" class=\"headerlink\" title=\"插槽的作用域\"></a>插槽的作用域</h2><p>有时候,我们需要使用组件的外部组件访问到组件内部数据,我们需要访问其slot所绑定的数据</p>\n<p>那么，我们可以按照以下步骤</p>\n<ol>\n<li>定义组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot v-bind:user=&quot;user&quot;&gt;\n      &lt;!-- default slot value --&gt;\n      &#123;&#123;user.firstName&#125;&#125;\n    &lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      user: &#123;\n        firstName: &quot;Jack&quot;,\n        lastName: &quot;Black&quot;\n      &#125;\n    &#125;;\n  &#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>在这里,我们定义了一个对象user，并且我们将user.firstName作为插槽的默认值</p>\n<p>然后我们在slot标签上绑定一个属性名为user,属性值为user</p>\n<p>这样,就完成了组件的定义</p>\n<ol start=\"2\">\n<li>使用组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;SlotComponent&gt;\n      &lt;template v-slot:default=&quot;slotProp&quot;&gt;&#123;&#123;slotProp.user.lastName&#125;&#125;&lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport SlotComponent from &quot;./components/SlotComponent&quot;;\n\nexport default &#123;\n  components: &#123;\n    SlotComponent\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>在这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>然后我们在template标签上使用v-slot获取slot所绑定的所有属性,格式为<code>v-slot:slotName=&quot;props&quot;</code>。</p>\n<p>slotName为插槽的名称,props为该插槽所绑定的所有属性,在这里是<code>&#123;user&#125;</code></p>\n<p>然后我们就可以通过props来获取slot所绑定的值</p>\n<p>最后效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A404.png\" alt=\"v-slot4\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>vue的插槽灵感来自于Web Component,将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>\n<p>slot标签也是我们UI组件化的一个方法,我们可以通过slot标签向组件传递标签数据(意思就是我们可以将组件作为数据传递给另一个组件)</p>\n<h2 id=\"插槽的基本使用\"><a href=\"#插槽的基本使用\" class=\"headerlink\" title=\"插槽的基本使用\"></a>插槽的基本使用</h2><p>先来一个最简单的使用Demo</p>\n<ol>\n<li>定义</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot&gt;Hello Slot&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>这里,定义了一个带有slot标签的组件,我们可以使用特定的方法在使用该组件时向该组件传递组件标签数据</p>\n<ol start=\"2\">\n<li>使用</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;!----使用组件----&gt; \n    &lt;SlotComponent&gt;\n      &lt;!----传递标签数据----&gt; \n      &lt;template&gt;\n        &lt;h1&gt;Hello Template&lt;/h1&gt;\n      &lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 引入组件\nimport SlotComponent from &quot;componentPath&quot;;\n\nexport default &#123;\n  // 注册组件\n  components: &#123;\n    SlotComponent\n  &#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>在使用该组件的使用,我们使用<code>&lt;template&gt;</code>标签,然后通过该标签将标签数据(也就是<code>&lt;h1&gt;Hello Template&lt;/h1&gt;</code>)传递给了SlotComponent组件,然后接收到标签数据的组件会将该标签分发到slot标签里。</p>\n<p>效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A401.png\" alt=\"v-slot1\"></p>\n<p>假如我们没有向SlotComponent组件传递参数,那么slot那区域所显示的内容就是SlotComponent组件slot标签原本的内容。  </p>\n<p>在这里是<code>Hello Slot</code></p>\n<p>效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A402.png\" alt=\"v-slot2\"></p>\n<h2 id=\"插槽命名\"><a href=\"#插槽命名\" class=\"headerlink\" title=\"插槽命名\"></a>插槽命名</h2><p>然而,在我们的实际应用中,我们的一个组件会多出使用到slot标签,那么这是我们就需要为slot命名 –&gt; 插槽命名</p>\n<ol>\n<li>定义组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot name=&quot;header&quot;&gt;\n      &lt;h1&gt;header&lt;/h1&gt;\n    &lt;/slot&gt;\n    &lt;slot&gt;\n      &lt;h1&gt;default&lt;/h1&gt;\n    &lt;/slot&gt;\n    &lt;slot name=&quot;footer&quot;&gt;\n      &lt;h1&gt;footer&lt;/h1&gt;\n    &lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>在这里,我们定义了三个插槽,并分别为这三个插槽命名,不取名默认为’default’。</p>\n<p>在这里这三个插槽的名称分别为<code>header</code>,<code>default</code>,<code>footer</code></p>\n<p>然后,接下来就是使用该组件</p>\n<ol start=\"2\">\n<li>使用组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;SlotComponent&gt;\n      &lt;template v-slot:header&gt;Hello header&lt;/template&gt;\n      &lt;template&gt;Hello default&lt;/template&gt;\n      &lt;template v-slot:footer&gt;Hello footer&lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport SlotComponent from &quot;./components/SlotComponent&quot;;\n\nexport default &#123;\n  components: &#123;\n    SlotComponent\n  &#125;,\n  data() &#123;&#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>然后,在这里,我们不仅使用了<code>template</code>标签,还使用了v-slot指令,该指令指定template所包含的标签数据应该传给那个slot</p>\n<p>v-slot后面的值为slot插槽的名称。并且该指令只能使用在template标签上</p>\n<p>这样,vue就会帮我们把template所包含的标签数据传递给相应的slot中</p>\n<p>效果如下图</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A403.png\" alt=\"v-slot3\"></p>\n<h2 id=\"插槽的作用域\"><a href=\"#插槽的作用域\" class=\"headerlink\" title=\"插槽的作用域\"></a>插槽的作用域</h2><p>有时候,我们需要使用组件的外部组件访问到组件内部数据,我们需要访问其slot所绑定的数据</p>\n<p>那么，我们可以按照以下步骤</p>\n<ol>\n<li>定义组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;slot v-bind:user=&quot;user&quot;&gt;\n      &lt;!-- default slot value --&gt;\n      &#123;&#123;user.firstName&#125;&#125;\n    &lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      user: &#123;\n        firstName: &quot;Jack&quot;,\n        lastName: &quot;Black&quot;\n      &#125;\n    &#125;;\n  &#125;\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>在这里,我们定义了一个对象user，并且我们将user.firstName作为插槽的默认值</p>\n<p>然后我们在slot标签上绑定一个属性名为user,属性值为user</p>\n<p>这样,就完成了组件的定义</p>\n<ol start=\"2\">\n<li>使用组件</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;SlotComponent&gt;\n      &lt;template v-slot:default=&quot;slotProp&quot;&gt;&#123;&#123;slotProp.user.lastName&#125;&#125;&lt;/template&gt;\n    &lt;/SlotComponent&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport SlotComponent from &quot;./components/SlotComponent&quot;;\n\nexport default &#123;\n  components: &#123;\n    SlotComponent\n  &#125;,\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>在这里,我们首先使用定义了一个组件,然后引用了该组件，注册并使用了它</p>\n<p>然后我们在template标签上使用v-slot获取slot所绑定的所有属性,格式为<code>v-slot:slotName=&quot;props&quot;</code>。</p>\n<p>slotName为插槽的名称,props为该插槽所绑定的所有属性,在这里是<code>&#123;user&#125;</code></p>\n<p>然后我们就可以通过props来获取slot所绑定的值</p>\n<p>最后效果如下</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/v-slot%E6%8C%87%E4%BB%A404.png\" alt=\"v-slot4\"></p>\n"},{"title":"vue2 vuex","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-02-17T16:00:00.000Z","comments":0,"description":"vue2 vuex","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n## 前言\n\nvuex是一个专门为vue应用程序开发的状态管理模式。它的出现是为了处理多个组件共同使用一个数据源渲染视图的问题\n\n当我们通过调用vuex的方法来改变数据时,跟数据相关的组件们视图就会同时发生变化\n\nvuex可以帮我们集中管理数据,存储多个组件共享的数据状态\n\nvuex的工作流程如下图所示\n\n<img src=\"https://vuex.vuejs.org/vuex.png\">\n\n`描述`\n\n1. 当组件调用dispatch方法时会触发vuex的action方法,在action方法中我们可以执行异步操作(api的请求...)\n2. 在action方法中我们可以通过调用mutation方法来更新state中的数据\n3. 一旦state中的数据发生变化,那么用state数据渲染的相关组件视图就会发生变化\n4. 当然,在实际开发中,不一定要按照这个流程来,可以根据实际情况来修改流程\n\n\n## vuex的基本使用\n\nvuex共有以下5部分组成\n1. getter(计算)\n2. state(数据源)\n3. mutation(修改数据源的方法)\n4. action(组件修改state的方法)\n5. module(模块化)\n\n#### getter\n我们可以使用getter进行一些数据源的派生计算,例如我想要获取数据源并且进行过滤,这时候我们就可以使用getter\n\n在组件中,我们可以使用mapGetter方法来获取数据源,该方法来自vuex实例对象\n\n语法:`mapGetters(namespace?: string, map: Array<string> | Object<string>): Object`\n\n#### state\n\n数据源,用于存储数据\n\n在组件中,我们可以使用mapState方法来获取数据源,该方法来自vuex实例对象\n\n语法:`mapState(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\n#### mutations\n\n我们可以调用mutation来修改state中数据的值\n\n语法:`store.commit(mutation,...args)`\n\n#### actions\n\n我们可以在action中进行异步操作和修改数据源数据的操作\n\n语法:`store.dispatch(action,...args)`\n\n#### modules\n\n由于我们在实际开发过程中,vuex维护的数据源会越来越庞大,因此对vuex进行拆分是十分有必要的\n\n每一个module可以看作成一个小型的vuex\n\n\n#### demo\n\n```js\n// 引入相关库\n\n\n// 模块A\nconst moduleA = {\n    state:{\n        a:1\n    },\n    mutations:{\n        SET_A(state,a){\n            state.a = a;\n        }\n    },\n    actions:{\n        changeA({commit},a){\n            commit('SET_A',a)\n        }\n    },\n    namespaced:true\n}\n\n\n// 模块B\nconst moduleB = {\n    state:{\n        b:1\n    },\n    mutations:{\n        SET_A(state,b){\n            state.b = b;\n        }\n    },\n    actions:{\n        changeA({commit},b){\n            commit('SET_A',b)\n        }\n    },\n    namespaced:true\n}\n\n// getter定义\n\nconst getters = {\n    a:state.moduleA.a,\n    b:state.moduleB.b,\n    sumAB:state.moduleA.a+state.moduleB.b\n}\n\nexport default Vuex.Store({\n    getters,\n    modules:{\n        moduleA,\n        moduleB\n    }\n})\n```\n\n## 简单状态管理(store模式)\n\n在一些简单的应用中,我们使用vuex会给我们带来比较大的负担。\n\n我们可以根据vuex的工作思路自己实现一个简单的数据共享对象\n\n\n`store模式简单`\n```js\nconst store = {\n    state:{\n        a:1\n    },\n    actions:{\n        changeA(a){\n            this.state.a = a;\n        }\n    }\n}\n```\n\n`组件一`\n```vue\n<template>\n    <h1>state.a</h1>\n</template>\n<script>\nimport { state } from 'store';\n\nexport default{\n    data(){\n        return{\n            state\n        }\n    }\n}\n</script>\n```\n\n`组件二`\n```vue\n<template>\n    <h1>state.a+1</h1>\n    <button @click=\"click\">click</button>\n</template>\n<script>\nimport { state,action } from 'store';\n\nexport default{\n    data(){\n        return{\n            state\n        }\n    },\n    methods:{\n        click(){\n            action.changeA(10);\n        }\n    }\n}\n</script>\n```\n\n描述\n\n1. 当我们点击组件2的按钮时,会触发action.changeA方法,并向其传递参数10\n2. 此时组件2的视图就会发生变化,且store.state.a的值也会发生变化\n3. 组件1的视图也会发生变化,因为组件1渲染时所使用的数据来自store.state.a,因为store.state.a发生变化,组件1的视图就发生了变化\n4. 此时组件1的a和组件2的a都来自store.state.a。就实现了组件们的数据共享\n","source":"_posts/前端/vue/vue2 vuex.md","raw":"---\ntitle: vue2 vuex\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-02-18\ncomments: false\ndescription: vue2 vuex\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n## 前言\n\nvuex是一个专门为vue应用程序开发的状态管理模式。它的出现是为了处理多个组件共同使用一个数据源渲染视图的问题\n\n当我们通过调用vuex的方法来改变数据时,跟数据相关的组件们视图就会同时发生变化\n\nvuex可以帮我们集中管理数据,存储多个组件共享的数据状态\n\nvuex的工作流程如下图所示\n\n<img src=\"https://vuex.vuejs.org/vuex.png\">\n\n`描述`\n\n1. 当组件调用dispatch方法时会触发vuex的action方法,在action方法中我们可以执行异步操作(api的请求...)\n2. 在action方法中我们可以通过调用mutation方法来更新state中的数据\n3. 一旦state中的数据发生变化,那么用state数据渲染的相关组件视图就会发生变化\n4. 当然,在实际开发中,不一定要按照这个流程来,可以根据实际情况来修改流程\n\n\n## vuex的基本使用\n\nvuex共有以下5部分组成\n1. getter(计算)\n2. state(数据源)\n3. mutation(修改数据源的方法)\n4. action(组件修改state的方法)\n5. module(模块化)\n\n#### getter\n我们可以使用getter进行一些数据源的派生计算,例如我想要获取数据源并且进行过滤,这时候我们就可以使用getter\n\n在组件中,我们可以使用mapGetter方法来获取数据源,该方法来自vuex实例对象\n\n语法:`mapGetters(namespace?: string, map: Array<string> | Object<string>): Object`\n\n#### state\n\n数据源,用于存储数据\n\n在组件中,我们可以使用mapState方法来获取数据源,该方法来自vuex实例对象\n\n语法:`mapState(namespace?: string, map: Array<string> | Object<string | function>): Object`\n\n#### mutations\n\n我们可以调用mutation来修改state中数据的值\n\n语法:`store.commit(mutation,...args)`\n\n#### actions\n\n我们可以在action中进行异步操作和修改数据源数据的操作\n\n语法:`store.dispatch(action,...args)`\n\n#### modules\n\n由于我们在实际开发过程中,vuex维护的数据源会越来越庞大,因此对vuex进行拆分是十分有必要的\n\n每一个module可以看作成一个小型的vuex\n\n\n#### demo\n\n```js\n// 引入相关库\n\n\n// 模块A\nconst moduleA = {\n    state:{\n        a:1\n    },\n    mutations:{\n        SET_A(state,a){\n            state.a = a;\n        }\n    },\n    actions:{\n        changeA({commit},a){\n            commit('SET_A',a)\n        }\n    },\n    namespaced:true\n}\n\n\n// 模块B\nconst moduleB = {\n    state:{\n        b:1\n    },\n    mutations:{\n        SET_A(state,b){\n            state.b = b;\n        }\n    },\n    actions:{\n        changeA({commit},b){\n            commit('SET_A',b)\n        }\n    },\n    namespaced:true\n}\n\n// getter定义\n\nconst getters = {\n    a:state.moduleA.a,\n    b:state.moduleB.b,\n    sumAB:state.moduleA.a+state.moduleB.b\n}\n\nexport default Vuex.Store({\n    getters,\n    modules:{\n        moduleA,\n        moduleB\n    }\n})\n```\n\n## 简单状态管理(store模式)\n\n在一些简单的应用中,我们使用vuex会给我们带来比较大的负担。\n\n我们可以根据vuex的工作思路自己实现一个简单的数据共享对象\n\n\n`store模式简单`\n```js\nconst store = {\n    state:{\n        a:1\n    },\n    actions:{\n        changeA(a){\n            this.state.a = a;\n        }\n    }\n}\n```\n\n`组件一`\n```vue\n<template>\n    <h1>state.a</h1>\n</template>\n<script>\nimport { state } from 'store';\n\nexport default{\n    data(){\n        return{\n            state\n        }\n    }\n}\n</script>\n```\n\n`组件二`\n```vue\n<template>\n    <h1>state.a+1</h1>\n    <button @click=\"click\">click</button>\n</template>\n<script>\nimport { state,action } from 'store';\n\nexport default{\n    data(){\n        return{\n            state\n        }\n    },\n    methods:{\n        click(){\n            action.changeA(10);\n        }\n    }\n}\n</script>\n```\n\n描述\n\n1. 当我们点击组件2的按钮时,会触发action.changeA方法,并向其传递参数10\n2. 此时组件2的视图就会发生变化,且store.state.a的值也会发生变化\n3. 组件1的视图也会发生变化,因为组件1渲染时所使用的数据来自store.state.a,因为store.state.a发生变化,组件1的视图就发生了变化\n4. 此时组件1的a和组件2的a都来自store.state.a。就实现了组件们的数据共享\n","slug":"前端/vue/vue2 vuex","published":1,"updated":"2023-05-12T23:28:10.996Z","layout":"post","link":"","_id":"clhws1t2y001z2h1798wthyew","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>vuex是一个专门为vue应用程序开发的状态管理模式。它的出现是为了处理多个组件共同使用一个数据源渲染视图的问题</p>\n<p>当我们通过调用vuex的方法来改变数据时,跟数据相关的组件们视图就会同时发生变化</p>\n<p>vuex可以帮我们集中管理数据,存储多个组件共享的数据状态</p>\n<p>vuex的工作流程如下图所示</p>\n<img src=\"https://vuex.vuejs.org/vuex.png\">\n\n<p><code>描述</code></p>\n<ol>\n<li>当组件调用dispatch方法时会触发vuex的action方法,在action方法中我们可以执行异步操作(api的请求…)</li>\n<li>在action方法中我们可以通过调用mutation方法来更新state中的数据</li>\n<li>一旦state中的数据发生变化,那么用state数据渲染的相关组件视图就会发生变化</li>\n<li>当然,在实际开发中,不一定要按照这个流程来,可以根据实际情况来修改流程</li>\n</ol>\n<h2 id=\"vuex的基本使用\"><a href=\"#vuex的基本使用\" class=\"headerlink\" title=\"vuex的基本使用\"></a>vuex的基本使用</h2><p>vuex共有以下5部分组成</p>\n<ol>\n<li>getter(计算)</li>\n<li>state(数据源)</li>\n<li>mutation(修改数据源的方法)</li>\n<li>action(组件修改state的方法)</li>\n<li>module(模块化)</li>\n</ol>\n<h4 id=\"getter\"><a href=\"#getter\" class=\"headerlink\" title=\"getter\"></a>getter</h4><p>我们可以使用getter进行一些数据源的派生计算,例如我想要获取数据源并且进行过滤,这时候我们就可以使用getter</p>\n<p>在组件中,我们可以使用mapGetter方法来获取数据源,该方法来自vuex实例对象</p>\n<p>语法:<code>mapGetters(namespace?: string, map: Array&lt;string&gt; | Object&lt;string&gt;): Object</code></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p>数据源,用于存储数据</p>\n<p>在组件中,我们可以使用mapState方法来获取数据源,该方法来自vuex实例对象</p>\n<p>语法:<code>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p>\n<h4 id=\"mutations\"><a href=\"#mutations\" class=\"headerlink\" title=\"mutations\"></a>mutations</h4><p>我们可以调用mutation来修改state中数据的值</p>\n<p>语法:<code>store.commit(mutation,...args)</code></p>\n<h4 id=\"actions\"><a href=\"#actions\" class=\"headerlink\" title=\"actions\"></a>actions</h4><p>我们可以在action中进行异步操作和修改数据源数据的操作</p>\n<p>语法:<code>store.dispatch(action,...args)</code></p>\n<h4 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h4><p>由于我们在实际开发过程中,vuex维护的数据源会越来越庞大,因此对vuex进行拆分是十分有必要的</p>\n<p>每一个module可以看作成一个小型的vuex</p>\n<h4 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h4><pre><code class=\"js\">// 引入相关库\n\n\n// 模块A\nconst moduleA = &#123;\n    state:&#123;\n        a:1\n    &#125;,\n    mutations:&#123;\n        SET_A(state,a)&#123;\n            state.a = a;\n        &#125;\n    &#125;,\n    actions:&#123;\n        changeA(&#123;commit&#125;,a)&#123;\n            commit(&#39;SET_A&#39;,a)\n        &#125;\n    &#125;,\n    namespaced:true\n&#125;\n\n\n// 模块B\nconst moduleB = &#123;\n    state:&#123;\n        b:1\n    &#125;,\n    mutations:&#123;\n        SET_A(state,b)&#123;\n            state.b = b;\n        &#125;\n    &#125;,\n    actions:&#123;\n        changeA(&#123;commit&#125;,b)&#123;\n            commit(&#39;SET_A&#39;,b)\n        &#125;\n    &#125;,\n    namespaced:true\n&#125;\n\n// getter定义\n\nconst getters = &#123;\n    a:state.moduleA.a,\n    b:state.moduleB.b,\n    sumAB:state.moduleA.a+state.moduleB.b\n&#125;\n\nexport default Vuex.Store(&#123;\n    getters,\n    modules:&#123;\n        moduleA,\n        moduleB\n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"简单状态管理-store模式\"><a href=\"#简单状态管理-store模式\" class=\"headerlink\" title=\"简单状态管理(store模式)\"></a>简单状态管理(store模式)</h2><p>在一些简单的应用中,我们使用vuex会给我们带来比较大的负担。</p>\n<p>我们可以根据vuex的工作思路自己实现一个简单的数据共享对象</p>\n<p><code>store模式简单</code></p>\n<pre><code class=\"js\">const store = &#123;\n    state:&#123;\n        a:1\n    &#125;,\n    actions:&#123;\n        changeA(a)&#123;\n            this.state.a = a;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><code>组件一</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;h1&gt;state.a&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport &#123; state &#125; from &#39;store&#39;;\n\nexport default&#123;\n    data()&#123;\n        return&#123;\n            state\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p><code>组件二</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;h1&gt;state.a+1&lt;/h1&gt;\n    &lt;button @click=&quot;click&quot;&gt;click&lt;/button&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport &#123; state,action &#125; from &#39;store&#39;;\n\nexport default&#123;\n    data()&#123;\n        return&#123;\n            state\n        &#125;\n    &#125;,\n    methods:&#123;\n        click()&#123;\n            action.changeA(10);\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>描述</p>\n<ol>\n<li>当我们点击组件2的按钮时,会触发action.changeA方法,并向其传递参数10</li>\n<li>此时组件2的视图就会发生变化,且store.state.a的值也会发生变化</li>\n<li>组件1的视图也会发生变化,因为组件1渲染时所使用的数据来自store.state.a,因为store.state.a发生变化,组件1的视图就发生了变化</li>\n<li>此时组件1的a和组件2的a都来自store.state.a。就实现了组件们的数据共享</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>vuex是一个专门为vue应用程序开发的状态管理模式。它的出现是为了处理多个组件共同使用一个数据源渲染视图的问题</p>\n<p>当我们通过调用vuex的方法来改变数据时,跟数据相关的组件们视图就会同时发生变化</p>\n<p>vuex可以帮我们集中管理数据,存储多个组件共享的数据状态</p>\n<p>vuex的工作流程如下图所示</p>\n<img src=\"https://vuex.vuejs.org/vuex.png\">\n\n<p><code>描述</code></p>\n<ol>\n<li>当组件调用dispatch方法时会触发vuex的action方法,在action方法中我们可以执行异步操作(api的请求…)</li>\n<li>在action方法中我们可以通过调用mutation方法来更新state中的数据</li>\n<li>一旦state中的数据发生变化,那么用state数据渲染的相关组件视图就会发生变化</li>\n<li>当然,在实际开发中,不一定要按照这个流程来,可以根据实际情况来修改流程</li>\n</ol>\n<h2 id=\"vuex的基本使用\"><a href=\"#vuex的基本使用\" class=\"headerlink\" title=\"vuex的基本使用\"></a>vuex的基本使用</h2><p>vuex共有以下5部分组成</p>\n<ol>\n<li>getter(计算)</li>\n<li>state(数据源)</li>\n<li>mutation(修改数据源的方法)</li>\n<li>action(组件修改state的方法)</li>\n<li>module(模块化)</li>\n</ol>\n<h4 id=\"getter\"><a href=\"#getter\" class=\"headerlink\" title=\"getter\"></a>getter</h4><p>我们可以使用getter进行一些数据源的派生计算,例如我想要获取数据源并且进行过滤,这时候我们就可以使用getter</p>\n<p>在组件中,我们可以使用mapGetter方法来获取数据源,该方法来自vuex实例对象</p>\n<p>语法:<code>mapGetters(namespace?: string, map: Array&lt;string&gt; | Object&lt;string&gt;): Object</code></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p>数据源,用于存储数据</p>\n<p>在组件中,我们可以使用mapState方法来获取数据源,该方法来自vuex实例对象</p>\n<p>语法:<code>mapState(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</code></p>\n<h4 id=\"mutations\"><a href=\"#mutations\" class=\"headerlink\" title=\"mutations\"></a>mutations</h4><p>我们可以调用mutation来修改state中数据的值</p>\n<p>语法:<code>store.commit(mutation,...args)</code></p>\n<h4 id=\"actions\"><a href=\"#actions\" class=\"headerlink\" title=\"actions\"></a>actions</h4><p>我们可以在action中进行异步操作和修改数据源数据的操作</p>\n<p>语法:<code>store.dispatch(action,...args)</code></p>\n<h4 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h4><p>由于我们在实际开发过程中,vuex维护的数据源会越来越庞大,因此对vuex进行拆分是十分有必要的</p>\n<p>每一个module可以看作成一个小型的vuex</p>\n<h4 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h4><pre><code class=\"js\">// 引入相关库\n\n\n// 模块A\nconst moduleA = &#123;\n    state:&#123;\n        a:1\n    &#125;,\n    mutations:&#123;\n        SET_A(state,a)&#123;\n            state.a = a;\n        &#125;\n    &#125;,\n    actions:&#123;\n        changeA(&#123;commit&#125;,a)&#123;\n            commit(&#39;SET_A&#39;,a)\n        &#125;\n    &#125;,\n    namespaced:true\n&#125;\n\n\n// 模块B\nconst moduleB = &#123;\n    state:&#123;\n        b:1\n    &#125;,\n    mutations:&#123;\n        SET_A(state,b)&#123;\n            state.b = b;\n        &#125;\n    &#125;,\n    actions:&#123;\n        changeA(&#123;commit&#125;,b)&#123;\n            commit(&#39;SET_A&#39;,b)\n        &#125;\n    &#125;,\n    namespaced:true\n&#125;\n\n// getter定义\n\nconst getters = &#123;\n    a:state.moduleA.a,\n    b:state.moduleB.b,\n    sumAB:state.moduleA.a+state.moduleB.b\n&#125;\n\nexport default Vuex.Store(&#123;\n    getters,\n    modules:&#123;\n        moduleA,\n        moduleB\n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"简单状态管理-store模式\"><a href=\"#简单状态管理-store模式\" class=\"headerlink\" title=\"简单状态管理(store模式)\"></a>简单状态管理(store模式)</h2><p>在一些简单的应用中,我们使用vuex会给我们带来比较大的负担。</p>\n<p>我们可以根据vuex的工作思路自己实现一个简单的数据共享对象</p>\n<p><code>store模式简单</code></p>\n<pre><code class=\"js\">const store = &#123;\n    state:&#123;\n        a:1\n    &#125;,\n    actions:&#123;\n        changeA(a)&#123;\n            this.state.a = a;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><code>组件一</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;h1&gt;state.a&lt;/h1&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport &#123; state &#125; from &#39;store&#39;;\n\nexport default&#123;\n    data()&#123;\n        return&#123;\n            state\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p><code>组件二</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;h1&gt;state.a+1&lt;/h1&gt;\n    &lt;button @click=&quot;click&quot;&gt;click&lt;/button&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport &#123; state,action &#125; from &#39;store&#39;;\n\nexport default&#123;\n    data()&#123;\n        return&#123;\n            state\n        &#125;\n    &#125;,\n    methods:&#123;\n        click()&#123;\n            action.changeA(10);\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p>描述</p>\n<ol>\n<li>当我们点击组件2的按钮时,会触发action.changeA方法,并向其传递参数10</li>\n<li>此时组件2的视图就会发生变化,且store.state.a的值也会发生变化</li>\n<li>组件1的视图也会发生变化,因为组件1渲染时所使用的数据来自store.state.a,因为store.state.a发生变化,组件1的视图就发生了变化</li>\n<li>此时组件1的a和组件2的a都来自store.state.a。就实现了组件们的数据共享</li>\n</ol>\n"},{"title":"vue2的基本认识和使用","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-01-20T16:00:00.000Z","comments":0,"description":"vue2的基本认识和使用","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n## 参考资料\n\n1. 官方文档: https://vuejs.org/\n2. github仓库: https://github.com/vuejs/vue\n\n## 基本认识\n1. 是一套用于构建用户界面的渐进式框架，只关注视图层\n2. 遵循MVVM模式\n3. 可以轻松引入vue相关插件或者结合第三方开发项目进行开发\n4. 借鉴angular的模板和数据绑定\n5. 借鉴react的组件化和虚拟DOM技术\n\n## 相关生态\n1. [vue-cli](https://cli.vuejs.org/zh/):vue脚手架\n2. [axios](https://github.com/axios/axios):ajax请求\n3. [vue-router](https://router.vuejs.org/zh/):SPA路由控制\n4. [vuex](https://vuex.vuejs.org/zh/):状态管理\n5. [element-ui](https://element.eleme.cn/#/zh-CN):基于vue的UI组件库(PC端)\n6. [mint-ui](http://mint-ui.github.io/#!/zh-cn):基于vue的UI组件库(移动端)\n7. [vue-element-admin](https://panjiachen.gitee.io/vue-element-admin-site/zh/):基于vue,element-ui等相关库所开发的后台管理模板\n\n## 安装\n\n#### 1. CDN引入\n直接使用script标签引入\n\n```js\n// 开发环境下使用，在开发中会给出友好的提示\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n// 开发环境下使用，会压缩代码，减少代码体积\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js\"></script>\n```\n\n#### 2. NPM引入\n前提要安装nodejs(网址:https://nodejs.org/en/)\n\n安装:`npm i vue --save`\n\n`使用`\n\n```js\nimport Vue from 'vue';\n\nnew Vue({\n    // ...option\n})\n```\n\n## 简单使用(Hello World)\n\n#### vue的简单使用总共分为以下几步\n1. 获取一个DOM容器\n2. new 一个vue的实例对象\n3. 传递创建该实例对象所需要的参数配置\n\n#### demo\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            {{msg}}\n        </div>\n        <script>\n            // 创建Vue的实例对象，并传入配置对象\n            var vm = new Vue({\n                // 获取容器\n                el:\"#app\",\n                data(){\n                    msg:\"hello world\"\n                }\n            });\n            /**\n             *  \n             * 最后,页面会显示hello world\n             * \n             * /\n        </script>\n    </body>\n</html>\n```\n\n## 基本语法\n\n#### 声明式渲染\n1. 双大括号:将实例对象中的data数据渲染到页面中\n2. v-html:用于输出HTML代码\n3. v-text:用于输出文本\n\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            {{msg}}\n            <div v-html=\"innerHTML\"></div>\n            <div v-text=\"textContent\"></div>\n        </div>\n        <script>     \n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    msg:\"hello world\",\n                    innerHTML:\"<h1>innerHTML</h1>\"\n                    textContent:\"textContent\"\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n#### 条件渲染\n1. v-if:用于条件性地渲染一块内容\n2. v-show:用于控制display的值\n3. v-if vs v-show  \n\n```js\n// v-show只是简单的基于CSS进行切换\n// v-if会控制该元素是否参与DOM树,如果false就从DOM树中删除销毁\n// 如果需要非常频繁地切换，则使用v-show较好;如何在运行时条件很少改变,则使用v-if较好\n```\n\n#### 循环渲染(v-for)\n1. 遍历数组(item in items)  \n\n我们可以使用v-for基于一个数组来渲染一个列表，语法为item in items,其中items是data中是源数据，而item则是被迭代的数组元素的别名\n\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            <ul>\n                <li v-for=\"(item,index) in items\" :key=\"index\">{{item}}</li>\n            </ul>\n        </div>\n        <script>\n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    items: [\n                        { message: 'Foo' },\n                        { message: 'Bar' }\n                    ];\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n2. 遍历对象 \n\n我们可以使用v-for来遍历一个对象的属性\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            <ul>\n                <li v-for=\"(value,name,index) in obj\" :key=\"index\">\n                    {{name}}:{{value}}\n                </li>\n            </ul>\n        </div>\n        <script>\n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    obj:{\n                        name:\"zhangsan\",\n                        age:24\n                    }\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n3. 数组更新检测\n\nVue对一个数组的变异方法进行包裹，所以调用以下方法会触发视图更新\n```js\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n```\n\n#### 计算属性和监听器(computed&watch)\n##### computed  \n1. 在computed属性对象中定义计算属性的方法\n2. 在页面中使用{{方法名}}来显示计算的结果\n\n##### 监视属性\n1. 通过vm对象的$watch或watch配置来监视指定的属性\n2. 当属性变化时,回调函数自动调用,在函数内部进行计算\n\n##### 计算属性高级\n1. 通过getter/setter实现对属性数据的显示个监视\n2. 计算属性存在缓存,多次读取只执行一个getter计算\n\n#### Style&Class\n##### class绑定\n1. :class='xxx'\n2. 表达式是字符串:'classA'\n3. 表达式是对象:{classA:isA,classB:isB}\n4. 表达式是数组:['classA','classB']\n\n##### style绑定\n1. :style=\"{color:activeColor,fontSize:fontSize+'px'}\"\n2. 其中activeColor/fontSize是data属性\n\n##### demo\n```vue\n<style>\n    .classA{\n        color:red;\n    }\n    .classB{\n        background:blue;\n    }\n    .classC{\n        font-size:20px;\n    }   \n</style>\n\n<template>\n<div id=\"demo\">\n    <h2>1.class绑定::class='xxx'</h2>\n    <p class=\"classB\" :class=\"a\">表达式是字符串:'classA'</p>\n    <p :class=\"{classA:isA,classB:isB}\">表达式是对象:{classA:isA,classB:isB}</p>\n    <p :class=\"['classA','classC']\">表达式是数组:['classA','classB']</p>\n\n    <h2>2.style绑定</h2>\n    <p :style=\"{color,fontSize}\">\n        style=\"{color:activeColor,fontSize:fontSize+'px'}\"\n    </p>\n\n    <button @click=\"update\">更新</button>\n\n</div>\n</template>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\nnew Vue({\n    el:'#demo',\n    data:{\n        a:'classA',\n        isA:true,\n        isB:false,\n        color:'red',\n        fontSize:'20px'\n    },\n    methods:{\n        update(){\n            this.a='classC'\n            this.isA=falsethis.isB=truethis.color='blue'\n            this.fontSize='30px'\n        }\n    }\n})\n</script>\n```\n\n#### 事件监听\n##### 绑定监听\n1. v-on:eventName=\"fun\"\n2. @eventName=\"fun\"\n3. @eventName=\"fun(参数)\"\n4. 默认事件形参:event\n5. 隐含属性对象:$event\n\n##### 事件修饰符\n1. .prevent:阻止事件的默认行为 event.preventDefault()\n2. .stop:停止事件冒泡 event.stopPropagation()\n\n##### 按键修饰符\n1. .keycode:操作的是某个keycode值的键\n2. .keyName:操作的是某个按键名的键(少部分)\n\n##### demo\n```vue\n<template>\n    <div id=\"example\">\n        <h2>1.绑定监听</h2>\n        <button v-on:click=\"test1\">Greet</button>\n        <button @click=\"test1\">Greet2</button>\n        <button @click=\"test2($event,'hello')\">Greet3</button>\n        <h2>2.事件修饰符</h2>\n        <!--阻止事件默认行为-->\n        <a href=\"http://www.baidu.com\"@click.prevent=\"test3\">百度一下</a>\n        <br/><br/>\n        <!--停止事件冒泡-->\n        <div style=\"width:200px;height:200px;background:red\" @click=\"test4\">\n            <div style=\"width:100px;height:100px;background:green\" @click.stop=\"test5\"></div>\n        </div>\n        <h2>3.按键修饰符</h2>\n        <input @keyup.8=\"test6\">\n        <input @keyup.enter=\"test6\">\n    </div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    newVue({\n        el:'#example',\n        data:{\n            name:'Vue.js'\n        },\n        methods:{\n            test1(event){\n                //方法内`this`指向vm\n                //alert('Hello'+this.name+'!')\n                //`event`是原生DOM事件\n                alert(event.target.innerHTML)\n            },\n            test2(event,msg){\n                alert(event.target.innerHTML+'---'+msg)\n            },\n            test3(){\n                alert('阻止事件的默认行为')\n            },\n            test4(){\n                alert('out')\n            },\n            test5(){\n                alert('inner')\n            },\n            test6(event){\n                alert(event.keyCode+'---'+event.target.value)\n            }\n        }\n    })\n</script>\n```\n\n#### 事件处理/表单输入绑定\n1. text/textarea\n2. checkbox\n3. radio\n4. select\n\n`demo`\n```vue\n<template>\n<div id=\"demo\">\n    <form @submit.prevent=\"handleSubmit\">\n        <span>用户名:</span>\n        <input type=\"text\"v-model=\"user.username\"><br>\n        <span>密码:</span>\n        <input type=\"password\" v-model=\"user.pwd\"><br>\n        <span>性别:</span>\n        <input type=\"radio\" id=\"female\" value=\"female\" v-model=\"user.sex\">\n        <label for=\"female\">女</label>\n        <input type=\"radio\" id=\"male\" value=\"male\" v-model=\"user.sex\">\n        <label for=\"male\">男</label><br>\n        <span>爱好:</span>\n        <input type=\"checkbox\" id=\"basket\" value=\"basketball\" v-model=\"user.likes\">\n        <label for=\"basket\">篮球</label>\n        <input type=\"checkbox\"id=\"foot\"value=\"football\"v-model=\"user.likes\">\n        <label for=\"foot\">足球</label>\n        <input type=\"checkbox\"id=\"pingpang\"value=\"pingpang\"v-model=\"user.likes\">\n        <label for=\"pingpang\">乒乓</label><br>\n        <span>城市:</span>\n        <select v-model=\"user.cityId\">\n            <option value=\"\">未选择</option>\n            <option v-for=\"cityinallCitys\" :value=\"city.id\">\n                {{city.name}}\n            </option>\n        </select>\n        <br/>\n        <span>介绍:</span>\n        <textarea v-model=\"user.desc\"rows=\"10\"></textarea><br><br>\n        <input type=\"submit\"value=\"注册\">\n    </form>\n</div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\nvar vm = new Vue({\n    el:\"#demo\",\n    data:{\n        user:{\n            username:'',\n            pwd:'',\n            sex:'female',\n            likes:[],\n            cityId:'',\n            desc:''\n        }\n        allCitys:[{id:1,name:'BJ'},{id:2,name:'SZ'},{id:4,name:'SH'}],\n    },\n    methods:{\n        handleSubmit(event){\n            alert(JSON.stringify(this.user);\n        }\n    }\n})\n</script>\n```\n\n## 指令\n\n#### 内置指令\n指令名  | 用处                                 | 其他  \n-|-|-\nv-text | 向页面输出文本                         | 相当于textContent |\nv-html | 向页面输出文本                         | 相当于innerHTML |\nv-if   | 通过控制元素是否在DOM树中来控制元素的显示  | 该属性会对DOM树产生影响 |\nv-else | 与v-if搭配使用,v-if后面的表达式为false才会执行该段代码        | 无 |\nv-show | 通过控制元素css来控制元素的显示            | 该属性不会对DOM树产生影响 |\nv-for  | 循环渲染元素                           | 一般需要为循环的元素指定key值 |\nv-model| 表单组件输入绑定监听                    | 主要常见表单组件:textare/checkbox/radio/input/select |\nv-on   | 事件绑定                             | 可简写为@事件名.事件修饰符 |\nv-bind | 属性绑定,后面的值会看作js代码运行        | 可简写为:attribute=value |\nv-clock | 防止闪现,与css配合:[v-cloak]{display:none}        | 可简写为:attribute=value |\n#### 自定义指令\n在Vue实例对象注册的指令为全局指令，在组件内部定义的指令为局部指令\n##### 注册全局指令\n```js\nVue.directive('my-directive',function(el,binding){\n    // todo something\n})\n```\n##### 注册局部指令\n```js\ndirectives:{\n    'my-directive':{\n        bind(el,binding){\n            // todo something\n        }\n    }\n}\n```\n##### 使用demo\n\nv-my-directive = 'xxx'\n\n需求:自定义2个指令\n1. 功能类型于v-text,但转换为全大写\n2. 功能类型于v-text,但转换为全小写\n\n```vue\n<template>\n    <div id=\"demo1\">\n       <p v-upper-text=\"msg\"></p>\n       <p v-lower-text=\"msg\"></p>\n    </div>\n    <div id=\"demo2\">\n       <p v-upper-text=\"msg2\"></p>\n       <p v-lower-text=\"msg2\"></p><!--局部指令,此处不能使用-->\n    </div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    //注册全局指令\n    Vue.directive('upper-text',function(el,binding){\n        el.innerHTML=binding.value.toUpperCase()\n    });\n\n    new Vue({\n        el:'#demo1',\n        data:{\n            msg2:'NBA love this game!'\n        },\n        directives:{\n            'lower-text':{\n                bind(el,binding){\n                    el.innerHTML = binding.value.toLowerCase();\n                }\n            }\n        }\n    })\n\n    new Vue({\n        el:'#demo2',\n        data:{\n            msg2:'ILikeYou'\n        }\n    })\n\n</script>\n```\n\n## 插件\n1. Vue插件是一个包含install方法的对象\n2. 通过install方法给vue或vue实例添加方法，定义全局z指令等\n\n#### 定义使用\n```js\n// vue-myPlugin.js\n// 定义Vue一个插件\n(function MyPlugin(){\n\n    const MyPlugin = {};\n\n    MyPlugin.install = function(Vue,options){\n\n        Vue.GlobalMethod = function(){\n            console.log('Vue函数对象方法执行');\n        };\n\n        Vue.directive('my-directive',function(el,binding){\n            el.innerHTML = 'MyPlugin my-directive'+binding.value\n        });\n\n        Vue.prototype.$method = function(){\n            console.log('vue'实例对象)\n        }\n    }\n\n    window.MyPlugin = MyPlugin;\n\n})();\n```\n在页面中使用\n\n```html\n<div id=\"demo\">\n    <p v-my-directive=\"msg\">\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"vue-myPlugin.js\"></script>\n<script>\n\n    Vue.use(MyPlugin);\n\n    var vm = new Vue({\n        el:\"#demo\",\n        data:{\n            msg:'atguigu'\n        }\n    })\n\n    Vue.myGlobalMethod();\n\n    vm.$myMethod();\n\n</script>\n```","source":"_posts/前端/vue/vue2的基本认识和使用.md","raw":"---\ntitle: vue2的基本认识和使用\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-01-21\ncomments: false\ndescription: vue2的基本认识和使用\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n## 参考资料\n\n1. 官方文档: https://vuejs.org/\n2. github仓库: https://github.com/vuejs/vue\n\n## 基本认识\n1. 是一套用于构建用户界面的渐进式框架，只关注视图层\n2. 遵循MVVM模式\n3. 可以轻松引入vue相关插件或者结合第三方开发项目进行开发\n4. 借鉴angular的模板和数据绑定\n5. 借鉴react的组件化和虚拟DOM技术\n\n## 相关生态\n1. [vue-cli](https://cli.vuejs.org/zh/):vue脚手架\n2. [axios](https://github.com/axios/axios):ajax请求\n3. [vue-router](https://router.vuejs.org/zh/):SPA路由控制\n4. [vuex](https://vuex.vuejs.org/zh/):状态管理\n5. [element-ui](https://element.eleme.cn/#/zh-CN):基于vue的UI组件库(PC端)\n6. [mint-ui](http://mint-ui.github.io/#!/zh-cn):基于vue的UI组件库(移动端)\n7. [vue-element-admin](https://panjiachen.gitee.io/vue-element-admin-site/zh/):基于vue,element-ui等相关库所开发的后台管理模板\n\n## 安装\n\n#### 1. CDN引入\n直接使用script标签引入\n\n```js\n// 开发环境下使用，在开发中会给出友好的提示\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n// 开发环境下使用，会压缩代码，减少代码体积\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js\"></script>\n```\n\n#### 2. NPM引入\n前提要安装nodejs(网址:https://nodejs.org/en/)\n\n安装:`npm i vue --save`\n\n`使用`\n\n```js\nimport Vue from 'vue';\n\nnew Vue({\n    // ...option\n})\n```\n\n## 简单使用(Hello World)\n\n#### vue的简单使用总共分为以下几步\n1. 获取一个DOM容器\n2. new 一个vue的实例对象\n3. 传递创建该实例对象所需要的参数配置\n\n#### demo\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            {{msg}}\n        </div>\n        <script>\n            // 创建Vue的实例对象，并传入配置对象\n            var vm = new Vue({\n                // 获取容器\n                el:\"#app\",\n                data(){\n                    msg:\"hello world\"\n                }\n            });\n            /**\n             *  \n             * 最后,页面会显示hello world\n             * \n             * /\n        </script>\n    </body>\n</html>\n```\n\n## 基本语法\n\n#### 声明式渲染\n1. 双大括号:将实例对象中的data数据渲染到页面中\n2. v-html:用于输出HTML代码\n3. v-text:用于输出文本\n\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            {{msg}}\n            <div v-html=\"innerHTML\"></div>\n            <div v-text=\"textContent\"></div>\n        </div>\n        <script>     \n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    msg:\"hello world\",\n                    innerHTML:\"<h1>innerHTML</h1>\"\n                    textContent:\"textContent\"\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n#### 条件渲染\n1. v-if:用于条件性地渲染一块内容\n2. v-show:用于控制display的值\n3. v-if vs v-show  \n\n```js\n// v-show只是简单的基于CSS进行切换\n// v-if会控制该元素是否参与DOM树,如果false就从DOM树中删除销毁\n// 如果需要非常频繁地切换，则使用v-show较好;如何在运行时条件很少改变,则使用v-if较好\n```\n\n#### 循环渲染(v-for)\n1. 遍历数组(item in items)  \n\n我们可以使用v-for基于一个数组来渲染一个列表，语法为item in items,其中items是data中是源数据，而item则是被迭代的数组元素的别名\n\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            <ul>\n                <li v-for=\"(item,index) in items\" :key=\"index\">{{item}}</li>\n            </ul>\n        </div>\n        <script>\n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    items: [\n                        { message: 'Foo' },\n                        { message: 'Bar' }\n                    ];\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n2. 遍历对象 \n\n我们可以使用v-for来遍历一个对象的属性\n```html\n<html>\n    <head>\n        <title>vue demo</title>\n        <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n    </head>\n    <body>\n        <div id=\"app\">\n            <ul>\n                <li v-for=\"(value,name,index) in obj\" :key=\"index\">\n                    {{name}}:{{value}}\n                </li>\n            </ul>\n        </div>\n        <script>\n            var vm = new Vue({\n                el:\"#app\",\n                data(){\n                    obj:{\n                        name:\"zhangsan\",\n                        age:24\n                    }\n                }\n            });\n        </script>\n    </body>\n</html>\n```\n\n3. 数组更新检测\n\nVue对一个数组的变异方法进行包裹，所以调用以下方法会触发视图更新\n```js\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n```\n\n#### 计算属性和监听器(computed&watch)\n##### computed  \n1. 在computed属性对象中定义计算属性的方法\n2. 在页面中使用{{方法名}}来显示计算的结果\n\n##### 监视属性\n1. 通过vm对象的$watch或watch配置来监视指定的属性\n2. 当属性变化时,回调函数自动调用,在函数内部进行计算\n\n##### 计算属性高级\n1. 通过getter/setter实现对属性数据的显示个监视\n2. 计算属性存在缓存,多次读取只执行一个getter计算\n\n#### Style&Class\n##### class绑定\n1. :class='xxx'\n2. 表达式是字符串:'classA'\n3. 表达式是对象:{classA:isA,classB:isB}\n4. 表达式是数组:['classA','classB']\n\n##### style绑定\n1. :style=\"{color:activeColor,fontSize:fontSize+'px'}\"\n2. 其中activeColor/fontSize是data属性\n\n##### demo\n```vue\n<style>\n    .classA{\n        color:red;\n    }\n    .classB{\n        background:blue;\n    }\n    .classC{\n        font-size:20px;\n    }   \n</style>\n\n<template>\n<div id=\"demo\">\n    <h2>1.class绑定::class='xxx'</h2>\n    <p class=\"classB\" :class=\"a\">表达式是字符串:'classA'</p>\n    <p :class=\"{classA:isA,classB:isB}\">表达式是对象:{classA:isA,classB:isB}</p>\n    <p :class=\"['classA','classC']\">表达式是数组:['classA','classB']</p>\n\n    <h2>2.style绑定</h2>\n    <p :style=\"{color,fontSize}\">\n        style=\"{color:activeColor,fontSize:fontSize+'px'}\"\n    </p>\n\n    <button @click=\"update\">更新</button>\n\n</div>\n</template>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\nnew Vue({\n    el:'#demo',\n    data:{\n        a:'classA',\n        isA:true,\n        isB:false,\n        color:'red',\n        fontSize:'20px'\n    },\n    methods:{\n        update(){\n            this.a='classC'\n            this.isA=falsethis.isB=truethis.color='blue'\n            this.fontSize='30px'\n        }\n    }\n})\n</script>\n```\n\n#### 事件监听\n##### 绑定监听\n1. v-on:eventName=\"fun\"\n2. @eventName=\"fun\"\n3. @eventName=\"fun(参数)\"\n4. 默认事件形参:event\n5. 隐含属性对象:$event\n\n##### 事件修饰符\n1. .prevent:阻止事件的默认行为 event.preventDefault()\n2. .stop:停止事件冒泡 event.stopPropagation()\n\n##### 按键修饰符\n1. .keycode:操作的是某个keycode值的键\n2. .keyName:操作的是某个按键名的键(少部分)\n\n##### demo\n```vue\n<template>\n    <div id=\"example\">\n        <h2>1.绑定监听</h2>\n        <button v-on:click=\"test1\">Greet</button>\n        <button @click=\"test1\">Greet2</button>\n        <button @click=\"test2($event,'hello')\">Greet3</button>\n        <h2>2.事件修饰符</h2>\n        <!--阻止事件默认行为-->\n        <a href=\"http://www.baidu.com\"@click.prevent=\"test3\">百度一下</a>\n        <br/><br/>\n        <!--停止事件冒泡-->\n        <div style=\"width:200px;height:200px;background:red\" @click=\"test4\">\n            <div style=\"width:100px;height:100px;background:green\" @click.stop=\"test5\"></div>\n        </div>\n        <h2>3.按键修饰符</h2>\n        <input @keyup.8=\"test6\">\n        <input @keyup.enter=\"test6\">\n    </div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    newVue({\n        el:'#example',\n        data:{\n            name:'Vue.js'\n        },\n        methods:{\n            test1(event){\n                //方法内`this`指向vm\n                //alert('Hello'+this.name+'!')\n                //`event`是原生DOM事件\n                alert(event.target.innerHTML)\n            },\n            test2(event,msg){\n                alert(event.target.innerHTML+'---'+msg)\n            },\n            test3(){\n                alert('阻止事件的默认行为')\n            },\n            test4(){\n                alert('out')\n            },\n            test5(){\n                alert('inner')\n            },\n            test6(event){\n                alert(event.keyCode+'---'+event.target.value)\n            }\n        }\n    })\n</script>\n```\n\n#### 事件处理/表单输入绑定\n1. text/textarea\n2. checkbox\n3. radio\n4. select\n\n`demo`\n```vue\n<template>\n<div id=\"demo\">\n    <form @submit.prevent=\"handleSubmit\">\n        <span>用户名:</span>\n        <input type=\"text\"v-model=\"user.username\"><br>\n        <span>密码:</span>\n        <input type=\"password\" v-model=\"user.pwd\"><br>\n        <span>性别:</span>\n        <input type=\"radio\" id=\"female\" value=\"female\" v-model=\"user.sex\">\n        <label for=\"female\">女</label>\n        <input type=\"radio\" id=\"male\" value=\"male\" v-model=\"user.sex\">\n        <label for=\"male\">男</label><br>\n        <span>爱好:</span>\n        <input type=\"checkbox\" id=\"basket\" value=\"basketball\" v-model=\"user.likes\">\n        <label for=\"basket\">篮球</label>\n        <input type=\"checkbox\"id=\"foot\"value=\"football\"v-model=\"user.likes\">\n        <label for=\"foot\">足球</label>\n        <input type=\"checkbox\"id=\"pingpang\"value=\"pingpang\"v-model=\"user.likes\">\n        <label for=\"pingpang\">乒乓</label><br>\n        <span>城市:</span>\n        <select v-model=\"user.cityId\">\n            <option value=\"\">未选择</option>\n            <option v-for=\"cityinallCitys\" :value=\"city.id\">\n                {{city.name}}\n            </option>\n        </select>\n        <br/>\n        <span>介绍:</span>\n        <textarea v-model=\"user.desc\"rows=\"10\"></textarea><br><br>\n        <input type=\"submit\"value=\"注册\">\n    </form>\n</div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\nvar vm = new Vue({\n    el:\"#demo\",\n    data:{\n        user:{\n            username:'',\n            pwd:'',\n            sex:'female',\n            likes:[],\n            cityId:'',\n            desc:''\n        }\n        allCitys:[{id:1,name:'BJ'},{id:2,name:'SZ'},{id:4,name:'SH'}],\n    },\n    methods:{\n        handleSubmit(event){\n            alert(JSON.stringify(this.user);\n        }\n    }\n})\n</script>\n```\n\n## 指令\n\n#### 内置指令\n指令名  | 用处                                 | 其他  \n-|-|-\nv-text | 向页面输出文本                         | 相当于textContent |\nv-html | 向页面输出文本                         | 相当于innerHTML |\nv-if   | 通过控制元素是否在DOM树中来控制元素的显示  | 该属性会对DOM树产生影响 |\nv-else | 与v-if搭配使用,v-if后面的表达式为false才会执行该段代码        | 无 |\nv-show | 通过控制元素css来控制元素的显示            | 该属性不会对DOM树产生影响 |\nv-for  | 循环渲染元素                           | 一般需要为循环的元素指定key值 |\nv-model| 表单组件输入绑定监听                    | 主要常见表单组件:textare/checkbox/radio/input/select |\nv-on   | 事件绑定                             | 可简写为@事件名.事件修饰符 |\nv-bind | 属性绑定,后面的值会看作js代码运行        | 可简写为:attribute=value |\nv-clock | 防止闪现,与css配合:[v-cloak]{display:none}        | 可简写为:attribute=value |\n#### 自定义指令\n在Vue实例对象注册的指令为全局指令，在组件内部定义的指令为局部指令\n##### 注册全局指令\n```js\nVue.directive('my-directive',function(el,binding){\n    // todo something\n})\n```\n##### 注册局部指令\n```js\ndirectives:{\n    'my-directive':{\n        bind(el,binding){\n            // todo something\n        }\n    }\n}\n```\n##### 使用demo\n\nv-my-directive = 'xxx'\n\n需求:自定义2个指令\n1. 功能类型于v-text,但转换为全大写\n2. 功能类型于v-text,但转换为全小写\n\n```vue\n<template>\n    <div id=\"demo1\">\n       <p v-upper-text=\"msg\"></p>\n       <p v-lower-text=\"msg\"></p>\n    </div>\n    <div id=\"demo2\">\n       <p v-upper-text=\"msg2\"></p>\n       <p v-lower-text=\"msg2\"></p><!--局部指令,此处不能使用-->\n    </div>\n</template>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script>\n    //注册全局指令\n    Vue.directive('upper-text',function(el,binding){\n        el.innerHTML=binding.value.toUpperCase()\n    });\n\n    new Vue({\n        el:'#demo1',\n        data:{\n            msg2:'NBA love this game!'\n        },\n        directives:{\n            'lower-text':{\n                bind(el,binding){\n                    el.innerHTML = binding.value.toLowerCase();\n                }\n            }\n        }\n    })\n\n    new Vue({\n        el:'#demo2',\n        data:{\n            msg2:'ILikeYou'\n        }\n    })\n\n</script>\n```\n\n## 插件\n1. Vue插件是一个包含install方法的对象\n2. 通过install方法给vue或vue实例添加方法，定义全局z指令等\n\n#### 定义使用\n```js\n// vue-myPlugin.js\n// 定义Vue一个插件\n(function MyPlugin(){\n\n    const MyPlugin = {};\n\n    MyPlugin.install = function(Vue,options){\n\n        Vue.GlobalMethod = function(){\n            console.log('Vue函数对象方法执行');\n        };\n\n        Vue.directive('my-directive',function(el,binding){\n            el.innerHTML = 'MyPlugin my-directive'+binding.value\n        });\n\n        Vue.prototype.$method = function(){\n            console.log('vue'实例对象)\n        }\n    }\n\n    window.MyPlugin = MyPlugin;\n\n})();\n```\n在页面中使用\n\n```html\n<div id=\"demo\">\n    <p v-my-directive=\"msg\">\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"vue-myPlugin.js\"></script>\n<script>\n\n    Vue.use(MyPlugin);\n\n    var vm = new Vue({\n        el:\"#demo\",\n        data:{\n            msg:'atguigu'\n        }\n    })\n\n    Vue.myGlobalMethod();\n\n    vm.$myMethod();\n\n</script>\n```","slug":"前端/vue/vue2的基本认识和使用","published":1,"updated":"2023-05-12T23:28:10.996Z","layout":"post","link":"","_id":"clhws1t2z00222h17d6bed0ad","content":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li>官方文档: <a href=\"https://vuejs.org/\">https://vuejs.org/</a></li>\n<li>github仓库: <a href=\"https://github.com/vuejs/vue\">https://github.com/vuejs/vue</a></li>\n</ol>\n<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><ol>\n<li>是一套用于构建用户界面的渐进式框架，只关注视图层</li>\n<li>遵循MVVM模式</li>\n<li>可以轻松引入vue相关插件或者结合第三方开发项目进行开发</li>\n<li>借鉴angular的模板和数据绑定</li>\n<li>借鉴react的组件化和虚拟DOM技术</li>\n</ol>\n<h2 id=\"相关生态\"><a href=\"#相关生态\" class=\"headerlink\" title=\"相关生态\"></a>相关生态</h2><ol>\n<li><a href=\"https://cli.vuejs.org/zh/\">vue-cli</a>:vue脚手架</li>\n<li><a href=\"https://github.com/axios/axios\">axios</a>:ajax请求</li>\n<li><a href=\"https://router.vuejs.org/zh/\">vue-router</a>:SPA路由控制</li>\n<li><a href=\"https://vuex.vuejs.org/zh/\">vuex</a>:状态管理</li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN\">element-ui</a>:基于vue的UI组件库(PC端)</li>\n<li><a href=\"http://mint-ui.github.io/#!/zh-cn\">mint-ui</a>:基于vue的UI组件库(移动端)</li>\n<li><a href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/\">vue-element-admin</a>:基于vue,element-ui等相关库所开发的后台管理模板</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h4 id=\"1-CDN引入\"><a href=\"#1-CDN引入\" class=\"headerlink\" title=\"1. CDN引入\"></a>1. CDN引入</h4><p>直接使用script标签引入</p>\n<pre><code class=\"js\">// 开发环境下使用，在开发中会给出友好的提示\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n// 开发环境下使用，会压缩代码，减少代码体积\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<h4 id=\"2-NPM引入\"><a href=\"#2-NPM引入\" class=\"headerlink\" title=\"2. NPM引入\"></a>2. NPM引入</h4><p>前提要安装nodejs(网址:<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>)</p>\n<p>安装:<code>npm i vue --save</code></p>\n<p><code>使用</code></p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;;\n\nnew Vue(&#123;\n    // ...option\n&#125;)\n</code></pre>\n<h2 id=\"简单使用-Hello-World\"><a href=\"#简单使用-Hello-World\" class=\"headerlink\" title=\"简单使用(Hello World)\"></a>简单使用(Hello World)</h2><h4 id=\"vue的简单使用总共分为以下几步\"><a href=\"#vue的简单使用总共分为以下几步\" class=\"headerlink\" title=\"vue的简单使用总共分为以下几步\"></a>vue的简单使用总共分为以下几步</h4><ol>\n<li>获取一个DOM容器</li>\n<li>new 一个vue的实例对象</li>\n<li>传递创建该实例对象所需要的参数配置</li>\n</ol>\n<h4 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h4><pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &#123;&#123;msg&#125;&#125;\n        &lt;/div&gt;\n        &lt;script&gt;\n            // 创建Vue的实例对象，并传入配置对象\n            var vm = new Vue(&#123;\n                // 获取容器\n                el:&quot;#app&quot;,\n                data()&#123;\n                    msg:&quot;hello world&quot;\n                &#125;\n            &#125;);\n            /**\n             *  \n             * 最后,页面会显示hello world\n             * \n             * /\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h4 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h4><ol>\n<li>双大括号:将实例对象中的data数据渲染到页面中</li>\n<li>v-html:用于输出HTML代码</li>\n<li>v-text:用于输出文本</li>\n</ol>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &#123;&#123;msg&#125;&#125;\n            &lt;div v-html=&quot;innerHTML&quot;&gt;&lt;/div&gt;\n            &lt;div v-text=&quot;textContent&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;script&gt;     \n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    msg:&quot;hello world&quot;,\n                    innerHTML:&quot;&lt;h1&gt;innerHTML&lt;/h1&gt;&quot;\n                    textContent:&quot;textContent&quot;\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h4><ol>\n<li>v-if:用于条件性地渲染一块内容</li>\n<li>v-show:用于控制display的值</li>\n<li>v-if vs v-show</li>\n</ol>\n<pre><code class=\"js\">// v-show只是简单的基于CSS进行切换\n// v-if会控制该元素是否参与DOM树,如果false就从DOM树中删除销毁\n// 如果需要非常频繁地切换，则使用v-show较好;如何在运行时条件很少改变,则使用v-if较好\n</code></pre>\n<h4 id=\"循环渲染-v-for\"><a href=\"#循环渲染-v-for\" class=\"headerlink\" title=\"循环渲染(v-for)\"></a>循环渲染(v-for)</h4><ol>\n<li>遍历数组(item in items)</li>\n</ol>\n<p>我们可以使用v-for基于一个数组来渲染一个列表，语法为item in items,其中items是data中是源数据，而item则是被迭代的数组元素的别名</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &lt;ul&gt;\n                &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;script&gt;\n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    items: [\n                        &#123; message: &#39;Foo&#39; &#125;,\n                        &#123; message: &#39;Bar&#39; &#125;\n                    ];\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"2\">\n<li>遍历对象</li>\n</ol>\n<p>我们可以使用v-for来遍历一个对象的属性</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &lt;ul&gt;\n                &lt;li v-for=&quot;(value,name,index) in obj&quot; :key=&quot;index&quot;&gt;\n                    &#123;&#123;name&#125;&#125;:&#123;&#123;value&#125;&#125;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;script&gt;\n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    obj:&#123;\n                        name:&quot;zhangsan&quot;,\n                        age:24\n                    &#125;\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>数组更新检测</li>\n</ol>\n<p>Vue对一个数组的变异方法进行包裹，所以调用以下方法会触发视图更新</p>\n<pre><code class=\"js\">push()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n</code></pre>\n<h4 id=\"计算属性和监听器-computed-amp-watch\"><a href=\"#计算属性和监听器-computed-amp-watch\" class=\"headerlink\" title=\"计算属性和监听器(computed&amp;watch)\"></a>计算属性和监听器(computed&amp;watch)</h4><h5 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h5><ol>\n<li>在computed属性对象中定义计算属性的方法</li>\n<li>在页面中使用来显示计算的结果</li>\n</ol>\n<h5 id=\"监视属性\"><a href=\"#监视属性\" class=\"headerlink\" title=\"监视属性\"></a>监视属性</h5><ol>\n<li>通过vm对象的$watch或watch配置来监视指定的属性</li>\n<li>当属性变化时,回调函数自动调用,在函数内部进行计算</li>\n</ol>\n<h5 id=\"计算属性高级\"><a href=\"#计算属性高级\" class=\"headerlink\" title=\"计算属性高级\"></a>计算属性高级</h5><ol>\n<li>通过getter&#x2F;setter实现对属性数据的显示个监视</li>\n<li>计算属性存在缓存,多次读取只执行一个getter计算</li>\n</ol>\n<h4 id=\"Style-amp-Class\"><a href=\"#Style-amp-Class\" class=\"headerlink\" title=\"Style&amp;Class\"></a>Style&amp;Class</h4><h5 id=\"class绑定\"><a href=\"#class绑定\" class=\"headerlink\" title=\"class绑定\"></a>class绑定</h5><ol>\n<li>:class&#x3D;’xxx’</li>\n<li>表达式是字符串:’classA’</li>\n<li>表达式是对象:{classA:isA,classB:isB}</li>\n<li>表达式是数组:[‘classA’,’classB’]</li>\n</ol>\n<h5 id=\"style绑定\"><a href=\"#style绑定\" class=\"headerlink\" title=\"style绑定\"></a>style绑定</h5><ol>\n<li>:style&#x3D;”{color:activeColor,fontSize:fontSize+’px’}”</li>\n<li>其中activeColor&#x2F;fontSize是data属性</li>\n</ol>\n<h5 id=\"demo-1\"><a href=\"#demo-1\" class=\"headerlink\" title=\"demo\"></a>demo</h5><pre><code class=\"vue\">&lt;style&gt;\n    .classA&#123;\n        color:red;\n    &#125;\n    .classB&#123;\n        background:blue;\n    &#125;\n    .classC&#123;\n        font-size:20px;\n    &#125;   \n&lt;/style&gt;\n\n&lt;template&gt;\n&lt;div id=&quot;demo&quot;&gt;\n    &lt;h2&gt;1.class绑定::class=&#39;xxx&#39;&lt;/h2&gt;\n    &lt;p class=&quot;classB&quot; :class=&quot;a&quot;&gt;表达式是字符串:&#39;classA&#39;&lt;/p&gt;\n    &lt;p :class=&quot;&#123;classA:isA,classB:isB&#125;&quot;&gt;表达式是对象:&#123;classA:isA,classB:isB&#125;&lt;/p&gt;\n    &lt;p :class=&quot;[&#39;classA&#39;,&#39;classC&#39;]&quot;&gt;表达式是数组:[&#39;classA&#39;,&#39;classB&#39;]&lt;/p&gt;\n\n    &lt;h2&gt;2.style绑定&lt;/h2&gt;\n    &lt;p :style=&quot;&#123;color,fontSize&#125;&quot;&gt;\n        style=&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;\n    &lt;/p&gt;\n\n    &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;\n\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nnew Vue(&#123;\n    el:&#39;#demo&#39;,\n    data:&#123;\n        a:&#39;classA&#39;,\n        isA:true,\n        isB:false,\n        color:&#39;red&#39;,\n        fontSize:&#39;20px&#39;\n    &#125;,\n    methods:&#123;\n        update()&#123;\n            this.a=&#39;classC&#39;\n            this.isA=falsethis.isB=truethis.color=&#39;blue&#39;\n            this.fontSize=&#39;30px&#39;\n        &#125;\n    &#125;\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><h5 id=\"绑定监听\"><a href=\"#绑定监听\" class=\"headerlink\" title=\"绑定监听\"></a>绑定监听</h5><ol>\n<li>v-on:eventName&#x3D;”fun”</li>\n<li>@eventName&#x3D;”fun”</li>\n<li>@eventName&#x3D;”fun(参数)”</li>\n<li>默认事件形参:event</li>\n<li>隐含属性对象:$event</li>\n</ol>\n<h5 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h5><ol>\n<li>.prevent:阻止事件的默认行为 event.preventDefault()</li>\n<li>.stop:停止事件冒泡 event.stopPropagation()</li>\n</ol>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><ol>\n<li>.keycode:操作的是某个keycode值的键</li>\n<li>.keyName:操作的是某个按键名的键(少部分)</li>\n</ol>\n<h5 id=\"demo-2\"><a href=\"#demo-2\" class=\"headerlink\" title=\"demo\"></a>demo</h5><pre><code class=\"vue\">&lt;template&gt;\n    &lt;div id=&quot;example&quot;&gt;\n        &lt;h2&gt;1.绑定监听&lt;/h2&gt;\n        &lt;button v-on:click=&quot;test1&quot;&gt;Greet&lt;/button&gt;\n        &lt;button @click=&quot;test1&quot;&gt;Greet2&lt;/button&gt;\n        &lt;button @click=&quot;test2($event,&#39;hello&#39;)&quot;&gt;Greet3&lt;/button&gt;\n        &lt;h2&gt;2.事件修饰符&lt;/h2&gt;\n        &lt;!--阻止事件默认行为--&gt;\n        &lt;a href=&quot;http://www.baidu.com&quot;@click.prevent=&quot;test3&quot;&gt;百度一下&lt;/a&gt;\n        &lt;br/&gt;&lt;br/&gt;\n        &lt;!--停止事件冒泡--&gt;\n        &lt;div style=&quot;width:200px;height:200px;background:red&quot; @click=&quot;test4&quot;&gt;\n            &lt;div style=&quot;width:100px;height:100px;background:green&quot; @click.stop=&quot;test5&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;h2&gt;3.按键修饰符&lt;/h2&gt;\n        &lt;input @keyup.8=&quot;test6&quot;&gt;\n        &lt;input @keyup.enter=&quot;test6&quot;&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    newVue(&#123;\n        el:&#39;#example&#39;,\n        data:&#123;\n            name:&#39;Vue.js&#39;\n        &#125;,\n        methods:&#123;\n            test1(event)&#123;\n                //方法内`this`指向vm\n                //alert(&#39;Hello&#39;+this.name+&#39;!&#39;)\n                //`event`是原生DOM事件\n                alert(event.target.innerHTML)\n            &#125;,\n            test2(event,msg)&#123;\n                alert(event.target.innerHTML+&#39;---&#39;+msg)\n            &#125;,\n            test3()&#123;\n                alert(&#39;阻止事件的默认行为&#39;)\n            &#125;,\n            test4()&#123;\n                alert(&#39;out&#39;)\n            &#125;,\n            test5()&#123;\n                alert(&#39;inner&#39;)\n            &#125;,\n            test6(event)&#123;\n                alert(event.keyCode+&#39;---&#39;+event.target.value)\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"事件处理-x2F-表单输入绑定\"><a href=\"#事件处理-x2F-表单输入绑定\" class=\"headerlink\" title=\"事件处理&#x2F;表单输入绑定\"></a>事件处理&#x2F;表单输入绑定</h4><ol>\n<li>text&#x2F;textarea</li>\n<li>checkbox</li>\n<li>radio</li>\n<li>select</li>\n</ol>\n<p><code>demo</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n&lt;div id=&quot;demo&quot;&gt;\n    &lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;\n        &lt;span&gt;用户名:&lt;/span&gt;\n        &lt;input type=&quot;text&quot;v-model=&quot;user.username&quot;&gt;&lt;br&gt;\n        &lt;span&gt;密码:&lt;/span&gt;\n        &lt;input type=&quot;password&quot; v-model=&quot;user.pwd&quot;&gt;&lt;br&gt;\n        &lt;span&gt;性别:&lt;/span&gt;\n        &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;female&quot; v-model=&quot;user.sex&quot;&gt;\n        &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;\n        &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;male&quot; v-model=&quot;user.sex&quot;&gt;\n        &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;br&gt;\n        &lt;span&gt;爱好:&lt;/span&gt;\n        &lt;input type=&quot;checkbox&quot; id=&quot;basket&quot; value=&quot;basketball&quot; v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;basket&quot;&gt;篮球&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot;id=&quot;foot&quot;value=&quot;football&quot;v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;foot&quot;&gt;足球&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot;id=&quot;pingpang&quot;value=&quot;pingpang&quot;v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;pingpang&quot;&gt;乒乓&lt;/label&gt;&lt;br&gt;\n        &lt;span&gt;城市:&lt;/span&gt;\n        &lt;select v-model=&quot;user.cityId&quot;&gt;\n            &lt;option value=&quot;&quot;&gt;未选择&lt;/option&gt;\n            &lt;option v-for=&quot;cityinallCitys&quot; :value=&quot;city.id&quot;&gt;\n                &#123;&#123;city.name&#125;&#125;\n            &lt;/option&gt;\n        &lt;/select&gt;\n        &lt;br/&gt;\n        &lt;span&gt;介绍:&lt;/span&gt;\n        &lt;textarea v-model=&quot;user.desc&quot;rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;\n        &lt;input type=&quot;submit&quot;value=&quot;注册&quot;&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar vm = new Vue(&#123;\n    el:&quot;#demo&quot;,\n    data:&#123;\n        user:&#123;\n            username:&#39;&#39;,\n            pwd:&#39;&#39;,\n            sex:&#39;female&#39;,\n            likes:[],\n            cityId:&#39;&#39;,\n            desc:&#39;&#39;\n        &#125;\n        allCitys:[&#123;id:1,name:&#39;BJ&#39;&#125;,&#123;id:2,name:&#39;SZ&#39;&#125;,&#123;id:4,name:&#39;SH&#39;&#125;],\n    &#125;,\n    methods:&#123;\n        handleSubmit(event)&#123;\n            alert(JSON.stringify(this.user);\n        &#125;\n    &#125;\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h4 id=\"内置指令\"><a href=\"#内置指令\" class=\"headerlink\" title=\"内置指令\"></a>内置指令</h4><table>\n<thead>\n<tr>\n<th>指令名</th>\n<th>用处</th>\n<th>其他</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v-text</td>\n<td>向页面输出文本</td>\n<td>相当于textContent</td>\n</tr>\n<tr>\n<td>v-html</td>\n<td>向页面输出文本</td>\n<td>相当于innerHTML</td>\n</tr>\n<tr>\n<td>v-if</td>\n<td>通过控制元素是否在DOM树中来控制元素的显示</td>\n<td>该属性会对DOM树产生影响</td>\n</tr>\n<tr>\n<td>v-else</td>\n<td>与v-if搭配使用,v-if后面的表达式为false才会执行该段代码</td>\n<td>无</td>\n</tr>\n<tr>\n<td>v-show</td>\n<td>通过控制元素css来控制元素的显示</td>\n<td>该属性不会对DOM树产生影响</td>\n</tr>\n<tr>\n<td>v-for</td>\n<td>循环渲染元素</td>\n<td>一般需要为循环的元素指定key值</td>\n</tr>\n<tr>\n<td>v-model</td>\n<td>表单组件输入绑定监听</td>\n<td>主要常见表单组件:textare&#x2F;checkbox&#x2F;radio&#x2F;input&#x2F;select</td>\n</tr>\n<tr>\n<td>v-on</td>\n<td>事件绑定</td>\n<td>可简写为@事件名.事件修饰符</td>\n</tr>\n<tr>\n<td>v-bind</td>\n<td>属性绑定,后面的值会看作js代码运行</td>\n<td>可简写为:attribute&#x3D;value</td>\n</tr>\n<tr>\n<td>v-clock</td>\n<td>防止闪现,与css配合:[v-cloak]{display:none}</td>\n<td>可简写为:attribute&#x3D;value</td>\n</tr>\n</tbody></table>\n<h4 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h4><p>在Vue实例对象注册的指令为全局指令，在组件内部定义的指令为局部指令</p>\n<h5 id=\"注册全局指令\"><a href=\"#注册全局指令\" class=\"headerlink\" title=\"注册全局指令\"></a>注册全局指令</h5><pre><code class=\"js\">Vue.directive(&#39;my-directive&#39;,function(el,binding)&#123;\n    // todo something\n&#125;)\n</code></pre>\n<h5 id=\"注册局部指令\"><a href=\"#注册局部指令\" class=\"headerlink\" title=\"注册局部指令\"></a>注册局部指令</h5><pre><code class=\"js\">directives:&#123;\n    &#39;my-directive&#39;:&#123;\n        bind(el,binding)&#123;\n            // todo something\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"使用demo\"><a href=\"#使用demo\" class=\"headerlink\" title=\"使用demo\"></a>使用demo</h5><p>v-my-directive &#x3D; ‘xxx’</p>\n<p>需求:自定义2个指令</p>\n<ol>\n<li>功能类型于v-text,但转换为全大写</li>\n<li>功能类型于v-text,但转换为全小写</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;div id=&quot;demo1&quot;&gt;\n       &lt;p v-upper-text=&quot;msg&quot;&gt;&lt;/p&gt;\n       &lt;p v-lower-text=&quot;msg&quot;&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;demo2&quot;&gt;\n       &lt;p v-upper-text=&quot;msg2&quot;&gt;&lt;/p&gt;\n       &lt;p v-lower-text=&quot;msg2&quot;&gt;&lt;/p&gt;&lt;!--局部指令,此处不能使用--&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    //注册全局指令\n    Vue.directive(&#39;upper-text&#39;,function(el,binding)&#123;\n        el.innerHTML=binding.value.toUpperCase()\n    &#125;);\n\n    new Vue(&#123;\n        el:&#39;#demo1&#39;,\n        data:&#123;\n            msg2:&#39;NBA love this game!&#39;\n        &#125;,\n        directives:&#123;\n            &#39;lower-text&#39;:&#123;\n                bind(el,binding)&#123;\n                    el.innerHTML = binding.value.toLowerCase();\n                &#125;\n            &#125;\n        &#125;\n    &#125;)\n\n    new Vue(&#123;\n        el:&#39;#demo2&#39;,\n        data:&#123;\n            msg2:&#39;ILikeYou&#39;\n        &#125;\n    &#125;)\n\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><ol>\n<li>Vue插件是一个包含install方法的对象</li>\n<li>通过install方法给vue或vue实例添加方法，定义全局z指令等</li>\n</ol>\n<h4 id=\"定义使用\"><a href=\"#定义使用\" class=\"headerlink\" title=\"定义使用\"></a>定义使用</h4><pre><code class=\"js\">// vue-myPlugin.js\n// 定义Vue一个插件\n(function MyPlugin()&#123;\n\n    const MyPlugin = &#123;&#125;;\n\n    MyPlugin.install = function(Vue,options)&#123;\n\n        Vue.GlobalMethod = function()&#123;\n            console.log(&#39;Vue函数对象方法执行&#39;);\n        &#125;;\n\n        Vue.directive(&#39;my-directive&#39;,function(el,binding)&#123;\n            el.innerHTML = &#39;MyPlugin my-directive&#39;+binding.value\n        &#125;);\n\n        Vue.prototype.$method = function()&#123;\n            console.log(&#39;vue&#39;实例对象)\n        &#125;\n    &#125;\n\n    window.MyPlugin = MyPlugin;\n\n&#125;)();\n</code></pre>\n<p>在页面中使用</p>\n<pre><code class=\"html\">&lt;div id=&quot;demo&quot;&gt;\n    &lt;p v-my-directive=&quot;msg&quot;&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n\n    Vue.use(MyPlugin);\n\n    var vm = new Vue(&#123;\n        el:&quot;#demo&quot;,\n        data:&#123;\n            msg:&#39;atguigu&#39;\n        &#125;\n    &#125;)\n\n    Vue.myGlobalMethod();\n\n    vm.$myMethod();\n\n&lt;/script&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li>官方文档: <a href=\"https://vuejs.org/\">https://vuejs.org/</a></li>\n<li>github仓库: <a href=\"https://github.com/vuejs/vue\">https://github.com/vuejs/vue</a></li>\n</ol>\n<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><ol>\n<li>是一套用于构建用户界面的渐进式框架，只关注视图层</li>\n<li>遵循MVVM模式</li>\n<li>可以轻松引入vue相关插件或者结合第三方开发项目进行开发</li>\n<li>借鉴angular的模板和数据绑定</li>\n<li>借鉴react的组件化和虚拟DOM技术</li>\n</ol>\n<h2 id=\"相关生态\"><a href=\"#相关生态\" class=\"headerlink\" title=\"相关生态\"></a>相关生态</h2><ol>\n<li><a href=\"https://cli.vuejs.org/zh/\">vue-cli</a>:vue脚手架</li>\n<li><a href=\"https://github.com/axios/axios\">axios</a>:ajax请求</li>\n<li><a href=\"https://router.vuejs.org/zh/\">vue-router</a>:SPA路由控制</li>\n<li><a href=\"https://vuex.vuejs.org/zh/\">vuex</a>:状态管理</li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN\">element-ui</a>:基于vue的UI组件库(PC端)</li>\n<li><a href=\"http://mint-ui.github.io/#!/zh-cn\">mint-ui</a>:基于vue的UI组件库(移动端)</li>\n<li><a href=\"https://panjiachen.gitee.io/vue-element-admin-site/zh/\">vue-element-admin</a>:基于vue,element-ui等相关库所开发的后台管理模板</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h4 id=\"1-CDN引入\"><a href=\"#1-CDN引入\" class=\"headerlink\" title=\"1. CDN引入\"></a>1. CDN引入</h4><p>直接使用script标签引入</p>\n<pre><code class=\"js\">// 开发环境下使用，在开发中会给出友好的提示\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n// 开发环境下使用，会压缩代码，减少代码体积\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<h4 id=\"2-NPM引入\"><a href=\"#2-NPM引入\" class=\"headerlink\" title=\"2. NPM引入\"></a>2. NPM引入</h4><p>前提要安装nodejs(网址:<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>)</p>\n<p>安装:<code>npm i vue --save</code></p>\n<p><code>使用</code></p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;;\n\nnew Vue(&#123;\n    // ...option\n&#125;)\n</code></pre>\n<h2 id=\"简单使用-Hello-World\"><a href=\"#简单使用-Hello-World\" class=\"headerlink\" title=\"简单使用(Hello World)\"></a>简单使用(Hello World)</h2><h4 id=\"vue的简单使用总共分为以下几步\"><a href=\"#vue的简单使用总共分为以下几步\" class=\"headerlink\" title=\"vue的简单使用总共分为以下几步\"></a>vue的简单使用总共分为以下几步</h4><ol>\n<li>获取一个DOM容器</li>\n<li>new 一个vue的实例对象</li>\n<li>传递创建该实例对象所需要的参数配置</li>\n</ol>\n<h4 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h4><pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &#123;&#123;msg&#125;&#125;\n        &lt;/div&gt;\n        &lt;script&gt;\n            // 创建Vue的实例对象，并传入配置对象\n            var vm = new Vue(&#123;\n                // 获取容器\n                el:&quot;#app&quot;,\n                data()&#123;\n                    msg:&quot;hello world&quot;\n                &#125;\n            &#125;);\n            /**\n             *  \n             * 最后,页面会显示hello world\n             * \n             * /\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h4 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h4><ol>\n<li>双大括号:将实例对象中的data数据渲染到页面中</li>\n<li>v-html:用于输出HTML代码</li>\n<li>v-text:用于输出文本</li>\n</ol>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &#123;&#123;msg&#125;&#125;\n            &lt;div v-html=&quot;innerHTML&quot;&gt;&lt;/div&gt;\n            &lt;div v-text=&quot;textContent&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;script&gt;     \n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    msg:&quot;hello world&quot;,\n                    innerHTML:&quot;&lt;h1&gt;innerHTML&lt;/h1&gt;&quot;\n                    textContent:&quot;textContent&quot;\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h4><ol>\n<li>v-if:用于条件性地渲染一块内容</li>\n<li>v-show:用于控制display的值</li>\n<li>v-if vs v-show</li>\n</ol>\n<pre><code class=\"js\">// v-show只是简单的基于CSS进行切换\n// v-if会控制该元素是否参与DOM树,如果false就从DOM树中删除销毁\n// 如果需要非常频繁地切换，则使用v-show较好;如何在运行时条件很少改变,则使用v-if较好\n</code></pre>\n<h4 id=\"循环渲染-v-for\"><a href=\"#循环渲染-v-for\" class=\"headerlink\" title=\"循环渲染(v-for)\"></a>循环渲染(v-for)</h4><ol>\n<li>遍历数组(item in items)</li>\n</ol>\n<p>我们可以使用v-for基于一个数组来渲染一个列表，语法为item in items,其中items是data中是源数据，而item则是被迭代的数组元素的别名</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &lt;ul&gt;\n                &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;script&gt;\n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    items: [\n                        &#123; message: &#39;Foo&#39; &#125;,\n                        &#123; message: &#39;Bar&#39; &#125;\n                    ];\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"2\">\n<li>遍历对象</li>\n</ol>\n<p>我们可以使用v-for来遍历一个对象的属性</p>\n<pre><code class=\"html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;vue demo&lt;/title&gt;\n        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &lt;ul&gt;\n                &lt;li v-for=&quot;(value,name,index) in obj&quot; :key=&quot;index&quot;&gt;\n                    &#123;&#123;name&#125;&#125;:&#123;&#123;value&#125;&#125;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;script&gt;\n            var vm = new Vue(&#123;\n                el:&quot;#app&quot;,\n                data()&#123;\n                    obj:&#123;\n                        name:&quot;zhangsan&quot;,\n                        age:24\n                    &#125;\n                &#125;\n            &#125;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>数组更新检测</li>\n</ol>\n<p>Vue对一个数组的变异方法进行包裹，所以调用以下方法会触发视图更新</p>\n<pre><code class=\"js\">push()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n</code></pre>\n<h4 id=\"计算属性和监听器-computed-amp-watch\"><a href=\"#计算属性和监听器-computed-amp-watch\" class=\"headerlink\" title=\"计算属性和监听器(computed&amp;watch)\"></a>计算属性和监听器(computed&amp;watch)</h4><h5 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h5><ol>\n<li>在computed属性对象中定义计算属性的方法</li>\n<li>在页面中使用来显示计算的结果</li>\n</ol>\n<h5 id=\"监视属性\"><a href=\"#监视属性\" class=\"headerlink\" title=\"监视属性\"></a>监视属性</h5><ol>\n<li>通过vm对象的$watch或watch配置来监视指定的属性</li>\n<li>当属性变化时,回调函数自动调用,在函数内部进行计算</li>\n</ol>\n<h5 id=\"计算属性高级\"><a href=\"#计算属性高级\" class=\"headerlink\" title=\"计算属性高级\"></a>计算属性高级</h5><ol>\n<li>通过getter&#x2F;setter实现对属性数据的显示个监视</li>\n<li>计算属性存在缓存,多次读取只执行一个getter计算</li>\n</ol>\n<h4 id=\"Style-amp-Class\"><a href=\"#Style-amp-Class\" class=\"headerlink\" title=\"Style&amp;Class\"></a>Style&amp;Class</h4><h5 id=\"class绑定\"><a href=\"#class绑定\" class=\"headerlink\" title=\"class绑定\"></a>class绑定</h5><ol>\n<li>:class&#x3D;’xxx’</li>\n<li>表达式是字符串:’classA’</li>\n<li>表达式是对象:{classA:isA,classB:isB}</li>\n<li>表达式是数组:[‘classA’,’classB’]</li>\n</ol>\n<h5 id=\"style绑定\"><a href=\"#style绑定\" class=\"headerlink\" title=\"style绑定\"></a>style绑定</h5><ol>\n<li>:style&#x3D;”{color:activeColor,fontSize:fontSize+’px’}”</li>\n<li>其中activeColor&#x2F;fontSize是data属性</li>\n</ol>\n<h5 id=\"demo-1\"><a href=\"#demo-1\" class=\"headerlink\" title=\"demo\"></a>demo</h5><pre><code class=\"vue\">&lt;style&gt;\n    .classA&#123;\n        color:red;\n    &#125;\n    .classB&#123;\n        background:blue;\n    &#125;\n    .classC&#123;\n        font-size:20px;\n    &#125;   \n&lt;/style&gt;\n\n&lt;template&gt;\n&lt;div id=&quot;demo&quot;&gt;\n    &lt;h2&gt;1.class绑定::class=&#39;xxx&#39;&lt;/h2&gt;\n    &lt;p class=&quot;classB&quot; :class=&quot;a&quot;&gt;表达式是字符串:&#39;classA&#39;&lt;/p&gt;\n    &lt;p :class=&quot;&#123;classA:isA,classB:isB&#125;&quot;&gt;表达式是对象:&#123;classA:isA,classB:isB&#125;&lt;/p&gt;\n    &lt;p :class=&quot;[&#39;classA&#39;,&#39;classC&#39;]&quot;&gt;表达式是数组:[&#39;classA&#39;,&#39;classB&#39;]&lt;/p&gt;\n\n    &lt;h2&gt;2.style绑定&lt;/h2&gt;\n    &lt;p :style=&quot;&#123;color,fontSize&#125;&quot;&gt;\n        style=&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;\n    &lt;/p&gt;\n\n    &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;\n\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nnew Vue(&#123;\n    el:&#39;#demo&#39;,\n    data:&#123;\n        a:&#39;classA&#39;,\n        isA:true,\n        isB:false,\n        color:&#39;red&#39;,\n        fontSize:&#39;20px&#39;\n    &#125;,\n    methods:&#123;\n        update()&#123;\n            this.a=&#39;classC&#39;\n            this.isA=falsethis.isB=truethis.color=&#39;blue&#39;\n            this.fontSize=&#39;30px&#39;\n        &#125;\n    &#125;\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><h5 id=\"绑定监听\"><a href=\"#绑定监听\" class=\"headerlink\" title=\"绑定监听\"></a>绑定监听</h5><ol>\n<li>v-on:eventName&#x3D;”fun”</li>\n<li>@eventName&#x3D;”fun”</li>\n<li>@eventName&#x3D;”fun(参数)”</li>\n<li>默认事件形参:event</li>\n<li>隐含属性对象:$event</li>\n</ol>\n<h5 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h5><ol>\n<li>.prevent:阻止事件的默认行为 event.preventDefault()</li>\n<li>.stop:停止事件冒泡 event.stopPropagation()</li>\n</ol>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><ol>\n<li>.keycode:操作的是某个keycode值的键</li>\n<li>.keyName:操作的是某个按键名的键(少部分)</li>\n</ol>\n<h5 id=\"demo-2\"><a href=\"#demo-2\" class=\"headerlink\" title=\"demo\"></a>demo</h5><pre><code class=\"vue\">&lt;template&gt;\n    &lt;div id=&quot;example&quot;&gt;\n        &lt;h2&gt;1.绑定监听&lt;/h2&gt;\n        &lt;button v-on:click=&quot;test1&quot;&gt;Greet&lt;/button&gt;\n        &lt;button @click=&quot;test1&quot;&gt;Greet2&lt;/button&gt;\n        &lt;button @click=&quot;test2($event,&#39;hello&#39;)&quot;&gt;Greet3&lt;/button&gt;\n        &lt;h2&gt;2.事件修饰符&lt;/h2&gt;\n        &lt;!--阻止事件默认行为--&gt;\n        &lt;a href=&quot;http://www.baidu.com&quot;@click.prevent=&quot;test3&quot;&gt;百度一下&lt;/a&gt;\n        &lt;br/&gt;&lt;br/&gt;\n        &lt;!--停止事件冒泡--&gt;\n        &lt;div style=&quot;width:200px;height:200px;background:red&quot; @click=&quot;test4&quot;&gt;\n            &lt;div style=&quot;width:100px;height:100px;background:green&quot; @click.stop=&quot;test5&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;h2&gt;3.按键修饰符&lt;/h2&gt;\n        &lt;input @keyup.8=&quot;test6&quot;&gt;\n        &lt;input @keyup.enter=&quot;test6&quot;&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    newVue(&#123;\n        el:&#39;#example&#39;,\n        data:&#123;\n            name:&#39;Vue.js&#39;\n        &#125;,\n        methods:&#123;\n            test1(event)&#123;\n                //方法内`this`指向vm\n                //alert(&#39;Hello&#39;+this.name+&#39;!&#39;)\n                //`event`是原生DOM事件\n                alert(event.target.innerHTML)\n            &#125;,\n            test2(event,msg)&#123;\n                alert(event.target.innerHTML+&#39;---&#39;+msg)\n            &#125;,\n            test3()&#123;\n                alert(&#39;阻止事件的默认行为&#39;)\n            &#125;,\n            test4()&#123;\n                alert(&#39;out&#39;)\n            &#125;,\n            test5()&#123;\n                alert(&#39;inner&#39;)\n            &#125;,\n            test6(event)&#123;\n                alert(event.keyCode+&#39;---&#39;+event.target.value)\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<h4 id=\"事件处理-x2F-表单输入绑定\"><a href=\"#事件处理-x2F-表单输入绑定\" class=\"headerlink\" title=\"事件处理&#x2F;表单输入绑定\"></a>事件处理&#x2F;表单输入绑定</h4><ol>\n<li>text&#x2F;textarea</li>\n<li>checkbox</li>\n<li>radio</li>\n<li>select</li>\n</ol>\n<p><code>demo</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n&lt;div id=&quot;demo&quot;&gt;\n    &lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;\n        &lt;span&gt;用户名:&lt;/span&gt;\n        &lt;input type=&quot;text&quot;v-model=&quot;user.username&quot;&gt;&lt;br&gt;\n        &lt;span&gt;密码:&lt;/span&gt;\n        &lt;input type=&quot;password&quot; v-model=&quot;user.pwd&quot;&gt;&lt;br&gt;\n        &lt;span&gt;性别:&lt;/span&gt;\n        &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;female&quot; v-model=&quot;user.sex&quot;&gt;\n        &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;\n        &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;male&quot; v-model=&quot;user.sex&quot;&gt;\n        &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;br&gt;\n        &lt;span&gt;爱好:&lt;/span&gt;\n        &lt;input type=&quot;checkbox&quot; id=&quot;basket&quot; value=&quot;basketball&quot; v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;basket&quot;&gt;篮球&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot;id=&quot;foot&quot;value=&quot;football&quot;v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;foot&quot;&gt;足球&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot;id=&quot;pingpang&quot;value=&quot;pingpang&quot;v-model=&quot;user.likes&quot;&gt;\n        &lt;label for=&quot;pingpang&quot;&gt;乒乓&lt;/label&gt;&lt;br&gt;\n        &lt;span&gt;城市:&lt;/span&gt;\n        &lt;select v-model=&quot;user.cityId&quot;&gt;\n            &lt;option value=&quot;&quot;&gt;未选择&lt;/option&gt;\n            &lt;option v-for=&quot;cityinallCitys&quot; :value=&quot;city.id&quot;&gt;\n                &#123;&#123;city.name&#125;&#125;\n            &lt;/option&gt;\n        &lt;/select&gt;\n        &lt;br/&gt;\n        &lt;span&gt;介绍:&lt;/span&gt;\n        &lt;textarea v-model=&quot;user.desc&quot;rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;\n        &lt;input type=&quot;submit&quot;value=&quot;注册&quot;&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar vm = new Vue(&#123;\n    el:&quot;#demo&quot;,\n    data:&#123;\n        user:&#123;\n            username:&#39;&#39;,\n            pwd:&#39;&#39;,\n            sex:&#39;female&#39;,\n            likes:[],\n            cityId:&#39;&#39;,\n            desc:&#39;&#39;\n        &#125;\n        allCitys:[&#123;id:1,name:&#39;BJ&#39;&#125;,&#123;id:2,name:&#39;SZ&#39;&#125;,&#123;id:4,name:&#39;SH&#39;&#125;],\n    &#125;,\n    methods:&#123;\n        handleSubmit(event)&#123;\n            alert(JSON.stringify(this.user);\n        &#125;\n    &#125;\n&#125;)\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h4 id=\"内置指令\"><a href=\"#内置指令\" class=\"headerlink\" title=\"内置指令\"></a>内置指令</h4><table>\n<thead>\n<tr>\n<th>指令名</th>\n<th>用处</th>\n<th>其他</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v-text</td>\n<td>向页面输出文本</td>\n<td>相当于textContent</td>\n</tr>\n<tr>\n<td>v-html</td>\n<td>向页面输出文本</td>\n<td>相当于innerHTML</td>\n</tr>\n<tr>\n<td>v-if</td>\n<td>通过控制元素是否在DOM树中来控制元素的显示</td>\n<td>该属性会对DOM树产生影响</td>\n</tr>\n<tr>\n<td>v-else</td>\n<td>与v-if搭配使用,v-if后面的表达式为false才会执行该段代码</td>\n<td>无</td>\n</tr>\n<tr>\n<td>v-show</td>\n<td>通过控制元素css来控制元素的显示</td>\n<td>该属性不会对DOM树产生影响</td>\n</tr>\n<tr>\n<td>v-for</td>\n<td>循环渲染元素</td>\n<td>一般需要为循环的元素指定key值</td>\n</tr>\n<tr>\n<td>v-model</td>\n<td>表单组件输入绑定监听</td>\n<td>主要常见表单组件:textare&#x2F;checkbox&#x2F;radio&#x2F;input&#x2F;select</td>\n</tr>\n<tr>\n<td>v-on</td>\n<td>事件绑定</td>\n<td>可简写为@事件名.事件修饰符</td>\n</tr>\n<tr>\n<td>v-bind</td>\n<td>属性绑定,后面的值会看作js代码运行</td>\n<td>可简写为:attribute&#x3D;value</td>\n</tr>\n<tr>\n<td>v-clock</td>\n<td>防止闪现,与css配合:[v-cloak]{display:none}</td>\n<td>可简写为:attribute&#x3D;value</td>\n</tr>\n</tbody></table>\n<h4 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h4><p>在Vue实例对象注册的指令为全局指令，在组件内部定义的指令为局部指令</p>\n<h5 id=\"注册全局指令\"><a href=\"#注册全局指令\" class=\"headerlink\" title=\"注册全局指令\"></a>注册全局指令</h5><pre><code class=\"js\">Vue.directive(&#39;my-directive&#39;,function(el,binding)&#123;\n    // todo something\n&#125;)\n</code></pre>\n<h5 id=\"注册局部指令\"><a href=\"#注册局部指令\" class=\"headerlink\" title=\"注册局部指令\"></a>注册局部指令</h5><pre><code class=\"js\">directives:&#123;\n    &#39;my-directive&#39;:&#123;\n        bind(el,binding)&#123;\n            // todo something\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"使用demo\"><a href=\"#使用demo\" class=\"headerlink\" title=\"使用demo\"></a>使用demo</h5><p>v-my-directive &#x3D; ‘xxx’</p>\n<p>需求:自定义2个指令</p>\n<ol>\n<li>功能类型于v-text,但转换为全大写</li>\n<li>功能类型于v-text,但转换为全小写</li>\n</ol>\n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;div id=&quot;demo1&quot;&gt;\n       &lt;p v-upper-text=&quot;msg&quot;&gt;&lt;/p&gt;\n       &lt;p v-lower-text=&quot;msg&quot;&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;demo2&quot;&gt;\n       &lt;p v-upper-text=&quot;msg2&quot;&gt;&lt;/p&gt;\n       &lt;p v-lower-text=&quot;msg2&quot;&gt;&lt;/p&gt;&lt;!--局部指令,此处不能使用--&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    //注册全局指令\n    Vue.directive(&#39;upper-text&#39;,function(el,binding)&#123;\n        el.innerHTML=binding.value.toUpperCase()\n    &#125;);\n\n    new Vue(&#123;\n        el:&#39;#demo1&#39;,\n        data:&#123;\n            msg2:&#39;NBA love this game!&#39;\n        &#125;,\n        directives:&#123;\n            &#39;lower-text&#39;:&#123;\n                bind(el,binding)&#123;\n                    el.innerHTML = binding.value.toLowerCase();\n                &#125;\n            &#125;\n        &#125;\n    &#125;)\n\n    new Vue(&#123;\n        el:&#39;#demo2&#39;,\n        data:&#123;\n            msg2:&#39;ILikeYou&#39;\n        &#125;\n    &#125;)\n\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><ol>\n<li>Vue插件是一个包含install方法的对象</li>\n<li>通过install方法给vue或vue实例添加方法，定义全局z指令等</li>\n</ol>\n<h4 id=\"定义使用\"><a href=\"#定义使用\" class=\"headerlink\" title=\"定义使用\"></a>定义使用</h4><pre><code class=\"js\">// vue-myPlugin.js\n// 定义Vue一个插件\n(function MyPlugin()&#123;\n\n    const MyPlugin = &#123;&#125;;\n\n    MyPlugin.install = function(Vue,options)&#123;\n\n        Vue.GlobalMethod = function()&#123;\n            console.log(&#39;Vue函数对象方法执行&#39;);\n        &#125;;\n\n        Vue.directive(&#39;my-directive&#39;,function(el,binding)&#123;\n            el.innerHTML = &#39;MyPlugin my-directive&#39;+binding.value\n        &#125;);\n\n        Vue.prototype.$method = function()&#123;\n            console.log(&#39;vue&#39;实例对象)\n        &#125;\n    &#125;\n\n    window.MyPlugin = MyPlugin;\n\n&#125;)();\n</code></pre>\n<p>在页面中使用</p>\n<pre><code class=\"html\">&lt;div id=&quot;demo&quot;&gt;\n    &lt;p v-my-directive=&quot;msg&quot;&gt;\n&lt;/div&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n\n    Vue.use(MyPlugin);\n\n    var vm = new Vue(&#123;\n        el:&quot;#demo&quot;,\n        data:&#123;\n            msg:&#39;atguigu&#39;\n        &#125;\n    &#125;)\n\n    Vue.myGlobalMethod();\n\n    vm.$myMethod();\n\n&lt;/script&gt;\n</code></pre>\n"},{"title":"vue2组件","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-01-30T16:00:00.000Z","comments":0,"description":"vue2组件","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg"],"_content":"\n\n## 组件化编码 & 模块化编码\n1. 模块 --> 具有特定功能的js文件\n2. 组件 --> 用来实现特定(局部)功能效果的代码集合(html/css/js)\n\n而在我们开发中，我们是通过组件化思想来分割页面成一个个组件，最后拼接成一个页面\n\n如果要使用组件化思想，一般可以按照以下步骤来进行思考\n1. 搞清要被划分页面所涉及的数据(搞起数据的来源，数据的类型)，以及该页面所涉及到的用户操作\n2. 划分页面成一块块组件，并且搞清每一个组件所涉及到的相关数据和用户操作\n3. 根据页面先完成页面的静态显示\n4. 然后完成页面的动态显示(`先初始化`，`再动态化`)  \n\n\n## 组件的基本认识\n\n组件的视图显示一般是由两部分组成:静态视图+数据视图\n\n静态视图就是静态页面，一般也就是由html+css组成\n\n而数据视图则是由html+css+js组成.其中js是负责获取数据并将数据显示到视图上\n\n对组件来说，其数据一般是由两部分组成\n1. `内部数据`\n2. `外部数据`\n\n内部数据一般是组件自身所携带的，外部数据则是由外部传入的\n\n\n## 组件的基本使用\n\n#### 使用全局组件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue Component</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <button-counter></button-counter>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n    // Vue.Component('component-name',options);\n    Vue.component('button-counter',{\n      data:function(){\n        return {\n          count:0\n        }\n      },\n      template:`<button @click='count++'>you click {{count}} times</button>`\n    })\n\n    new Vue({\n      el:'#app'\n    })\n  </script>\n</body>\n\n</html>\n\n```\n#### 使用局部组件\n1. 创建一个普通对象来定义组件\n2. 然后在创建vue实例对象的配置参数中指定components对象\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue Component</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <button-counter></button-counter>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n    \n    var ButtonCounter = {\n      template:`<button @click=\"count++\">{{count}}</button>`,\n      data:function(){\n        return{\n          count:0\n        }\n      }\n    }\n\n    new Vue({\n      el:'#app',\n      components:{\n        ButtonCounter\n      }\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n## 组件的通信\n\n组件通信基本原则\n1. 不要在子组件中直接修改父组件的状态数据\n2. 数据在哪里，更新数据的行为(函数)就应该定义在哪里\n\n#### props\nprops属性是在定义一个组件常用的属性，用于在我们使用该组件时应该传入什么样的数据，如果我们没有按照其要求传入相关数据，该组件在创建期间就会发生warning!\n\nprops属性是一个对象，该对象的每一个属性名是该组件所要传入的属性名，而属性名所对应的属性值可以是一个对象。该对象是用于描述该属性的类型，默认值，是否必需等\n\n在父子组件之间通信时，我们可以在父组件定义改变数据的方法，然后将该方法作为一个prop传入给子组件。当子组件需要修改父组件数据时调用该方法即可(跟react父子之间通信道理一样)\n\n`demo`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue props</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <parent-component/>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n\n\n    Vue.component('child-component',{\n      template:`<button @click='changeParentData'>change parent component data</button>`,\n      props:{\n        changeParentData:{\n          type:Function,\n          required:true\n        }\n      }\n    });\n\n    Vue.component('parent-component',{\n      template:`\n        <div>\n          <h1>{{msg}}</h1>\n          <child-component :changeParentData=\"changeParentData\"/>\n        </div>\n      `,\n      data:function(){\n        return{\n          msg:'parent data'\n        }\n      },\n      methods:{\n        changeParentData:function(){\n          this.msg += ' change';\n        }\n      }\n    })\n\n\n    new Vue({\n      el: '#app'\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n注意，该方式的数据流是单向的，即`父组件 --> 子组件`。也就是说我们无法通过该方式来实现通过父组件来修改子组件数据\n\n\n#### $emit\n此方式是通过监听事件然后触发回调函数来实现组件通信，且该方法只能用于子组件向父组件传递数据\n方式 `子组件 --> 父组件` \n\n\n`demo`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue props</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <parent-component />\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n\n    Vue.component('child-component', {\n      template: `<button @click=\"postDataToParent\">post data to parent component</button>`,\n      data:function(){\n        return{\n          msg:\"hello child component\"\n        }\n      },\n      methods:{\n        postDataToParent:function(){\n          alert('post data to parent!');\n          this.$emit('receive',this.msg);\n        }\n      }\n    });\n\n    Vue.component('parent-component', {\n      template: `\n        <div>\n          <h1>{{msg}}</h1>\n          <child-component @receive=\"receive\"/>\n        </div>\n      `,\n      data: function () {\n        return {\n          msg: 'parent data'\n        }\n      },\n      methods: {\n        receive: function (data) {\n          alert('receive data from child!');\n          this.msg = data;\n        }\n      }\n    })\n\n    new Vue({\n      el: '#app'\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n#### 消息订阅发布机制(PubSubJS)\n\nPubSubJS地址: https://www.npmjs.com/package/pubsubjs\n\n我们可以使用PubSubJS来完成组件的通信,模式为订阅者 -- 发布者模式。当一个组件A想要向另一个组件B通信时,首先组件B要订阅A发布的消息,然后当A要向B通信时就直接发布相应消息\n\n订阅消息  \n\nPubSub.subscribe('msg',function(msg,data){})\n\n发布消息  \n\nPubSub.publish('msg',data)\n\n\n","source":"_posts/前端/vue/vue2组件.md","raw":"---\ntitle: vue2组件\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-01-31\ncomments: false\ndescription: vue2组件\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/类数组转换为数组的方法_bg.jpg\n---\n\n\n## 组件化编码 & 模块化编码\n1. 模块 --> 具有特定功能的js文件\n2. 组件 --> 用来实现特定(局部)功能效果的代码集合(html/css/js)\n\n而在我们开发中，我们是通过组件化思想来分割页面成一个个组件，最后拼接成一个页面\n\n如果要使用组件化思想，一般可以按照以下步骤来进行思考\n1. 搞清要被划分页面所涉及的数据(搞起数据的来源，数据的类型)，以及该页面所涉及到的用户操作\n2. 划分页面成一块块组件，并且搞清每一个组件所涉及到的相关数据和用户操作\n3. 根据页面先完成页面的静态显示\n4. 然后完成页面的动态显示(`先初始化`，`再动态化`)  \n\n\n## 组件的基本认识\n\n组件的视图显示一般是由两部分组成:静态视图+数据视图\n\n静态视图就是静态页面，一般也就是由html+css组成\n\n而数据视图则是由html+css+js组成.其中js是负责获取数据并将数据显示到视图上\n\n对组件来说，其数据一般是由两部分组成\n1. `内部数据`\n2. `外部数据`\n\n内部数据一般是组件自身所携带的，外部数据则是由外部传入的\n\n\n## 组件的基本使用\n\n#### 使用全局组件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue Component</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <button-counter></button-counter>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n    // Vue.Component('component-name',options);\n    Vue.component('button-counter',{\n      data:function(){\n        return {\n          count:0\n        }\n      },\n      template:`<button @click='count++'>you click {{count}} times</button>`\n    })\n\n    new Vue({\n      el:'#app'\n    })\n  </script>\n</body>\n\n</html>\n\n```\n#### 使用局部组件\n1. 创建一个普通对象来定义组件\n2. 然后在创建vue实例对象的配置参数中指定components对象\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue Component</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <button-counter></button-counter>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n    \n    var ButtonCounter = {\n      template:`<button @click=\"count++\">{{count}}</button>`,\n      data:function(){\n        return{\n          count:0\n        }\n      }\n    }\n\n    new Vue({\n      el:'#app',\n      components:{\n        ButtonCounter\n      }\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n## 组件的通信\n\n组件通信基本原则\n1. 不要在子组件中直接修改父组件的状态数据\n2. 数据在哪里，更新数据的行为(函数)就应该定义在哪里\n\n#### props\nprops属性是在定义一个组件常用的属性，用于在我们使用该组件时应该传入什么样的数据，如果我们没有按照其要求传入相关数据，该组件在创建期间就会发生warning!\n\nprops属性是一个对象，该对象的每一个属性名是该组件所要传入的属性名，而属性名所对应的属性值可以是一个对象。该对象是用于描述该属性的类型，默认值，是否必需等\n\n在父子组件之间通信时，我们可以在父组件定义改变数据的方法，然后将该方法作为一个prop传入给子组件。当子组件需要修改父组件数据时调用该方法即可(跟react父子之间通信道理一样)\n\n`demo`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue props</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <parent-component/>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n\n\n    Vue.component('child-component',{\n      template:`<button @click='changeParentData'>change parent component data</button>`,\n      props:{\n        changeParentData:{\n          type:Function,\n          required:true\n        }\n      }\n    });\n\n    Vue.component('parent-component',{\n      template:`\n        <div>\n          <h1>{{msg}}</h1>\n          <child-component :changeParentData=\"changeParentData\"/>\n        </div>\n      `,\n      data:function(){\n        return{\n          msg:'parent data'\n        }\n      },\n      methods:{\n        changeParentData:function(){\n          this.msg += ' change';\n        }\n      }\n    })\n\n\n    new Vue({\n      el: '#app'\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n注意，该方式的数据流是单向的，即`父组件 --> 子组件`。也就是说我们无法通过该方式来实现通过父组件来修改子组件数据\n\n\n#### $emit\n此方式是通过监听事件然后触发回调函数来实现组件通信，且该方法只能用于子组件向父组件传递数据\n方式 `子组件 --> 父组件` \n\n\n`demo`\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Vue props</title>\n</head>\n\n<body>\n  <div id=\"app\">\n    <parent-component />\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  <script>\n\n    Vue.component('child-component', {\n      template: `<button @click=\"postDataToParent\">post data to parent component</button>`,\n      data:function(){\n        return{\n          msg:\"hello child component\"\n        }\n      },\n      methods:{\n        postDataToParent:function(){\n          alert('post data to parent!');\n          this.$emit('receive',this.msg);\n        }\n      }\n    });\n\n    Vue.component('parent-component', {\n      template: `\n        <div>\n          <h1>{{msg}}</h1>\n          <child-component @receive=\"receive\"/>\n        </div>\n      `,\n      data: function () {\n        return {\n          msg: 'parent data'\n        }\n      },\n      methods: {\n        receive: function (data) {\n          alert('receive data from child!');\n          this.msg = data;\n        }\n      }\n    })\n\n    new Vue({\n      el: '#app'\n    })\n\n  </script>\n</body>\n\n</html>\n```\n\n#### 消息订阅发布机制(PubSubJS)\n\nPubSubJS地址: https://www.npmjs.com/package/pubsubjs\n\n我们可以使用PubSubJS来完成组件的通信,模式为订阅者 -- 发布者模式。当一个组件A想要向另一个组件B通信时,首先组件B要订阅A发布的消息,然后当A要向B通信时就直接发布相应消息\n\n订阅消息  \n\nPubSub.subscribe('msg',function(msg,data){})\n\n发布消息  \n\nPubSub.publish('msg',data)\n\n\n","slug":"前端/vue/vue2组件","published":1,"updated":"2023-05-12T23:28:10.996Z","layout":"post","link":"","_id":"clhws1t2z00252h171t4rhpqs","content":"<h2 id=\"组件化编码-amp-模块化编码\"><a href=\"#组件化编码-amp-模块化编码\" class=\"headerlink\" title=\"组件化编码 &amp; 模块化编码\"></a>组件化编码 &amp; 模块化编码</h2><ol>\n<li>模块 –&gt; 具有特定功能的js文件</li>\n<li>组件 –&gt; 用来实现特定(局部)功能效果的代码集合(html&#x2F;css&#x2F;js)</li>\n</ol>\n<p>而在我们开发中，我们是通过组件化思想来分割页面成一个个组件，最后拼接成一个页面</p>\n<p>如果要使用组件化思想，一般可以按照以下步骤来进行思考</p>\n<ol>\n<li>搞清要被划分页面所涉及的数据(搞起数据的来源，数据的类型)，以及该页面所涉及到的用户操作</li>\n<li>划分页面成一块块组件，并且搞清每一个组件所涉及到的相关数据和用户操作</li>\n<li>根据页面先完成页面的静态显示</li>\n<li>然后完成页面的动态显示(<code>先初始化</code>，<code>再动态化</code>)</li>\n</ol>\n<h2 id=\"组件的基本认识\"><a href=\"#组件的基本认识\" class=\"headerlink\" title=\"组件的基本认识\"></a>组件的基本认识</h2><p>组件的视图显示一般是由两部分组成:静态视图+数据视图</p>\n<p>静态视图就是静态页面，一般也就是由html+css组成</p>\n<p>而数据视图则是由html+css+js组成.其中js是负责获取数据并将数据显示到视图上</p>\n<p>对组件来说，其数据一般是由两部分组成</p>\n<ol>\n<li><code>内部数据</code></li>\n<li><code>外部数据</code></li>\n</ol>\n<p>内部数据一般是组件自身所携带的，外部数据则是由外部传入的</p>\n<h2 id=\"组件的基本使用\"><a href=\"#组件的基本使用\" class=\"headerlink\" title=\"组件的基本使用\"></a>组件的基本使用</h2><h4 id=\"使用全局组件\"><a href=\"#使用全局组件\" class=\"headerlink\" title=\"使用全局组件\"></a>使用全局组件</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue Component&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // Vue.Component(&#39;component-name&#39;,options);\n    Vue.component(&#39;button-counter&#39;,&#123;\n      data:function()&#123;\n        return &#123;\n          count:0\n        &#125;\n      &#125;,\n      template:`&lt;button @click=&#39;count++&#39;&gt;you click &#123;&#123;count&#125;&#125; times&lt;/button&gt;`\n    &#125;)\n\n    new Vue(&#123;\n      el:&#39;#app&#39;\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"使用局部组件\"><a href=\"#使用局部组件\" class=\"headerlink\" title=\"使用局部组件\"></a>使用局部组件</h4><ol>\n<li>创建一个普通对象来定义组件</li>\n<li>然后在创建vue实例对象的配置参数中指定components对象</li>\n</ol>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue Component&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    \n    var ButtonCounter = &#123;\n      template:`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;`,\n      data:function()&#123;\n        return&#123;\n          count:0\n        &#125;\n      &#125;\n    &#125;\n\n    new Vue(&#123;\n      el:&#39;#app&#39;,\n      components:&#123;\n        ButtonCounter\n      &#125;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"组件的通信\"><a href=\"#组件的通信\" class=\"headerlink\" title=\"组件的通信\"></a>组件的通信</h2><p>组件通信基本原则</p>\n<ol>\n<li>不要在子组件中直接修改父组件的状态数据</li>\n<li>数据在哪里，更新数据的行为(函数)就应该定义在哪里</li>\n</ol>\n<h4 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h4><p>props属性是在定义一个组件常用的属性，用于在我们使用该组件时应该传入什么样的数据，如果我们没有按照其要求传入相关数据，该组件在创建期间就会发生warning!</p>\n<p>props属性是一个对象，该对象的每一个属性名是该组件所要传入的属性名，而属性名所对应的属性值可以是一个对象。该对象是用于描述该属性的类型，默认值，是否必需等</p>\n<p>在父子组件之间通信时，我们可以在父组件定义改变数据的方法，然后将该方法作为一个prop传入给子组件。当子组件需要修改父组件数据时调用该方法即可(跟react父子之间通信道理一样)</p>\n<p><code>demo</code></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue props&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;parent-component/&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n\n\n    Vue.component(&#39;child-component&#39;,&#123;\n      template:`&lt;button @click=&#39;changeParentData&#39;&gt;change parent component data&lt;/button&gt;`,\n      props:&#123;\n        changeParentData:&#123;\n          type:Function,\n          required:true\n        &#125;\n      &#125;\n    &#125;);\n\n    Vue.component(&#39;parent-component&#39;,&#123;\n      template:`\n        &lt;div&gt;\n          &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;\n          &lt;child-component :changeParentData=&quot;changeParentData&quot;/&gt;\n        &lt;/div&gt;\n      `,\n      data:function()&#123;\n        return&#123;\n          msg:&#39;parent data&#39;\n        &#125;\n      &#125;,\n      methods:&#123;\n        changeParentData:function()&#123;\n          this.msg += &#39; change&#39;;\n        &#125;\n      &#125;\n    &#125;)\n\n\n    new Vue(&#123;\n      el: &#39;#app&#39;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p>注意，该方式的数据流是单向的，即<code>父组件 --&gt; 子组件</code>。也就是说我们无法通过该方式来实现通过父组件来修改子组件数据</p>\n<h4 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"$emit\"></a>$emit</h4><p>此方式是通过监听事件然后触发回调函数来实现组件通信，且该方法只能用于子组件向父组件传递数据<br>方式 <code>子组件 --&gt; 父组件</code> </p>\n<p><code>demo</code></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue props&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;parent-component /&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n\n    Vue.component(&#39;child-component&#39;, &#123;\n      template: `&lt;button @click=&quot;postDataToParent&quot;&gt;post data to parent component&lt;/button&gt;`,\n      data:function()&#123;\n        return&#123;\n          msg:&quot;hello child component&quot;\n        &#125;\n      &#125;,\n      methods:&#123;\n        postDataToParent:function()&#123;\n          alert(&#39;post data to parent!&#39;);\n          this.$emit(&#39;receive&#39;,this.msg);\n        &#125;\n      &#125;\n    &#125;);\n\n    Vue.component(&#39;parent-component&#39;, &#123;\n      template: `\n        &lt;div&gt;\n          &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;\n          &lt;child-component @receive=&quot;receive&quot;/&gt;\n        &lt;/div&gt;\n      `,\n      data: function () &#123;\n        return &#123;\n          msg: &#39;parent data&#39;\n        &#125;\n      &#125;,\n      methods: &#123;\n        receive: function (data) &#123;\n          alert(&#39;receive data from child!&#39;);\n          this.msg = data;\n        &#125;\n      &#125;\n    &#125;)\n\n    new Vue(&#123;\n      el: &#39;#app&#39;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"消息订阅发布机制-PubSubJS\"><a href=\"#消息订阅发布机制-PubSubJS\" class=\"headerlink\" title=\"消息订阅发布机制(PubSubJS)\"></a>消息订阅发布机制(PubSubJS)</h4><p>PubSubJS地址: <a href=\"https://www.npmjs.com/package/pubsubjs\">https://www.npmjs.com/package/pubsubjs</a></p>\n<p>我们可以使用PubSubJS来完成组件的通信,模式为订阅者 – 发布者模式。当一个组件A想要向另一个组件B通信时,首先组件B要订阅A发布的消息,然后当A要向B通信时就直接发布相应消息</p>\n<p>订阅消息  </p>\n<p>PubSub.subscribe(‘msg’,function(msg,data){})</p>\n<p>发布消息  </p>\n<p>PubSub.publish(‘msg’,data)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"组件化编码-amp-模块化编码\"><a href=\"#组件化编码-amp-模块化编码\" class=\"headerlink\" title=\"组件化编码 &amp; 模块化编码\"></a>组件化编码 &amp; 模块化编码</h2><ol>\n<li>模块 –&gt; 具有特定功能的js文件</li>\n<li>组件 –&gt; 用来实现特定(局部)功能效果的代码集合(html&#x2F;css&#x2F;js)</li>\n</ol>\n<p>而在我们开发中，我们是通过组件化思想来分割页面成一个个组件，最后拼接成一个页面</p>\n<p>如果要使用组件化思想，一般可以按照以下步骤来进行思考</p>\n<ol>\n<li>搞清要被划分页面所涉及的数据(搞起数据的来源，数据的类型)，以及该页面所涉及到的用户操作</li>\n<li>划分页面成一块块组件，并且搞清每一个组件所涉及到的相关数据和用户操作</li>\n<li>根据页面先完成页面的静态显示</li>\n<li>然后完成页面的动态显示(<code>先初始化</code>，<code>再动态化</code>)</li>\n</ol>\n<h2 id=\"组件的基本认识\"><a href=\"#组件的基本认识\" class=\"headerlink\" title=\"组件的基本认识\"></a>组件的基本认识</h2><p>组件的视图显示一般是由两部分组成:静态视图+数据视图</p>\n<p>静态视图就是静态页面，一般也就是由html+css组成</p>\n<p>而数据视图则是由html+css+js组成.其中js是负责获取数据并将数据显示到视图上</p>\n<p>对组件来说，其数据一般是由两部分组成</p>\n<ol>\n<li><code>内部数据</code></li>\n<li><code>外部数据</code></li>\n</ol>\n<p>内部数据一般是组件自身所携带的，外部数据则是由外部传入的</p>\n<h2 id=\"组件的基本使用\"><a href=\"#组件的基本使用\" class=\"headerlink\" title=\"组件的基本使用\"></a>组件的基本使用</h2><h4 id=\"使用全局组件\"><a href=\"#使用全局组件\" class=\"headerlink\" title=\"使用全局组件\"></a>使用全局组件</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue Component&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // Vue.Component(&#39;component-name&#39;,options);\n    Vue.component(&#39;button-counter&#39;,&#123;\n      data:function()&#123;\n        return &#123;\n          count:0\n        &#125;\n      &#125;,\n      template:`&lt;button @click=&#39;count++&#39;&gt;you click &#123;&#123;count&#125;&#125; times&lt;/button&gt;`\n    &#125;)\n\n    new Vue(&#123;\n      el:&#39;#app&#39;\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"使用局部组件\"><a href=\"#使用局部组件\" class=\"headerlink\" title=\"使用局部组件\"></a>使用局部组件</h4><ol>\n<li>创建一个普通对象来定义组件</li>\n<li>然后在创建vue实例对象的配置参数中指定components对象</li>\n</ol>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue Component&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    \n    var ButtonCounter = &#123;\n      template:`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;`,\n      data:function()&#123;\n        return&#123;\n          count:0\n        &#125;\n      &#125;\n    &#125;\n\n    new Vue(&#123;\n      el:&#39;#app&#39;,\n      components:&#123;\n        ButtonCounter\n      &#125;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"组件的通信\"><a href=\"#组件的通信\" class=\"headerlink\" title=\"组件的通信\"></a>组件的通信</h2><p>组件通信基本原则</p>\n<ol>\n<li>不要在子组件中直接修改父组件的状态数据</li>\n<li>数据在哪里，更新数据的行为(函数)就应该定义在哪里</li>\n</ol>\n<h4 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h4><p>props属性是在定义一个组件常用的属性，用于在我们使用该组件时应该传入什么样的数据，如果我们没有按照其要求传入相关数据，该组件在创建期间就会发生warning!</p>\n<p>props属性是一个对象，该对象的每一个属性名是该组件所要传入的属性名，而属性名所对应的属性值可以是一个对象。该对象是用于描述该属性的类型，默认值，是否必需等</p>\n<p>在父子组件之间通信时，我们可以在父组件定义改变数据的方法，然后将该方法作为一个prop传入给子组件。当子组件需要修改父组件数据时调用该方法即可(跟react父子之间通信道理一样)</p>\n<p><code>demo</code></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue props&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;parent-component/&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n\n\n    Vue.component(&#39;child-component&#39;,&#123;\n      template:`&lt;button @click=&#39;changeParentData&#39;&gt;change parent component data&lt;/button&gt;`,\n      props:&#123;\n        changeParentData:&#123;\n          type:Function,\n          required:true\n        &#125;\n      &#125;\n    &#125;);\n\n    Vue.component(&#39;parent-component&#39;,&#123;\n      template:`\n        &lt;div&gt;\n          &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;\n          &lt;child-component :changeParentData=&quot;changeParentData&quot;/&gt;\n        &lt;/div&gt;\n      `,\n      data:function()&#123;\n        return&#123;\n          msg:&#39;parent data&#39;\n        &#125;\n      &#125;,\n      methods:&#123;\n        changeParentData:function()&#123;\n          this.msg += &#39; change&#39;;\n        &#125;\n      &#125;\n    &#125;)\n\n\n    new Vue(&#123;\n      el: &#39;#app&#39;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p>注意，该方式的数据流是单向的，即<code>父组件 --&gt; 子组件</code>。也就是说我们无法通过该方式来实现通过父组件来修改子组件数据</p>\n<h4 id=\"emit\"><a href=\"#emit\" class=\"headerlink\" title=\"$emit\"></a>$emit</h4><p>此方式是通过监听事件然后触发回调函数来实现组件通信，且该方法只能用于子组件向父组件传递数据<br>方式 <code>子组件 --&gt; 父组件</code> </p>\n<p><code>demo</code></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;title&gt;Vue props&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;parent-component /&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n\n    Vue.component(&#39;child-component&#39;, &#123;\n      template: `&lt;button @click=&quot;postDataToParent&quot;&gt;post data to parent component&lt;/button&gt;`,\n      data:function()&#123;\n        return&#123;\n          msg:&quot;hello child component&quot;\n        &#125;\n      &#125;,\n      methods:&#123;\n        postDataToParent:function()&#123;\n          alert(&#39;post data to parent!&#39;);\n          this.$emit(&#39;receive&#39;,this.msg);\n        &#125;\n      &#125;\n    &#125;);\n\n    Vue.component(&#39;parent-component&#39;, &#123;\n      template: `\n        &lt;div&gt;\n          &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;\n          &lt;child-component @receive=&quot;receive&quot;/&gt;\n        &lt;/div&gt;\n      `,\n      data: function () &#123;\n        return &#123;\n          msg: &#39;parent data&#39;\n        &#125;\n      &#125;,\n      methods: &#123;\n        receive: function (data) &#123;\n          alert(&#39;receive data from child!&#39;);\n          this.msg = data;\n        &#125;\n      &#125;\n    &#125;)\n\n    new Vue(&#123;\n      el: &#39;#app&#39;\n    &#125;)\n\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"消息订阅发布机制-PubSubJS\"><a href=\"#消息订阅发布机制-PubSubJS\" class=\"headerlink\" title=\"消息订阅发布机制(PubSubJS)\"></a>消息订阅发布机制(PubSubJS)</h4><p>PubSubJS地址: <a href=\"https://www.npmjs.com/package/pubsubjs\">https://www.npmjs.com/package/pubsubjs</a></p>\n<p>我们可以使用PubSubJS来完成组件的通信,模式为订阅者 – 发布者模式。当一个组件A想要向另一个组件B通信时,首先组件B要订阅A发布的消息,然后当A要向B通信时就直接发布相应消息</p>\n<p>订阅消息  </p>\n<p>PubSub.subscribe(‘msg’,function(msg,data){})</p>\n<p>发布消息  </p>\n<p>PubSub.publish(‘msg’,data)</p>\n"},{"title":"vue3的基本认识和使用","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"vue","date":"2020-07-20T10:00:00.000Z","comments":0,"description":"vue3的基本认识和使用","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识_bg.jpg"],"_content":"\n## 基本认识\n\n`vue3` 是 `vue2` 的下一个版本，至于为什么会出现 `vue3` 主要是因为在使用 `vue2` 的过程中出现了一些改善框架所根本或者需要花费很大代价才能解决的问题。大致说可以归为以下两种\n1. `vue2`中缺少简介且低成本的机制来提取和重用多个组件之间的逻辑\n2. 随着功能的增长，组件越来越复杂，组件的代码越来越让人难以理解，而且我们只能根据 `Vue` 现有的API来尽量使得代码变得令人简单理解，但是这最终还是无法从根本上解决组件代码越来越复杂的问题。\n\n而这是因为以上原因，`vue3` 就重新设计了组件的相关api，原本编写一个 `vue` 组件需要提供 `data` 和 `method`，在 `vue3` 中只需要指定 `setup` 入口函数就可以完成一个组件的渲染工作，`setup` 函数返回的值将会合并到 `vue` 的渲染上下文中，所返回的值都可以用于模板的渲染。\n\n而且，由于最近几年 [typescript](https://www.tslang.cn/)的兴起，现大部分项目都使用了 `typescript`，而在 `vue2` 中对于 `typescript` 的支持需要引入相关的支持包，并且对 `typescript` 的支持度也是有限的。也正是因为这样，vue3所有的源代码都是由 `typescript` 所编写的，最大程度上支持了 `typescript`。\n\n总的来说，vue3的优势如下\n1. 组件化编写组件变为 `composition` 编写组件\n2. 将 `vue` 框架源码按API分包编写然后组合，这样就可以按只需功能打包，减少打包体积\n3. 对 `typescript` 有了更好的支持\n\n\n#### 资料连接\n1. [Github](https://github.com/vuejs/vue-next)\n2. [Composition_API](https://composition-api.vuejs.org/zh/)\n\n\n## 基本使用\n\n我们只需要按照以下步骤就可以完成 `vue3` 的尝鲜使用\n1. 在Github上克隆该项目 [vue-next-webpack-preview](https://github.com/vuejs/vue-next-webpack-preview.git)\n2. 运行 `npm i` 安装相关依赖\n3. 运行 `npm run dev` 运行项目\n\n现在，我们关注代码，其实使用 `vue3` 语法的也就只有 `main.js` 和 `App.vue`文件\n\n`main.js`\n```js\n// 项目运行的入口文件\nimport { createApp } from 'vue' // 引入创建vue-component方法\nimport App from './App.vue' // 导入vue组件\n\ncreateApp(App).mount('#app') // 创建vue实例并挂载到dom上\n```\n\n`App.vue`\n```vue\n<template>\n  <img src=\"./logo.png\">\n  <h1>Hello Vue 3!</h1>\n  <button @click=\"inc\">Clicked {{ count }} times.</button>\n</template>\n\n<script>\nimport { ref } from 'vue' // 引入ref方法\n\nexport default {\n  // 组件创建的入口方法\n  setup() {\n    const count = ref(0) // 定义响应式数据\n    const inc = () => {\n      count.value++\n    } // 定义方法\n\n    // 返回的数据会注册到渲染上下文(context)，模板渲染所需要的数据可以从这上下文(context)中获取\n    return {\n      count,\n      inc\n    }\n  }\n}\n</script>\n\n<style scoped>\nimg {\n  width: 200px;\n}\nh1 {\n  font-family: Arial, Helvetica, sans-serif;\n}\n</style>\n```\n\n`思路`\n1. 从 `vue` 导入创建组件的方法 `createApp`\n2. 导入 `App.vue`\n3. 创建好并挂载到 DOM 上\n\n## 思维导图\n\n![vue3](https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识 01.jpg)","source":"_posts/前端/vue/vue3的基本认识和使用.md","raw":"---\ntitle: vue3的基本认识和使用\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - vue\nkeywords: vue\ndate: 2020-07-20 18:00:00\ncomments: false\ndescription: vue3的基本认识和使用\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识_bg.jpg\n---\n\n## 基本认识\n\n`vue3` 是 `vue2` 的下一个版本，至于为什么会出现 `vue3` 主要是因为在使用 `vue2` 的过程中出现了一些改善框架所根本或者需要花费很大代价才能解决的问题。大致说可以归为以下两种\n1. `vue2`中缺少简介且低成本的机制来提取和重用多个组件之间的逻辑\n2. 随着功能的增长，组件越来越复杂，组件的代码越来越让人难以理解，而且我们只能根据 `Vue` 现有的API来尽量使得代码变得令人简单理解，但是这最终还是无法从根本上解决组件代码越来越复杂的问题。\n\n而这是因为以上原因，`vue3` 就重新设计了组件的相关api，原本编写一个 `vue` 组件需要提供 `data` 和 `method`，在 `vue3` 中只需要指定 `setup` 入口函数就可以完成一个组件的渲染工作，`setup` 函数返回的值将会合并到 `vue` 的渲染上下文中，所返回的值都可以用于模板的渲染。\n\n而且，由于最近几年 [typescript](https://www.tslang.cn/)的兴起，现大部分项目都使用了 `typescript`，而在 `vue2` 中对于 `typescript` 的支持需要引入相关的支持包，并且对 `typescript` 的支持度也是有限的。也正是因为这样，vue3所有的源代码都是由 `typescript` 所编写的，最大程度上支持了 `typescript`。\n\n总的来说，vue3的优势如下\n1. 组件化编写组件变为 `composition` 编写组件\n2. 将 `vue` 框架源码按API分包编写然后组合，这样就可以按只需功能打包，减少打包体积\n3. 对 `typescript` 有了更好的支持\n\n\n#### 资料连接\n1. [Github](https://github.com/vuejs/vue-next)\n2. [Composition_API](https://composition-api.vuejs.org/zh/)\n\n\n## 基本使用\n\n我们只需要按照以下步骤就可以完成 `vue3` 的尝鲜使用\n1. 在Github上克隆该项目 [vue-next-webpack-preview](https://github.com/vuejs/vue-next-webpack-preview.git)\n2. 运行 `npm i` 安装相关依赖\n3. 运行 `npm run dev` 运行项目\n\n现在，我们关注代码，其实使用 `vue3` 语法的也就只有 `main.js` 和 `App.vue`文件\n\n`main.js`\n```js\n// 项目运行的入口文件\nimport { createApp } from 'vue' // 引入创建vue-component方法\nimport App from './App.vue' // 导入vue组件\n\ncreateApp(App).mount('#app') // 创建vue实例并挂载到dom上\n```\n\n`App.vue`\n```vue\n<template>\n  <img src=\"./logo.png\">\n  <h1>Hello Vue 3!</h1>\n  <button @click=\"inc\">Clicked {{ count }} times.</button>\n</template>\n\n<script>\nimport { ref } from 'vue' // 引入ref方法\n\nexport default {\n  // 组件创建的入口方法\n  setup() {\n    const count = ref(0) // 定义响应式数据\n    const inc = () => {\n      count.value++\n    } // 定义方法\n\n    // 返回的数据会注册到渲染上下文(context)，模板渲染所需要的数据可以从这上下文(context)中获取\n    return {\n      count,\n      inc\n    }\n  }\n}\n</script>\n\n<style scoped>\nimg {\n  width: 200px;\n}\nh1 {\n  font-family: Arial, Helvetica, sans-serif;\n}\n</style>\n```\n\n`思路`\n1. 从 `vue` 导入创建组件的方法 `createApp`\n2. 导入 `App.vue`\n3. 创建好并挂载到 DOM 上\n\n## 思维导图\n\n![vue3](https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识 01.jpg)","slug":"前端/vue/vue3的基本认识和使用","published":1,"updated":"2023-05-12T23:28:10.996Z","layout":"post","link":"","_id":"clhws1t3000282h171z4m9aym","content":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p><code>vue3</code> 是 <code>vue2</code> 的下一个版本，至于为什么会出现 <code>vue3</code> 主要是因为在使用 <code>vue2</code> 的过程中出现了一些改善框架所根本或者需要花费很大代价才能解决的问题。大致说可以归为以下两种</p>\n<ol>\n<li><code>vue2</code>中缺少简介且低成本的机制来提取和重用多个组件之间的逻辑</li>\n<li>随着功能的增长，组件越来越复杂，组件的代码越来越让人难以理解，而且我们只能根据 <code>Vue</code> 现有的API来尽量使得代码变得令人简单理解，但是这最终还是无法从根本上解决组件代码越来越复杂的问题。</li>\n</ol>\n<p>而这是因为以上原因，<code>vue3</code> 就重新设计了组件的相关api，原本编写一个 <code>vue</code> 组件需要提供 <code>data</code> 和 <code>method</code>，在 <code>vue3</code> 中只需要指定 <code>setup</code> 入口函数就可以完成一个组件的渲染工作，<code>setup</code> 函数返回的值将会合并到 <code>vue</code> 的渲染上下文中，所返回的值都可以用于模板的渲染。</p>\n<p>而且，由于最近几年 <a href=\"https://www.tslang.cn/\">typescript</a>的兴起，现大部分项目都使用了 <code>typescript</code>，而在 <code>vue2</code> 中对于 <code>typescript</code> 的支持需要引入相关的支持包，并且对 <code>typescript</code> 的支持度也是有限的。也正是因为这样，vue3所有的源代码都是由 <code>typescript</code> 所编写的，最大程度上支持了 <code>typescript</code>。</p>\n<p>总的来说，vue3的优势如下</p>\n<ol>\n<li>组件化编写组件变为 <code>composition</code> 编写组件</li>\n<li>将 <code>vue</code> 框架源码按API分包编写然后组合，这样就可以按只需功能打包，减少打包体积</li>\n<li>对 <code>typescript</code> 有了更好的支持</li>\n</ol>\n<h4 id=\"资料连接\"><a href=\"#资料连接\" class=\"headerlink\" title=\"资料连接\"></a>资料连接</h4><ol>\n<li><a href=\"https://github.com/vuejs/vue-next\">Github</a></li>\n<li><a href=\"https://composition-api.vuejs.org/zh/\">Composition_API</a></li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>我们只需要按照以下步骤就可以完成 <code>vue3</code> 的尝鲜使用</p>\n<ol>\n<li>在Github上克隆该项目 <a href=\"https://github.com/vuejs/vue-next-webpack-preview.git\">vue-next-webpack-preview</a></li>\n<li>运行 <code>npm i</code> 安装相关依赖</li>\n<li>运行 <code>npm run dev</code> 运行项目</li>\n</ol>\n<p>现在，我们关注代码，其实使用 <code>vue3</code> 语法的也就只有 <code>main.js</code> 和 <code>App.vue</code>文件</p>\n<p><code>main.js</code></p>\n<pre><code class=\"js\">// 项目运行的入口文件\nimport &#123; createApp &#125; from &#39;vue&#39; // 引入创建vue-component方法\nimport App from &#39;./App.vue&#39; // 导入vue组件\n\ncreateApp(App).mount(&#39;#app&#39;) // 创建vue实例并挂载到dom上\n</code></pre>\n<p><code>App.vue</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;img src=&quot;./logo.png&quot;&gt;\n  &lt;h1&gt;Hello Vue 3!&lt;/h1&gt;\n  &lt;button @click=&quot;inc&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39; // 引入ref方法\n\nexport default &#123;\n  // 组件创建的入口方法\n  setup() &#123;\n    const count = ref(0) // 定义响应式数据\n    const inc = () =&gt; &#123;\n      count.value++\n    &#125; // 定义方法\n\n    // 返回的数据会注册到渲染上下文(context)，模板渲染所需要的数据可以从这上下文(context)中获取\n    return &#123;\n      count,\n      inc\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\nimg &#123;\n  width: 200px;\n&#125;\nh1 &#123;\n  font-family: Arial, Helvetica, sans-serif;\n&#125;\n&lt;/style&gt;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>从 <code>vue</code> 导入创建组件的方法 <code>createApp</code></li>\n<li>导入 <code>App.vue</code></li>\n<li>创建好并挂载到 DOM 上</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p>![vue3](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/vue3%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识</a> 01.jpg)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p><code>vue3</code> 是 <code>vue2</code> 的下一个版本，至于为什么会出现 <code>vue3</code> 主要是因为在使用 <code>vue2</code> 的过程中出现了一些改善框架所根本或者需要花费很大代价才能解决的问题。大致说可以归为以下两种</p>\n<ol>\n<li><code>vue2</code>中缺少简介且低成本的机制来提取和重用多个组件之间的逻辑</li>\n<li>随着功能的增长，组件越来越复杂，组件的代码越来越让人难以理解，而且我们只能根据 <code>Vue</code> 现有的API来尽量使得代码变得令人简单理解，但是这最终还是无法从根本上解决组件代码越来越复杂的问题。</li>\n</ol>\n<p>而这是因为以上原因，<code>vue3</code> 就重新设计了组件的相关api，原本编写一个 <code>vue</code> 组件需要提供 <code>data</code> 和 <code>method</code>，在 <code>vue3</code> 中只需要指定 <code>setup</code> 入口函数就可以完成一个组件的渲染工作，<code>setup</code> 函数返回的值将会合并到 <code>vue</code> 的渲染上下文中，所返回的值都可以用于模板的渲染。</p>\n<p>而且，由于最近几年 <a href=\"https://www.tslang.cn/\">typescript</a>的兴起，现大部分项目都使用了 <code>typescript</code>，而在 <code>vue2</code> 中对于 <code>typescript</code> 的支持需要引入相关的支持包，并且对 <code>typescript</code> 的支持度也是有限的。也正是因为这样，vue3所有的源代码都是由 <code>typescript</code> 所编写的，最大程度上支持了 <code>typescript</code>。</p>\n<p>总的来说，vue3的优势如下</p>\n<ol>\n<li>组件化编写组件变为 <code>composition</code> 编写组件</li>\n<li>将 <code>vue</code> 框架源码按API分包编写然后组合，这样就可以按只需功能打包，减少打包体积</li>\n<li>对 <code>typescript</code> 有了更好的支持</li>\n</ol>\n<h4 id=\"资料连接\"><a href=\"#资料连接\" class=\"headerlink\" title=\"资料连接\"></a>资料连接</h4><ol>\n<li><a href=\"https://github.com/vuejs/vue-next\">Github</a></li>\n<li><a href=\"https://composition-api.vuejs.org/zh/\">Composition_API</a></li>\n</ol>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>我们只需要按照以下步骤就可以完成 <code>vue3</code> 的尝鲜使用</p>\n<ol>\n<li>在Github上克隆该项目 <a href=\"https://github.com/vuejs/vue-next-webpack-preview.git\">vue-next-webpack-preview</a></li>\n<li>运行 <code>npm i</code> 安装相关依赖</li>\n<li>运行 <code>npm run dev</code> 运行项目</li>\n</ol>\n<p>现在，我们关注代码，其实使用 <code>vue3</code> 语法的也就只有 <code>main.js</code> 和 <code>App.vue</code>文件</p>\n<p><code>main.js</code></p>\n<pre><code class=\"js\">// 项目运行的入口文件\nimport &#123; createApp &#125; from &#39;vue&#39; // 引入创建vue-component方法\nimport App from &#39;./App.vue&#39; // 导入vue组件\n\ncreateApp(App).mount(&#39;#app&#39;) // 创建vue实例并挂载到dom上\n</code></pre>\n<p><code>App.vue</code></p>\n<pre><code class=\"vue\">&lt;template&gt;\n  &lt;img src=&quot;./logo.png&quot;&gt;\n  &lt;h1&gt;Hello Vue 3!&lt;/h1&gt;\n  &lt;button @click=&quot;inc&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport &#123; ref &#125; from &#39;vue&#39; // 引入ref方法\n\nexport default &#123;\n  // 组件创建的入口方法\n  setup() &#123;\n    const count = ref(0) // 定义响应式数据\n    const inc = () =&gt; &#123;\n      count.value++\n    &#125; // 定义方法\n\n    // 返回的数据会注册到渲染上下文(context)，模板渲染所需要的数据可以从这上下文(context)中获取\n    return &#123;\n      count,\n      inc\n    &#125;\n  &#125;\n&#125;\n&lt;/script&gt;\n\n&lt;style scoped&gt;\nimg &#123;\n  width: 200px;\n&#125;\nh1 &#123;\n  font-family: Arial, Helvetica, sans-serif;\n&#125;\n&lt;/style&gt;\n</code></pre>\n<p><code>思路</code></p>\n<ol>\n<li>从 <code>vue</code> 导入创建组件的方法 <code>createApp</code></li>\n<li>导入 <code>App.vue</code></li>\n<li>创建好并挂载到 DOM 上</li>\n</ol>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p>![vue3](<a href=\"https://gitee.com/trueLoving/cdn/raw/master/img/vue3%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86\">https://gitee.com/trueLoving/cdn/raw/master/img/vue3的基本认识</a> 01.jpg)</p>\n"},{"title":"Webpack 开发配置","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2019-12-23T16:00:00.000Z","comments":0,"description":"Webpack 开发配置","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/webpack_2.jpg"],"_content":"\n\n## CSS \n\n相关包：style-loader,css-loader\n\n使用，在loade中使用\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n            {\n                test:/\\.css$/,\n                use:['style-loader','css-loader']\n            },\n            {\n                test:/\\.less$/,\n                use:['style-loader','css-loader','less-loader']\n            }\n        ]\n\t}\n}\n```\n\n## JavaScript\n\nwebpack本身就支持js和json\n\n但是为了考虑js代码的兼容性，我们会使用babel来做预处理\n\n相关包：babel-loader, @babel/core\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n            {\n            \ttest:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:'babel-loader'\n            }\n        ]\n\t}\n}\n```\n\n## HTML\n\n相关包：html-webpack-plugin\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n   //  ....\n  \tplugins:[\n        new HtmlWebpackPlugin({\n            template:'index.html'\n        })\n    ]\n}\n```\n\n## Image\n\n相关包：url-loader,html-loader(用于处理html文件中引入的图片资源)\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n           {\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:'url-loader',\n               options:{\n                   limit:8*1024,\n                   esModule:false\n               }\n           },\n           {\n               test:/\\.html$/,\n               loader:'html-loader'\n           }\n        ]\n\t}\n}\n```\n\n## others\n\n例如字体文件，图标文件等\n\n相关包：file-loader\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n           {\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:'file-loader'\n           }\n        ]\n\t}\n}\n```\n\n## 总和\n\n下面是一个最简单的webpack运行配置\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    // 入口文件\n    entry:'./src/main.js'\n    // 输出文件\n    output:{\n    \tfilename:'js/built.js',\n    \tpath:resolve(__dirname,'build')\n\t},\n    // loader\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:['style-loader','css-loader']\n            },\n            {\n            \ttest:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:'babel-loader'\n            },\n            {\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:'url-loader',\n               options:{\n                   limit:8*1024,\n                   esModule:false\n               }\n            },\n           \t{\n               test:/\\.html$/,\n               loader:'html-loader'\n           \t},\n            {\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:'file-loader'\n           \t}\n        ]\n    },\n    // 插件\n    plugins:[\n           new HtmlWebpackPlugin() \n    ],\n    // 运行模式,development\n    mode:'development',\n        \n}\n\n```\n\n","source":"_posts/前端/Webpack/02 开发配置.md","raw":"---\ntitle: Webpack 开发配置\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2019-12-24\ncomments: false\ndescription: Webpack 开发配置\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/webpack_2.jpg\n---\n\n\n## CSS \n\n相关包：style-loader,css-loader\n\n使用，在loade中使用\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n            {\n                test:/\\.css$/,\n                use:['style-loader','css-loader']\n            },\n            {\n                test:/\\.less$/,\n                use:['style-loader','css-loader','less-loader']\n            }\n        ]\n\t}\n}\n```\n\n## JavaScript\n\nwebpack本身就支持js和json\n\n但是为了考虑js代码的兼容性，我们会使用babel来做预处理\n\n相关包：babel-loader, @babel/core\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n            {\n            \ttest:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:'babel-loader'\n            }\n        ]\n\t}\n}\n```\n\n## HTML\n\n相关包：html-webpack-plugin\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n   //  ....\n  \tplugins:[\n        new HtmlWebpackPlugin({\n            template:'index.html'\n        })\n    ]\n}\n```\n\n## Image\n\n相关包：url-loader,html-loader(用于处理html文件中引入的图片资源)\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n           {\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:'url-loader',\n               options:{\n                   limit:8*1024,\n                   esModule:false\n               }\n           },\n           {\n               test:/\\.html$/,\n               loader:'html-loader'\n           }\n        ]\n\t}\n}\n```\n\n## others\n\n例如字体文件，图标文件等\n\n相关包：file-loader\n\n```js\nmodule.exports = {\n   //  ....\n    module:{\n    \trules:[\n           {\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:'file-loader'\n           }\n        ]\n\t}\n}\n```\n\n## 总和\n\n下面是一个最简单的webpack运行配置\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    // 入口文件\n    entry:'./src/main.js'\n    // 输出文件\n    output:{\n    \tfilename:'js/built.js',\n    \tpath:resolve(__dirname,'build')\n\t},\n    // loader\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:['style-loader','css-loader']\n            },\n            {\n            \ttest:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:'babel-loader'\n            },\n            {\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:'url-loader',\n               options:{\n                   limit:8*1024,\n                   esModule:false\n               }\n            },\n           \t{\n               test:/\\.html$/,\n               loader:'html-loader'\n           \t},\n            {\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:'file-loader'\n           \t}\n        ]\n    },\n    // 插件\n    plugins:[\n           new HtmlWebpackPlugin() \n    ],\n    // 运行模式,development\n    mode:'development',\n        \n}\n\n```\n\n","slug":"前端/Webpack/02 开发配置","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t31002b2h17h4b1847j","content":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>相关包：style-loader,css-loader</p>\n<p>使用，在loade中使用</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n            &#125;,\n            &#123;\n                test:/\\.less$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>webpack本身就支持js和json</p>\n<p>但是为了考虑js代码的兼容性，我们会使用babel来做预处理</p>\n<p>相关包：babel-loader, @babel&#x2F;core</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:&#39;babel-loader&#39;\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>相关包：html-webpack-plugin</p>\n<pre><code class=\"js\">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n   //  ....\n      plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;index.html&#39;\n        &#125;)\n    ]\n&#125;\n</code></pre>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><p>相关包：url-loader,html-loader(用于处理html文件中引入的图片资源)</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n           &#123;\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:&#39;url-loader&#39;,\n               options:&#123;\n                   limit:8*1024,\n                   esModule:false\n               &#125;\n           &#125;,\n           &#123;\n               test:/\\.html$/,\n               loader:&#39;html-loader&#39;\n           &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h2><p>例如字体文件，图标文件等</p>\n<p>相关包：file-loader</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n           &#123;\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:&#39;file-loader&#39;\n           &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"总和\"><a href=\"#总和\" class=\"headerlink\" title=\"总和\"></a>总和</h2><p>下面是一个最简单的webpack运行配置</p>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    // 入口文件\n    entry:&#39;./src/main.js&#39;\n    // 输出文件\n    output:&#123;\n        filename:&#39;js/built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    // loader\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n            &#125;,\n            &#123;\n                test:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:&#39;babel-loader&#39;\n            &#125;,\n            &#123;\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:&#39;url-loader&#39;,\n               options:&#123;\n                   limit:8*1024,\n                   esModule:false\n               &#125;\n            &#125;,\n               &#123;\n               test:/\\.html$/,\n               loader:&#39;html-loader&#39;\n               &#125;,\n            &#123;\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:&#39;file-loader&#39;\n               &#125;\n        ]\n    &#125;,\n    // 插件\n    plugins:[\n           new HtmlWebpackPlugin() \n    ],\n    // 运行模式,development\n    mode:&#39;development&#39;,\n        \n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><p>相关包：style-loader,css-loader</p>\n<p>使用，在loade中使用</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n            &#125;,\n            &#123;\n                test:/\\.less$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>webpack本身就支持js和json</p>\n<p>但是为了考虑js代码的兼容性，我们会使用babel来做预处理</p>\n<p>相关包：babel-loader, @babel&#x2F;core</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:&#39;babel-loader&#39;\n            &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>相关包：html-webpack-plugin</p>\n<pre><code class=\"js\">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n   //  ....\n      plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;index.html&#39;\n        &#125;)\n    ]\n&#125;\n</code></pre>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><p>相关包：url-loader,html-loader(用于处理html文件中引入的图片资源)</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n           &#123;\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:&#39;url-loader&#39;,\n               options:&#123;\n                   limit:8*1024,\n                   esModule:false\n               &#125;\n           &#125;,\n           &#123;\n               test:/\\.html$/,\n               loader:&#39;html-loader&#39;\n           &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h2><p>例如字体文件，图标文件等</p>\n<p>相关包：file-loader</p>\n<pre><code class=\"js\">module.exports = &#123;\n   //  ....\n    module:&#123;\n        rules:[\n           &#123;\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:&#39;file-loader&#39;\n           &#125;\n        ]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"总和\"><a href=\"#总和\" class=\"headerlink\" title=\"总和\"></a>总和</h2><p>下面是一个最简单的webpack运行配置</p>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    // 入口文件\n    entry:&#39;./src/main.js&#39;\n    // 输出文件\n    output:&#123;\n        filename:&#39;js/built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    // loader\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n            &#125;,\n            &#123;\n                test:/\\.js$/,\n                // 让babel跳过/node_modules/文件夹下的编译\n                exclude:/node_modules/,\n                loader:&#39;babel-loader&#39;\n            &#125;,\n            &#123;\n               test:/\\.(jpg|png|gif|jpeg)$/,\n               loader:&#39;url-loader&#39;,\n               options:&#123;\n                   limit:8*1024,\n                   esModule:false\n               &#125;\n            &#125;,\n               &#123;\n               test:/\\.html$/,\n               loader:&#39;html-loader&#39;\n               &#125;,\n            &#123;\n               exclude:/\\.(html|css|js|png|gif|jpg|jpeg)$/,\n               loader:&#39;file-loader&#39;\n               &#125;\n        ]\n    &#125;,\n    // 插件\n    plugins:[\n           new HtmlWebpackPlugin() \n    ],\n    // 运行模式,development\n    mode:&#39;development&#39;,\n        \n&#125;\n</code></pre>\n"},{"title":"Webpack 基本认识","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2019-12-20T16:00:00.000Z","comments":0,"description":"Webpack 基本认识","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/webpack_1.jpg"],"_content":"\n\n## 1. Webpack是什么\n\n1. 前端资源构建工具（将代码在运行前进行处理，使得浏览器能够支持运行该代码）\n2. 静态模块打包器（将前端的所有资源文件作为模块，根据模块的依赖关系进行静态分析，打包成对应的静态资源(bundle)）\n\n## 2. webpack 五个核心概念\n\n1. Entry（入口）\n\n\n指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。\n\n\n2. Output（输出）\n\n\n指示webpack打包后的资源bundles输出到哪里去，以及如何命名\n\n\n3. Loader\n\n\n让webpack能够处理那些非JavaScript文件（类似于一些提供一些翻译功能）\n\n\n4. Plugins\n\n\n可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等\n\n\n5. Mode\n\n\n模式指示Webpack使用相应模式的配置\n\n\n![webpack基本认识](https://gitee.com/trueLoving/cdn/raw/master/img/webpack的基本认识01.PNG)\n\n## 3. webpack的基本使用\n\n1. npm init -y\n2. npm i webpack webpack-cli -g\n3. 编写入口文件(./src/index.js 为例)，创建打包后的输出文件所存放的文件夹( ./build/为例)\n4. 运行命令\n   1. 开发模式：webpack ./src/index.js -o ./build/built.js --mode==development\n   2. 生产模式：webpack ./src/index.js -o ./build/built.js --mode==development\n5. 运行成功后会发现build文件夹下有一个built.js文件，该js文件可以被浏览器直接运行，也可以被node运行\n\n## 4. 其他\n\n#### 1. webpack能够处理js/json文件，不能处理其他文件（除非引入相关loader进行预处理）\n\n#### 2.根目录下的文件webpack.config.js webpack的配置文件\n   1. 作用：指示webpack在运行时应该加载哪些配置\n   2. 所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs\n\n#### 3. webpack常见要打包的文件类型\n\n1. css\nstyle-loader 创建style标签并将js中的样式资源插入进行添加到head中生效\ncss-loader 将css代码变成commonjs加载到js中，以字符串的形式来存储css内容\nMiniCssExtractPlugin --> 从js代码中提取css\npostcss,postcss-loader,postcss-preset-env --> 处理css的兼容性\nOptimizeCssAssetsWebpackPlugins --> 压缩css代码\n   \n2. js\neslint-loader eslint-config-airbnb-base eslint-plugin-import eslint --> js的语法检查\nbabel-loader @babel/core @babel/preset-env @babel/polyfill core-js --> 处理js的兼容性\n   \n3. html\nHtmlWebpackPlugin 该插件功能会默认创建一个空的HTML文件，自动引入打包输出所有的资源\n   \n4. images\nurl-loader  解析url中引入的图片,默认使用es6模块解析(因此，在这里要关闭该loader的es6语法)\nfile-loader 原样输出文件\nhtml-loader 处理html文件的img图片,默认使用commonjs模块解析\n\n## webpack的其他插件/第三方依赖库\n\n1. workbox-webpack-plugin PWD依赖\n2. thread-loader 多进程打包依赖","source":"_posts/前端/Webpack/01 基本认识.md","raw":"---\ntitle: Webpack 基本认识\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2019-12-21\ncomments: false\ndescription: Webpack 基本认识\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/webpack_1.jpg\n---\n\n\n## 1. Webpack是什么\n\n1. 前端资源构建工具（将代码在运行前进行处理，使得浏览器能够支持运行该代码）\n2. 静态模块打包器（将前端的所有资源文件作为模块，根据模块的依赖关系进行静态分析，打包成对应的静态资源(bundle)）\n\n## 2. webpack 五个核心概念\n\n1. Entry（入口）\n\n\n指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。\n\n\n2. Output（输出）\n\n\n指示webpack打包后的资源bundles输出到哪里去，以及如何命名\n\n\n3. Loader\n\n\n让webpack能够处理那些非JavaScript文件（类似于一些提供一些翻译功能）\n\n\n4. Plugins\n\n\n可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等\n\n\n5. Mode\n\n\n模式指示Webpack使用相应模式的配置\n\n\n![webpack基本认识](https://gitee.com/trueLoving/cdn/raw/master/img/webpack的基本认识01.PNG)\n\n## 3. webpack的基本使用\n\n1. npm init -y\n2. npm i webpack webpack-cli -g\n3. 编写入口文件(./src/index.js 为例)，创建打包后的输出文件所存放的文件夹( ./build/为例)\n4. 运行命令\n   1. 开发模式：webpack ./src/index.js -o ./build/built.js --mode==development\n   2. 生产模式：webpack ./src/index.js -o ./build/built.js --mode==development\n5. 运行成功后会发现build文件夹下有一个built.js文件，该js文件可以被浏览器直接运行，也可以被node运行\n\n## 4. 其他\n\n#### 1. webpack能够处理js/json文件，不能处理其他文件（除非引入相关loader进行预处理）\n\n#### 2.根目录下的文件webpack.config.js webpack的配置文件\n   1. 作用：指示webpack在运行时应该加载哪些配置\n   2. 所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs\n\n#### 3. webpack常见要打包的文件类型\n\n1. css\nstyle-loader 创建style标签并将js中的样式资源插入进行添加到head中生效\ncss-loader 将css代码变成commonjs加载到js中，以字符串的形式来存储css内容\nMiniCssExtractPlugin --> 从js代码中提取css\npostcss,postcss-loader,postcss-preset-env --> 处理css的兼容性\nOptimizeCssAssetsWebpackPlugins --> 压缩css代码\n   \n2. js\neslint-loader eslint-config-airbnb-base eslint-plugin-import eslint --> js的语法检查\nbabel-loader @babel/core @babel/preset-env @babel/polyfill core-js --> 处理js的兼容性\n   \n3. html\nHtmlWebpackPlugin 该插件功能会默认创建一个空的HTML文件，自动引入打包输出所有的资源\n   \n4. images\nurl-loader  解析url中引入的图片,默认使用es6模块解析(因此，在这里要关闭该loader的es6语法)\nfile-loader 原样输出文件\nhtml-loader 处理html文件的img图片,默认使用commonjs模块解析\n\n## webpack的其他插件/第三方依赖库\n\n1. workbox-webpack-plugin PWD依赖\n2. thread-loader 多进程打包依赖","slug":"前端/Webpack/01 基本认识","published":1,"updated":"2023-05-12T23:28:10.994Z","layout":"post","link":"","_id":"clhws1t31002e2h1752556n05","content":"<h2 id=\"1-Webpack是什么\"><a href=\"#1-Webpack是什么\" class=\"headerlink\" title=\"1. Webpack是什么\"></a>1. Webpack是什么</h2><ol>\n<li>前端资源构建工具（将代码在运行前进行处理，使得浏览器能够支持运行该代码）</li>\n<li>静态模块打包器（将前端的所有资源文件作为模块，根据模块的依赖关系进行静态分析，打包成对应的静态资源(bundle)）</li>\n</ol>\n<h2 id=\"2-webpack-五个核心概念\"><a href=\"#2-webpack-五个核心概念\" class=\"headerlink\" title=\"2. webpack 五个核心概念\"></a>2. webpack 五个核心概念</h2><ol>\n<li>Entry（入口）</li>\n</ol>\n<p>指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>\n<ol start=\"2\">\n<li>Output（输出）</li>\n</ol>\n<p>指示webpack打包后的资源bundles输出到哪里去，以及如何命名</p>\n<ol start=\"3\">\n<li>Loader</li>\n</ol>\n<p>让webpack能够处理那些非JavaScript文件（类似于一些提供一些翻译功能）</p>\n<ol start=\"4\">\n<li>Plugins</li>\n</ol>\n<p>可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</p>\n<ol start=\"5\">\n<li>Mode</li>\n</ol>\n<p>模式指示Webpack使用相应模式的配置</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%8601.PNG\" alt=\"webpack基本认识\"></p>\n<h2 id=\"3-webpack的基本使用\"><a href=\"#3-webpack的基本使用\" class=\"headerlink\" title=\"3. webpack的基本使用\"></a>3. webpack的基本使用</h2><ol>\n<li>npm init -y</li>\n<li>npm i webpack webpack-cli -g</li>\n<li>编写入口文件(.&#x2F;src&#x2F;index.js 为例)，创建打包后的输出文件所存放的文件夹( .&#x2F;build&#x2F;为例)</li>\n<li>运行命令<ol>\n<li>开发模式：webpack .&#x2F;src&#x2F;index.js -o .&#x2F;build&#x2F;built.js –mode&#x3D;&#x3D;development</li>\n<li>生产模式：webpack .&#x2F;src&#x2F;index.js -o .&#x2F;build&#x2F;built.js –mode&#x3D;&#x3D;development</li>\n</ol>\n</li>\n<li>运行成功后会发现build文件夹下有一个built.js文件，该js文件可以被浏览器直接运行，也可以被node运行</li>\n</ol>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h2><h4 id=\"1-webpack能够处理js-x2F-json文件，不能处理其他文件（除非引入相关loader进行预处理）\"><a href=\"#1-webpack能够处理js-x2F-json文件，不能处理其他文件（除非引入相关loader进行预处理）\" class=\"headerlink\" title=\"1. webpack能够处理js&#x2F;json文件，不能处理其他文件（除非引入相关loader进行预处理）\"></a>1. webpack能够处理js&#x2F;json文件，不能处理其他文件（除非引入相关loader进行预处理）</h4><h4 id=\"2-根目录下的文件webpack-config-js-webpack的配置文件\"><a href=\"#2-根目录下的文件webpack-config-js-webpack的配置文件\" class=\"headerlink\" title=\"2.根目录下的文件webpack.config.js webpack的配置文件\"></a>2.根目录下的文件webpack.config.js webpack的配置文件</h4><ol>\n<li>作用：指示webpack在运行时应该加载哪些配置</li>\n<li>所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs</li>\n</ol>\n<h4 id=\"3-webpack常见要打包的文件类型\"><a href=\"#3-webpack常见要打包的文件类型\" class=\"headerlink\" title=\"3. webpack常见要打包的文件类型\"></a>3. webpack常见要打包的文件类型</h4><ol>\n<li><p>css<br>style-loader 创建style标签并将js中的样式资源插入进行添加到head中生效<br>css-loader 将css代码变成commonjs加载到js中，以字符串的形式来存储css内容<br>MiniCssExtractPlugin –&gt; 从js代码中提取css<br>postcss,postcss-loader,postcss-preset-env –&gt; 处理css的兼容性<br>OptimizeCssAssetsWebpackPlugins –&gt; 压缩css代码</p>\n</li>\n<li><p>js<br>eslint-loader eslint-config-airbnb-base eslint-plugin-import eslint –&gt; js的语法检查<br>babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;polyfill core-js –&gt; 处理js的兼容性</p>\n</li>\n<li><p>html<br>HtmlWebpackPlugin 该插件功能会默认创建一个空的HTML文件，自动引入打包输出所有的资源</p>\n</li>\n<li><p>images<br>url-loader  解析url中引入的图片,默认使用es6模块解析(因此，在这里要关闭该loader的es6语法)<br>file-loader 原样输出文件<br>html-loader 处理html文件的img图片,默认使用commonjs模块解析</p>\n</li>\n</ol>\n<h2 id=\"webpack的其他插件-x2F-第三方依赖库\"><a href=\"#webpack的其他插件-x2F-第三方依赖库\" class=\"headerlink\" title=\"webpack的其他插件&#x2F;第三方依赖库\"></a>webpack的其他插件&#x2F;第三方依赖库</h2><ol>\n<li>workbox-webpack-plugin PWD依赖</li>\n<li>thread-loader 多进程打包依赖</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Webpack是什么\"><a href=\"#1-Webpack是什么\" class=\"headerlink\" title=\"1. Webpack是什么\"></a>1. Webpack是什么</h2><ol>\n<li>前端资源构建工具（将代码在运行前进行处理，使得浏览器能够支持运行该代码）</li>\n<li>静态模块打包器（将前端的所有资源文件作为模块，根据模块的依赖关系进行静态分析，打包成对应的静态资源(bundle)）</li>\n</ol>\n<h2 id=\"2-webpack-五个核心概念\"><a href=\"#2-webpack-五个核心概念\" class=\"headerlink\" title=\"2. webpack 五个核心概念\"></a>2. webpack 五个核心概念</h2><ol>\n<li>Entry（入口）</li>\n</ol>\n<p>指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>\n<ol start=\"2\">\n<li>Output（输出）</li>\n</ol>\n<p>指示webpack打包后的资源bundles输出到哪里去，以及如何命名</p>\n<ol start=\"3\">\n<li>Loader</li>\n</ol>\n<p>让webpack能够处理那些非JavaScript文件（类似于一些提供一些翻译功能）</p>\n<ol start=\"4\">\n<li>Plugins</li>\n</ol>\n<p>可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</p>\n<ol start=\"5\">\n<li>Mode</li>\n</ol>\n<p>模式指示Webpack使用相应模式的配置</p>\n<p><img src=\"https://gitee.com/trueLoving/cdn/raw/master/img/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%8601.PNG\" alt=\"webpack基本认识\"></p>\n<h2 id=\"3-webpack的基本使用\"><a href=\"#3-webpack的基本使用\" class=\"headerlink\" title=\"3. webpack的基本使用\"></a>3. webpack的基本使用</h2><ol>\n<li>npm init -y</li>\n<li>npm i webpack webpack-cli -g</li>\n<li>编写入口文件(.&#x2F;src&#x2F;index.js 为例)，创建打包后的输出文件所存放的文件夹( .&#x2F;build&#x2F;为例)</li>\n<li>运行命令<ol>\n<li>开发模式：webpack .&#x2F;src&#x2F;index.js -o .&#x2F;build&#x2F;built.js –mode&#x3D;&#x3D;development</li>\n<li>生产模式：webpack .&#x2F;src&#x2F;index.js -o .&#x2F;build&#x2F;built.js –mode&#x3D;&#x3D;development</li>\n</ol>\n</li>\n<li>运行成功后会发现build文件夹下有一个built.js文件，该js文件可以被浏览器直接运行，也可以被node运行</li>\n</ol>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h2><h4 id=\"1-webpack能够处理js-x2F-json文件，不能处理其他文件（除非引入相关loader进行预处理）\"><a href=\"#1-webpack能够处理js-x2F-json文件，不能处理其他文件（除非引入相关loader进行预处理）\" class=\"headerlink\" title=\"1. webpack能够处理js&#x2F;json文件，不能处理其他文件（除非引入相关loader进行预处理）\"></a>1. webpack能够处理js&#x2F;json文件，不能处理其他文件（除非引入相关loader进行预处理）</h4><h4 id=\"2-根目录下的文件webpack-config-js-webpack的配置文件\"><a href=\"#2-根目录下的文件webpack-config-js-webpack的配置文件\" class=\"headerlink\" title=\"2.根目录下的文件webpack.config.js webpack的配置文件\"></a>2.根目录下的文件webpack.config.js webpack的配置文件</h4><ol>\n<li>作用：指示webpack在运行时应该加载哪些配置</li>\n<li>所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs</li>\n</ol>\n<h4 id=\"3-webpack常见要打包的文件类型\"><a href=\"#3-webpack常见要打包的文件类型\" class=\"headerlink\" title=\"3. webpack常见要打包的文件类型\"></a>3. webpack常见要打包的文件类型</h4><ol>\n<li><p>css<br>style-loader 创建style标签并将js中的样式资源插入进行添加到head中生效<br>css-loader 将css代码变成commonjs加载到js中，以字符串的形式来存储css内容<br>MiniCssExtractPlugin –&gt; 从js代码中提取css<br>postcss,postcss-loader,postcss-preset-env –&gt; 处理css的兼容性<br>OptimizeCssAssetsWebpackPlugins –&gt; 压缩css代码</p>\n</li>\n<li><p>js<br>eslint-loader eslint-config-airbnb-base eslint-plugin-import eslint –&gt; js的语法检查<br>babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;polyfill core-js –&gt; 处理js的兼容性</p>\n</li>\n<li><p>html<br>HtmlWebpackPlugin 该插件功能会默认创建一个空的HTML文件，自动引入打包输出所有的资源</p>\n</li>\n<li><p>images<br>url-loader  解析url中引入的图片,默认使用es6模块解析(因此，在这里要关闭该loader的es6语法)<br>file-loader 原样输出文件<br>html-loader 处理html文件的img图片,默认使用commonjs模块解析</p>\n</li>\n</ol>\n<h2 id=\"webpack的其他插件-x2F-第三方依赖库\"><a href=\"#webpack的其他插件-x2F-第三方依赖库\" class=\"headerlink\" title=\"webpack的其他插件&#x2F;第三方依赖库\"></a>webpack的其他插件&#x2F;第三方依赖库</h2><ol>\n<li>workbox-webpack-plugin PWD依赖</li>\n<li>thread-loader 多进程打包依赖</li>\n</ol>\n"},{"title":"Webpack 生产配置","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2019-12-28T16:00:00.000Z","comments":0,"description":"Webpack 生产配置","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/webpack_3.jpg"],"_content":"\n\n\n1. css提取\n2. 代码压缩\n3. 样式兼容\n4. ......\n\n## 提取CSS文件\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // 'style-loader',\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n            // 该插件会自动将css通过link标签引入\n        \tfilename:'css/built.css'\n        })\n    ],\n    mode:'development'\n}\n```\n\n\n\n## CSS兼容性处理\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\n// 设置node的环境变量\nprocess.env.NODE_ENV=\"development\"\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    MiniCssExtractPlugin.loader\n                    'css-loader'\n                    // css兼容性处理：postcss -> postcss-loader,postcss-preset-env\n                    // 帮postcss找到package.json中browserlist里面的配置，通过配置加载相关css兼容性代码\n                    // 使用loader的默认配置和\n                    // 'postcss-loader'\n                    // 修改loader配置\n                    {\n                    \tloader:'postcss-loader',\n                    \toptions:{\n                    \t\tident:'postcss',\n                    \t\tplugins:()=>[\n                \t\t\t\t// postcss的插件\n                \t\t\t\trequire('postcss-preset-env')()\n                \t\t\t]\n                    \t}\n                    }\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n        \tfilename:'css/built.css'\n        })\n    ],\n    mode:'development'\n}\n```\n\n```json\n{\n    \"browserslist\":{\n        // 开发环境相关配置\n        \"development\":{\n            \"last 1 chrome version\",\n            \"last 1 firefox version\"\n            \"last 1 safari version\"\n        },\n        // 生产环境相关配置：默认\n        \"production\":[\n            \">0.2%\",\n            \"not dead\",\n            \"not op_mini all\"\n        ]\n        // 修改运行模式得要设置node的环境变量：process.env.NODE_ENV=\"development\"\n    }\n}\n```\n\n\n\n## 压缩css\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugins = require('optimize-css-assets-webpack-plugin')\t\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // 'style-loader',\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n        \tfilename:'css/built.css'\n        }),\n        // 压缩css\n        new OptimizeCssAssetsWebpackPlugins()\n    ],\n    mode:'development'\n}\n```\n\n## js语法检查\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\t\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                /*语法检查\n                注意：只需要检查自己写的代码，第三方依赖库的代码无需检查\n                设置检查规则\n                package.json中eslintConfig配置\n                \t\"eslintConfig\":{\n                    \t“extends”:\"aribnb-base\"\n            \t\t}\n                airbnb -> eslint-config-airbnb-base eslint-plugin-import eslint */\n                test:/\\.js$/,\n                execlide:/node_modules/,\n                loader:'eslint-loader',\n                options:{\n                    // 自动修复\n                    fix:true\n                }\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        })\n    ],\n    mode:'development'\n}\n```\n\n## js兼容性处理\n\n```js\nconst { resolve } = require(\"path\");\n\nmodule.exports = {\n    entry:\"./src/index,js\",\n    output:{\n        filename:\"built.js\",\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n        \t// js兼容性处理 babel-loader @babel/core \n            // 1. 基本的js兼容性处理--> @babel/preset-env 但这只能转换基本的语法\n            // 2. 全部js兼容性处理 --> @babel/polyfill 做全部的兼容性处理(Promise,Proxy,Reflect...) 通过在入口文件引入该依赖即可  全局引入，导致打包完后的文件体积太大\n            // 3. 按需加载 --->  core-js\n            {\n                test:/\\.js$/,\n                execlude:/node_modules/,\n                loader:'babel-loader',\n                options:{\n                    // 预设：指示babel做怎样的兼容性处理\n                    presets:[\n                        [\n                            ‘@babel/preset-env',\n                            {\n                            \tuseBuiltIns:'usage'\n                            \t// 指定core-js版本\n                            \tcorejs:{\n                            \t\tversion:3\n                           \t\t},\n                        \t\t// 指定兼容性到那个版本浏览器\n                        \t\ttargets:{\n                        \t\t\tchrome:'60',\n                        \t\t\tfirefox;'60',\n                        \t\t\tie:'9',\n                        \t\t\tsafari:'10',\n                        \t\t\tedge:'17'\n                        \t\t}\n                            }\n                        ]\n                    ]\n                }\n            }\n        ]\n    },\n    plugins:[\n        \n    ]\n}\n```\n\n## js代码压缩\n\n```js\n// 生产环境下自动压缩js代码  \n```\n\n## html代码压缩\n\n```\n在插件 html-webpack-plugin构造函数添加s属性对象\nminify:{\n\t// 移除空格\n\tcollapseWhitespace:true\n\t// 移除注释\n\tremoveComments:true\n}\n```\n\n## 总和\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = {\n    \n    entry: './src/js/index.js',\n    \n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, 'build')\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [...commonCssloader]\n            },\n            {\n                test: /\\.less$/,\n                use: [...commonCssloader, 'less-loader']\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                loader: 'babel-loader',\n                options: {\n                    presets: [\n                        '@babel/preset-env',\n                        {\n                            useBuiltIns: 'usage',\n                            corejs: { version: 3 },\n                            targets: {\n                                chrome: '60',\n                                firefox: '50'\n                            }\n                        }\n                    ]\n                }\n            },\n            {\n                test: /\\.(jpg|png|gif)$/,\n                loader: 'url-loader',\n                options: {\n                    limit: 8 * 1024,\n                    name: '[hash:10].[ext]',\n                    outputPath: 'imgs',\n                    esModule: false\n                }\n            },\n            {\n                test: /\\.html$/,\n                loader: 'html-loader'\n            },\n            {\n                execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                loader: 'file-loader',\n                options: {\n                    outputPath: 'media'\n                }\n            }\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    \n    mode: 'production'\n\n}\n\n// browserslist:{\n//     \"development\":[\n//         \"last 1 chrome version\",\n//         \"last 1 firefox version\",\n//         \"last 1 safari version\"\n//     ],\n//     \"production\":[\n//         \">0.2%\",\n//         \"not dead\",\n//         \"not op_mini all\"\n//     ]\n// }\n\n// eslintConfig:{\n//     \"extends\":'aribnb-base'\n// }\n```\n\n","source":"_posts/前端/Webpack/03 生产配置.md","raw":"---\ntitle: Webpack 生产配置\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2019-12-29\ncomments: false\ndescription: Webpack 生产配置\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/webpack_3.jpg\n---\n\n\n\n1. css提取\n2. 代码压缩\n3. 样式兼容\n4. ......\n\n## 提取CSS文件\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // 'style-loader',\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n            // 该插件会自动将css通过link标签引入\n        \tfilename:'css/built.css'\n        })\n    ],\n    mode:'development'\n}\n```\n\n\n\n## CSS兼容性处理\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\n// 设置node的环境变量\nprocess.env.NODE_ENV=\"development\"\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    MiniCssExtractPlugin.loader\n                    'css-loader'\n                    // css兼容性处理：postcss -> postcss-loader,postcss-preset-env\n                    // 帮postcss找到package.json中browserlist里面的配置，通过配置加载相关css兼容性代码\n                    // 使用loader的默认配置和\n                    // 'postcss-loader'\n                    // 修改loader配置\n                    {\n                    \tloader:'postcss-loader',\n                    \toptions:{\n                    \t\tident:'postcss',\n                    \t\tplugins:()=>[\n                \t\t\t\t// postcss的插件\n                \t\t\t\trequire('postcss-preset-env')()\n                \t\t\t]\n                    \t}\n                    }\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n        \tfilename:'css/built.css'\n        })\n    ],\n    mode:'development'\n}\n```\n\n```json\n{\n    \"browserslist\":{\n        // 开发环境相关配置\n        \"development\":{\n            \"last 1 chrome version\",\n            \"last 1 firefox version\"\n            \"last 1 safari version\"\n        },\n        // 生产环境相关配置：默认\n        \"production\":[\n            \">0.2%\",\n            \"not dead\",\n            \"not op_mini all\"\n        ]\n        // 修改运行模式得要设置node的环境变量：process.env.NODE_ENV=\"development\"\n    }\n}\n```\n\n\n\n## 压缩css\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCssAssetsWebpackPlugins = require('optimize-css-assets-webpack-plugin')\t\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // 'style-loader',\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        }),\n        new MiniCssExtractPlugin({\n            // 对输出的css文件进行重命名\n        \tfilename:'css/built.css'\n        }),\n        // 压缩css\n        new OptimizeCssAssetsWebpackPlugins()\n    ],\n    mode:'development'\n}\n```\n\n## js语法检查\n\n```js\nconst { resolve } = require(\"path\")\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\t\n\nmodule.exports = {\n    entry:\"./src/index.js\",\n    output:{\n        filename:'built.js',\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n            {\n                /*语法检查\n                注意：只需要检查自己写的代码，第三方依赖库的代码无需检查\n                设置检查规则\n                package.json中eslintConfig配置\n                \t\"eslintConfig\":{\n                    \t“extends”:\"aribnb-base\"\n            \t\t}\n                airbnb -> eslint-config-airbnb-base eslint-plugin-import eslint */\n                test:/\\.js$/,\n                execlide:/node_modules/,\n                loader:'eslint-loader',\n                options:{\n                    // 自动修复\n                    fix:true\n                }\n            }\n        ]\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html'\n        })\n    ],\n    mode:'development'\n}\n```\n\n## js兼容性处理\n\n```js\nconst { resolve } = require(\"path\");\n\nmodule.exports = {\n    entry:\"./src/index,js\",\n    output:{\n        filename:\"built.js\",\n        path:resolve(__dirname,'build')\n    },\n    module:{\n        rules:[\n        \t// js兼容性处理 babel-loader @babel/core \n            // 1. 基本的js兼容性处理--> @babel/preset-env 但这只能转换基本的语法\n            // 2. 全部js兼容性处理 --> @babel/polyfill 做全部的兼容性处理(Promise,Proxy,Reflect...) 通过在入口文件引入该依赖即可  全局引入，导致打包完后的文件体积太大\n            // 3. 按需加载 --->  core-js\n            {\n                test:/\\.js$/,\n                execlude:/node_modules/,\n                loader:'babel-loader',\n                options:{\n                    // 预设：指示babel做怎样的兼容性处理\n                    presets:[\n                        [\n                            ‘@babel/preset-env',\n                            {\n                            \tuseBuiltIns:'usage'\n                            \t// 指定core-js版本\n                            \tcorejs:{\n                            \t\tversion:3\n                           \t\t},\n                        \t\t// 指定兼容性到那个版本浏览器\n                        \t\ttargets:{\n                        \t\t\tchrome:'60',\n                        \t\t\tfirefox;'60',\n                        \t\t\tie:'9',\n                        \t\t\tsafari:'10',\n                        \t\t\tedge:'17'\n                        \t\t}\n                            }\n                        ]\n                    ]\n                }\n            }\n        ]\n    },\n    plugins:[\n        \n    ]\n}\n```\n\n## js代码压缩\n\n```js\n// 生产环境下自动压缩js代码  \n```\n\n## html代码压缩\n\n```\n在插件 html-webpack-plugin构造函数添加s属性对象\nminify:{\n\t// 移除空格\n\tcollapseWhitespace:true\n\t// 移除注释\n\tremoveComments:true\n}\n```\n\n## 总和\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = {\n    \n    entry: './src/js/index.js',\n    \n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, 'build')\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [...commonCssloader]\n            },\n            {\n                test: /\\.less$/,\n                use: [...commonCssloader, 'less-loader']\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                loader: 'babel-loader',\n                options: {\n                    presets: [\n                        '@babel/preset-env',\n                        {\n                            useBuiltIns: 'usage',\n                            corejs: { version: 3 },\n                            targets: {\n                                chrome: '60',\n                                firefox: '50'\n                            }\n                        }\n                    ]\n                }\n            },\n            {\n                test: /\\.(jpg|png|gif)$/,\n                loader: 'url-loader',\n                options: {\n                    limit: 8 * 1024,\n                    name: '[hash:10].[ext]',\n                    outputPath: 'imgs',\n                    esModule: false\n                }\n            },\n            {\n                test: /\\.html$/,\n                loader: 'html-loader'\n            },\n            {\n                execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                loader: 'file-loader',\n                options: {\n                    outputPath: 'media'\n                }\n            }\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n    \n    mode: 'production'\n\n}\n\n// browserslist:{\n//     \"development\":[\n//         \"last 1 chrome version\",\n//         \"last 1 firefox version\",\n//         \"last 1 safari version\"\n//     ],\n//     \"production\":[\n//         \">0.2%\",\n//         \"not dead\",\n//         \"not op_mini all\"\n//     ]\n// }\n\n// eslintConfig:{\n//     \"extends\":'aribnb-base'\n// }\n```\n\n","slug":"前端/Webpack/03 生产配置","published":1,"updated":"2023-05-12T23:28:10.995Z","layout":"post","link":"","_id":"clhws1t32002h2h17as2y9ezl","content":"<ol>\n<li>css提取</li>\n<li>代码压缩</li>\n<li>样式兼容</li>\n<li>……</li>\n</ol>\n<h2 id=\"提取CSS文件\"><a href=\"#提取CSS文件\" class=\"headerlink\" title=\"提取CSS文件\"></a>提取CSS文件</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // &#39;style-loader&#39;,\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    &#39;css-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            // 该插件会自动将css通过link标签引入\n            filename:&#39;css/built.css&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"CSS兼容性处理\"><a href=\"#CSS兼容性处理\" class=\"headerlink\" title=\"CSS兼容性处理\"></a>CSS兼容性处理</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\n\n// 设置node的环境变量\nprocess.env.NODE_ENV=&quot;development&quot;\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    MiniCssExtractPlugin.loader\n                    &#39;css-loader&#39;\n                    // css兼容性处理：postcss -&gt; postcss-loader,postcss-preset-env\n                    // 帮postcss找到package.json中browserlist里面的配置，通过配置加载相关css兼容性代码\n                    // 使用loader的默认配置和\n                    // &#39;postcss-loader&#39;\n                    // 修改loader配置\n                    &#123;\n                        loader:&#39;postcss-loader&#39;,\n                        options:&#123;\n                            ident:&#39;postcss&#39;,\n                            plugins:()=&gt;[\n                                // postcss的插件\n                                require(&#39;postcss-preset-env&#39;)()\n                            ]\n                        &#125;\n                    &#125;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            filename:&#39;css/built.css&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"json\">&#123;\n    &quot;browserslist&quot;:&#123;\n        // 开发环境相关配置\n        &quot;development&quot;:&#123;\n            &quot;last 1 chrome version&quot;,\n            &quot;last 1 firefox version&quot;\n            &quot;last 1 safari version&quot;\n        &#125;,\n        // 生产环境相关配置：默认\n        &quot;production&quot;:[\n            &quot;&gt;0.2%&quot;,\n            &quot;not dead&quot;,\n            &quot;not op_mini all&quot;\n        ]\n        // 修改运行模式得要设置node的环境变量：process.env.NODE_ENV=&quot;development&quot;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"压缩css\"><a href=\"#压缩css\" class=\"headerlink\" title=\"压缩css\"></a>压缩css</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\nconst OptimizeCssAssetsWebpackPlugins = require(&#39;optimize-css-assets-webpack-plugin&#39;)\t\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // &#39;style-loader&#39;,\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    &#39;css-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            filename:&#39;css/built.css&#39;\n        &#125;),\n        // 压缩css\n        new OptimizeCssAssetsWebpackPlugins()\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"js语法检查\"><a href=\"#js语法检查\" class=\"headerlink\" title=\"js语法检查\"></a>js语法检查</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\t\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                /*语法检查\n                注意：只需要检查自己写的代码，第三方依赖库的代码无需检查\n                设置检查规则\n                package.json中eslintConfig配置\n                    &quot;eslintConfig&quot;:&#123;\n                        “extends”:&quot;aribnb-base&quot;\n                    &#125;\n                airbnb -&gt; eslint-config-airbnb-base eslint-plugin-import eslint */\n                test:/\\.js$/,\n                execlide:/node_modules/,\n                loader:&#39;eslint-loader&#39;,\n                options:&#123;\n                    // 自动修复\n                    fix:true\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"js兼容性处理\"><a href=\"#js兼容性处理\" class=\"headerlink\" title=\"js兼容性处理\"></a>js兼容性处理</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;);\n\nmodule.exports = &#123;\n    entry:&quot;./src/index,js&quot;,\n    output:&#123;\n        filename:&quot;built.js&quot;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            // js兼容性处理 babel-loader @babel/core \n            // 1. 基本的js兼容性处理--&gt; @babel/preset-env 但这只能转换基本的语法\n            // 2. 全部js兼容性处理 --&gt; @babel/polyfill 做全部的兼容性处理(Promise,Proxy,Reflect...) 通过在入口文件引入该依赖即可  全局引入，导致打包完后的文件体积太大\n            // 3. 按需加载 ---&gt;  core-js\n            &#123;\n                test:/\\.js$/,\n                execlude:/node_modules/,\n                loader:&#39;babel-loader&#39;,\n                options:&#123;\n                    // 预设：指示babel做怎样的兼容性处理\n                    presets:[\n                        [\n                            ‘@babel/preset-env&#39;,\n                            &#123;\n                                useBuiltIns:&#39;usage&#39;\n                                // 指定core-js版本\n                                corejs:&#123;\n                                    version:3\n                                   &#125;,\n                                // 指定兼容性到那个版本浏览器\n                                targets:&#123;\n                                    chrome:&#39;60&#39;,\n                                    firefox;&#39;60&#39;,\n                                    ie:&#39;9&#39;,\n                                    safari:&#39;10&#39;,\n                                    edge:&#39;17&#39;\n                                &#125;\n                            &#125;\n                        ]\n                    ]\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        \n    ]\n&#125;\n</code></pre>\n<h2 id=\"js代码压缩\"><a href=\"#js代码压缩\" class=\"headerlink\" title=\"js代码压缩\"></a>js代码压缩</h2><pre><code class=\"js\">// 生产环境下自动压缩js代码  \n</code></pre>\n<h2 id=\"html代码压缩\"><a href=\"#html代码压缩\" class=\"headerlink\" title=\"html代码压缩\"></a>html代码压缩</h2><pre><code>在插件 html-webpack-plugin构造函数添加s属性对象\nminify:&#123;\n    // 移除空格\n    collapseWhitespace:true\n    // 移除注释\n    removeComments:true\n&#125;\n</code></pre>\n<h2 id=\"总和\"><a href=\"#总和\" class=\"headerlink\" title=\"总和\"></a>总和</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = &#123;\n    \n    entry: &#39;./src/js/index.js&#39;,\n    \n    output: &#123;\n        filename: &#39;js/built.js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.css$/,\n                use: [...commonCssloader]\n            &#125;,\n            &#123;\n                test: /\\.less$/,\n                use: [...commonCssloader, &#39;less-loader&#39;]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                loader: &#39;babel-loader&#39;,\n                options: &#123;\n                    presets: [\n                        &#39;@babel/preset-env&#39;,\n                        &#123;\n                            useBuiltIns: &#39;usage&#39;,\n                            corejs: &#123; version: 3 &#125;,\n                            targets: &#123;\n                                chrome: &#39;60&#39;,\n                                firefox: &#39;50&#39;\n                            &#125;\n                        &#125;\n                    ]\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.(jpg|png|gif)$/,\n                loader: &#39;url-loader&#39;,\n                options: &#123;\n                    limit: 8 * 1024,\n                    name: &#39;[hash:10].[ext]&#39;,\n                    outputPath: &#39;imgs&#39;,\n                    esModule: false\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.html$/,\n                loader: &#39;html-loader&#39;\n            &#125;,\n            &#123;\n                execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                loader: &#39;file-loader&#39;,\n                options: &#123;\n                    outputPath: &#39;media&#39;\n                &#125;\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n    \n    mode: &#39;production&#39;\n\n&#125;\n\n// browserslist:&#123;\n//     &quot;development&quot;:[\n//         &quot;last 1 chrome version&quot;,\n//         &quot;last 1 firefox version&quot;,\n//         &quot;last 1 safari version&quot;\n//     ],\n//     &quot;production&quot;:[\n//         &quot;&gt;0.2%&quot;,\n//         &quot;not dead&quot;,\n//         &quot;not op_mini all&quot;\n//     ]\n// &#125;\n\n// eslintConfig:&#123;\n//     &quot;extends&quot;:&#39;aribnb-base&#39;\n// &#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>css提取</li>\n<li>代码压缩</li>\n<li>样式兼容</li>\n<li>……</li>\n</ol>\n<h2 id=\"提取CSS文件\"><a href=\"#提取CSS文件\" class=\"headerlink\" title=\"提取CSS文件\"></a>提取CSS文件</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // &#39;style-loader&#39;,\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    &#39;css-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            // 该插件会自动将css通过link标签引入\n            filename:&#39;css/built.css&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"CSS兼容性处理\"><a href=\"#CSS兼容性处理\" class=\"headerlink\" title=\"CSS兼容性处理\"></a>CSS兼容性处理</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\n\n// 设置node的环境变量\nprocess.env.NODE_ENV=&quot;development&quot;\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    MiniCssExtractPlugin.loader\n                    &#39;css-loader&#39;\n                    // css兼容性处理：postcss -&gt; postcss-loader,postcss-preset-env\n                    // 帮postcss找到package.json中browserlist里面的配置，通过配置加载相关css兼容性代码\n                    // 使用loader的默认配置和\n                    // &#39;postcss-loader&#39;\n                    // 修改loader配置\n                    &#123;\n                        loader:&#39;postcss-loader&#39;,\n                        options:&#123;\n                            ident:&#39;postcss&#39;,\n                            plugins:()=&gt;[\n                                // postcss的插件\n                                require(&#39;postcss-preset-env&#39;)()\n                            ]\n                        &#125;\n                    &#125;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            filename:&#39;css/built.css&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"json\">&#123;\n    &quot;browserslist&quot;:&#123;\n        // 开发环境相关配置\n        &quot;development&quot;:&#123;\n            &quot;last 1 chrome version&quot;,\n            &quot;last 1 firefox version&quot;\n            &quot;last 1 safari version&quot;\n        &#125;,\n        // 生产环境相关配置：默认\n        &quot;production&quot;:[\n            &quot;&gt;0.2%&quot;,\n            &quot;not dead&quot;,\n            &quot;not op_mini all&quot;\n        ]\n        // 修改运行模式得要设置node的环境变量：process.env.NODE_ENV=&quot;development&quot;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"压缩css\"><a href=\"#压缩css\" class=\"headerlink\" title=\"压缩css\"></a>压缩css</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)\nconst OptimizeCssAssetsWebpackPlugins = require(&#39;optimize-css-assets-webpack-plugin&#39;)\t\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                test:/\\.css$/,\n                use:[\n                    // 创建style标签，将样式放入\n                    // &#39;style-loader&#39;,\n                    // 这个loader取代style-loader,提取js中的css成单独文件\n                    MiniCssExtractPlugin.loader\n                    // 将css整合到js文件\n                    &#39;css-loader&#39;\n                ]\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;),\n        new MiniCssExtractPlugin(&#123;\n            // 对输出的css文件进行重命名\n            filename:&#39;css/built.css&#39;\n        &#125;),\n        // 压缩css\n        new OptimizeCssAssetsWebpackPlugins()\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"js语法检查\"><a href=\"#js语法检查\" class=\"headerlink\" title=\"js语法检查\"></a>js语法检查</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\t\n\nmodule.exports = &#123;\n    entry:&quot;./src/index.js&quot;,\n    output:&#123;\n        filename:&#39;built.js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            &#123;\n                /*语法检查\n                注意：只需要检查自己写的代码，第三方依赖库的代码无需检查\n                设置检查规则\n                package.json中eslintConfig配置\n                    &quot;eslintConfig&quot;:&#123;\n                        “extends”:&quot;aribnb-base&quot;\n                    &#125;\n                airbnb -&gt; eslint-config-airbnb-base eslint-plugin-import eslint */\n                test:/\\.js$/,\n                execlide:/node_modules/,\n                loader:&#39;eslint-loader&#39;,\n                options:&#123;\n                    // 自动修复\n                    fix:true\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<h2 id=\"js兼容性处理\"><a href=\"#js兼容性处理\" class=\"headerlink\" title=\"js兼容性处理\"></a>js兼容性处理</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&quot;path&quot;);\n\nmodule.exports = &#123;\n    entry:&quot;./src/index,js&quot;,\n    output:&#123;\n        filename:&quot;built.js&quot;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    module:&#123;\n        rules:[\n            // js兼容性处理 babel-loader @babel/core \n            // 1. 基本的js兼容性处理--&gt; @babel/preset-env 但这只能转换基本的语法\n            // 2. 全部js兼容性处理 --&gt; @babel/polyfill 做全部的兼容性处理(Promise,Proxy,Reflect...) 通过在入口文件引入该依赖即可  全局引入，导致打包完后的文件体积太大\n            // 3. 按需加载 ---&gt;  core-js\n            &#123;\n                test:/\\.js$/,\n                execlude:/node_modules/,\n                loader:&#39;babel-loader&#39;,\n                options:&#123;\n                    // 预设：指示babel做怎样的兼容性处理\n                    presets:[\n                        [\n                            ‘@babel/preset-env&#39;,\n                            &#123;\n                                useBuiltIns:&#39;usage&#39;\n                                // 指定core-js版本\n                                corejs:&#123;\n                                    version:3\n                                   &#125;,\n                                // 指定兼容性到那个版本浏览器\n                                targets:&#123;\n                                    chrome:&#39;60&#39;,\n                                    firefox;&#39;60&#39;,\n                                    ie:&#39;9&#39;,\n                                    safari:&#39;10&#39;,\n                                    edge:&#39;17&#39;\n                                &#125;\n                            &#125;\n                        ]\n                    ]\n                &#125;\n            &#125;\n        ]\n    &#125;,\n    plugins:[\n        \n    ]\n&#125;\n</code></pre>\n<h2 id=\"js代码压缩\"><a href=\"#js代码压缩\" class=\"headerlink\" title=\"js代码压缩\"></a>js代码压缩</h2><pre><code class=\"js\">// 生产环境下自动压缩js代码  \n</code></pre>\n<h2 id=\"html代码压缩\"><a href=\"#html代码压缩\" class=\"headerlink\" title=\"html代码压缩\"></a>html代码压缩</h2><pre><code>在插件 html-webpack-plugin构造函数添加s属性对象\nminify:&#123;\n    // 移除空格\n    collapseWhitespace:true\n    // 移除注释\n    removeComments:true\n&#125;\n</code></pre>\n<h2 id=\"总和\"><a href=\"#总和\" class=\"headerlink\" title=\"总和\"></a>总和</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = &#123;\n    \n    entry: &#39;./src/js/index.js&#39;,\n    \n    output: &#123;\n        filename: &#39;js/built.js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n    module: &#123;\n        rules: [\n            &#123;\n                test: /\\.css$/,\n                use: [...commonCssloader]\n            &#125;,\n            &#123;\n                test: /\\.less$/,\n                use: [...commonCssloader, &#39;less-loader&#39;]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                loader: &#39;babel-loader&#39;,\n                options: &#123;\n                    presets: [\n                        &#39;@babel/preset-env&#39;,\n                        &#123;\n                            useBuiltIns: &#39;usage&#39;,\n                            corejs: &#123; version: 3 &#125;,\n                            targets: &#123;\n                                chrome: &#39;60&#39;,\n                                firefox: &#39;50&#39;\n                            &#125;\n                        &#125;\n                    ]\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.(jpg|png|gif)$/,\n                loader: &#39;url-loader&#39;,\n                options: &#123;\n                    limit: 8 * 1024,\n                    name: &#39;[hash:10].[ext]&#39;,\n                    outputPath: &#39;imgs&#39;,\n                    esModule: false\n                &#125;\n            &#125;,\n            &#123;\n                test: /\\.html$/,\n                loader: &#39;html-loader&#39;\n            &#125;,\n            &#123;\n                execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                loader: &#39;file-loader&#39;,\n                options: &#123;\n                    outputPath: &#39;media&#39;\n                &#125;\n            &#125;\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n    \n    mode: &#39;production&#39;\n\n&#125;\n\n// browserslist:&#123;\n//     &quot;development&quot;:[\n//         &quot;last 1 chrome version&quot;,\n//         &quot;last 1 firefox version&quot;,\n//         &quot;last 1 safari version&quot;\n//     ],\n//     &quot;production&quot;:[\n//         &quot;&gt;0.2%&quot;,\n//         &quot;not dead&quot;,\n//         &quot;not op_mini all&quot;\n//     ]\n// &#125;\n\n// eslintConfig:&#123;\n//     &quot;extends&quot;:&#39;aribnb-base&#39;\n// &#125;\n</code></pre>\n"},{"title":"Webpack 优化配置","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2019-12-29T16:00:00.000Z","comments":0,"description":"Webpack 优化配置","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/webpack_4.jpg"],"_content":"\n#### 1. 开发环境性能优化\n\n1. 优化打包构建速度\n2. 优化代码调试\n\n#### 2. 生产环境性能优化\n\n1. 优化打包构建速度\n2. 优化代码运行时的性能\n\n## 开发环境 优化打包构建速度\n\n#### HMR\n\n之前的问题：代码修改，全局刷新\n\n**HMR**: hot module replacement 热模块替换 / 模块热替换\n\n一个模块发生变化，只会重新打包这一个模块（而不是重新打包全部模块）\n\n只需将devServer的hot属性改为true,即可开启HMR\n\n样式文件：可以使用HMR功能：因为style-loader内部已经实现：\n\njs文件：默认不能使用HMR功能 但我们需要HMR\n\nhtml文件：默认不能使用HMR功能。html无法热更新（将html文件引入到入口配置），其实html无需HMR\n\nHMR针对的是那些非入口的js文件\n\n#### source-map\n\n[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map\n\n\n一种技术，提供源代码到构建后代码的映射\n\n\n如果构建后后代码出错了，通过映射可以追踪源代码错误\n\n\n我们只需在webpack配置中添加属性devtool:'source-map'\n\n内联和外部的区别\n\n1. 外部生成了文件，内联没有\n2. 内联构建速度够快\n\nsource-map\n\n\n外部\n错误代码准确原因和源代码的错误位置\n\n\ninline-source-map \n\n\n内联\n错误代码准确原因和源代码的错误位置\n\n\nhidden-source-map\t\n\n\n 外部\n 错误代码准确原因但不提供源代码的错误位置（即不能追踪到源代码的错误，只追踪到构建后代码的位置）\n\n\neval-source-map\t\t\t（每一个引入的模块之后都有源代码地址的，并在eval中）\n\n\n内联\n错误代码准确原因和源代码的错误位置\n\n\nnosources-source-map\t\n\n\n外部\n错误代码准确原因,但是没有任何源代码错误的相关提示\n\n\ncheap-source-map\t\t外部\n\n\n外部\n错误代码准确原因和源代码的错误位置(源代码错误代码只能精确到行)\n\n\ncheap-module-source-map\t\n\n\n外部\n错误代码准确原因和源代码的错误位置\nmodule会将loader的source-map加入\n\n\n考虑环境的使用\n\n1. 开发环境：打包速度块，调试方便\n\n速度块\n    eval>inline>cheap>......\n    eval-cheap-source-map 打包速度最快\n    eval-source-map\n调试更友好\n    source-map\n    cheap-module-source-map\n    cheap-source-map\n--> eval-source-map/eval-cheap-source-map是一个比较好的方案（具体情况具体看）\n\n\n2. 生产环境：源代码隐藏是否\n\n\nnosources-source-map 隐藏全部代码\nhidden-source-map\t只隐藏源代码，会提示构建后代码错误信息\n内联会让代码体积变得非常大，因此内联的所有方案都要排除\n-->  source-map/cheap-module-source-map\n\n\n## 优化配置方案\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = {\n\n    entry: './src/js/index.js',\n\n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, 'build')\n    },\n    module: {\n        rules: [\n            {\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [{\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [...commonCssloader, 'less-loader']\n                    },\n                    {\n                        // 在package.json中eslintConfig --> aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: 'babel-loader',\n                        options: {\n                            presets: [\n                                '@babel/preset-env',\n                                {\n                                    useBuiltIns: 'usage',\n                                    corejs: {\n                                        version: 3\n                                    },\n                                    targets: {\n                                        chrome: '60',\n                                        firefox: '50'\n                                    }\n                                }\n                            ]\n                        }\n                    },\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: 'url-loader',\n                        options: {\n                            limit: 8 * 1024,\n                            name: '[hash:10].[ext]',\n                            outputPath: 'imgs',\n                            esModule: false\n                        }\n                    },\n                    {\n                        test: /\\.html$/,\n                        loader: 'html-loader'\n                    },\n                    {\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'media'\n                        }\n                    }\n                ]\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n\n    mode: 'production'\n\n}\n\n// browserslist:{\n//     \"development\":[\n//         \"last 1 chrome version\",\n//         \"last 1 firefox version\",\n//         \"last 1 safari version\"\n//     ],\n//     \"production\":[\n//         \">0.2%\",\n//         \"not dead\",\n//         \"not op_mini all\"\n//     ]\n// }\n\n// eslintConfig:{\n//     \"extends\":'aribnb-base'\n// }\n```\n\n\n\n## 缓存\n\n1. babel缓存\n   第二次打包速度更快\n2. 文件资源缓存\n   让代码上线运行缓存更好使用，页面访问速度更快\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n * \n * babel缓存\n * 文件资源缓存：给文件名添加一个哈希值\n * 问题：因为js和css同时使用一个哈希值\n * 如果重新打包，会导致所有缓存失效，在这里指修改一个js\n * hash改为使用chunkhash:如果打包来源于一个chunk，则chunkhash相同\n * 问题是js和css来源于同一个模块（因为css要在js引入才能被打包）\n * contenthash:根据文件的内容生成hash值，不同文件hash值不同\n */\nmodule.exports = {\n\n    entry: './src/js/index.js',\n\n    output: {\n        filename: 'js/built_[contenthash:10].js',\n        path: resolve(__dirname, 'build')\n    },\n\n    module: {\n        rules: [\n            {\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [\n                    {\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [...commonCssloader, 'less-loader']\n                    },\n                    {\n                        // 在package.json中eslintConfig --> aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: 'babel-loader',\n                        options: {\n                            presets: [\n                                '@babel/preset-env',\n                                {\n                                    useBuiltIns: 'usage',\n                                    corejs: {\n                                        version: 3\n                                    },\n                                    targets: {\n                                        chrome: '60',\n                                        firefox: '50'\n                                    }\n                                }\n                            ],\n                            // 开启babel缓存\n                            // 第二次构建时，会读取之前的缓存\n                            cacheDirectory:true\n                        }\n                    },\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: 'url-loader',\n                        options: {\n                            limit: 8 * 1024,\n                            name: '[hash:10].[ext]',\n                            outputPath: 'imgs',\n                            esModule: false\n                        }\n                    },\n                    {\n                        test: /\\.html$/,\n                        loader: 'html-loader'\n                    },\n                    {\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'media'\n                        }\n                    }\n                ]\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.[contenthash:10].css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n\n    mode: 'production'\n\n}\n```\n\n\n\n## tree shaking\n\n为了去除在代码中没有使用到的代码\n\n```\n使用前提：\n1. 必须使用ES6模块化\n2. 模式为‘production’\n作用\n减少我们的打包体积\n\n在package.json中设置sideEffects:false 所有代码都没有作用(都可以使用tree shaking)\n问题：可能会把css/@babel/polyfill (副作用)进行删除\n\"sideEffect\":['*.css','*.less'] 这些类型的文件就不会进行tree shaking\n```\n\n\n\n## 代码分割\n\n文件分割（分割的代码是js代码），按需加载\n\n方法\n\n1. 多入口文件\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:{\n        main:\"./src/js/main.js\",\n        test:'./src/js/test.js'\n    },\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    mode:'development'\n}\n```\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:{\n        main:\"./src/js/main.js\",\n        test:'./src/js/test.js'\n    },\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:{\n      splitChunks:{\n          chunks:'all'\n      }  \n    },\n    mode:'development'\n}\n```\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:\"./src/js/main.js\",\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:{\n      splitChunks:{\n          chunks:'all'\n      }  \n    },\n    mode:'development'\n}\n```\n\n```js\n// 通过js代码使得当前模块单独打包成一个chunk\n// import动态导入语法：能将文件单独打包\nimport(/* webpackChunkName:'test' */'./test').then((res)=>{\n    console.log(res);\n}).catch(()=>{\n    console.log(\"文件加载失败\")\n})\n```\n\n## 懒加载\n\n等触发某些条件才会加载\n\n使用import的动态加载语法\n\n```js\n// 懒加载 当文件需要时才加载\n// 预加载 prefetch 会提前加载js之前 等其他资源加载完成，等浏览器空闲在加载（慎用，兼容性问题）\n// 正常加载可以认为是并行加载(同一时间加载多个文件)\nimport(/*webpackNameChunk:'test',*/,'./test').then(({f})=>{f()});\n```\n\n## PWA(渐进式网络开发应用程序，离线可访问)\n\nworkbox --> workbox-webpack-plugin\n\n离线状态下也可以使得一部分功能能使用\n\n```js\nplugins:[\n    new WorkboxWebpackPlugin.GenerateSW({\n        // 1. 帮助serviceworker快速启动\n        // 2. 删除旧的serviceworker\n        \n        // 生成一个serviceworker\n        clientsClaim:true\n        skipWaiting:true\n    })\n]\n```\n\n```js\n// 注册servceworker\n// 处理兼容性问题\n// 测试需要在服务端运行 serve -s build 启动服务端\n// 可在浏览器的application中查看\nif('serviceworker' in navigator){\n    window.addEventListener('load',()=>{\n        navigator.注册servceworker.register('./serviceworker').\n        then(()=>{\n             console.log(\"构建成功\");\n        }).catch(()=>{\n            console.log(\"构建失败\");\n        })\n    })\n}\n```\n\n## 多进程打包\n\n包 thread-loader\n\n在babel打包中引入loader\n\n优点\n\n进行开启需要时间，启动时间大概为600ms，进程通信也有开销\n\n只有工作消耗时间比较长，才需要多进程打包\n\n因为在我们开发中，js打包所需要的时间一般是最多的，所有一般是在js的相关loader开启多进程\n\n## externals\n\n就是我们使用cdn引入资源时，不要让Webpack打包cdn资源，直接cdn引入即可\n\n```js\nmodule.exports = {\n    ....\n    \n    \n    externals:{\n    \t// 忽略的库名 -- npm 包名\n    \t// 拒绝jQuery被打包，主要要自己在html中cdn引入\n    \tjquery:'jQuery'\n\t}\n}\n```\n\n## dll\n\n动态打包\n\n可以将node_module分块打包\n\n在webpack.dll.js中填写\n\n```js\nconst { resolve } = require('path');\nconst webpack = require('webpack')\n\n/*\n\t使用dll技术，对某些库(第三方库：jquery,react,vue)进行单独打包\n\t当我们运行webpack时，默认查找webpack.config.js 配置文件\n\t --> webpack --config 配置文件\n\t就是单独打包某些库\n*/\nmodule.exports = {\n    entry:{\n        // 最终打包生成的[name] --> jquery\n        //['jquery'] --> 要打包的库是jquery\n        juery:['jquery']\n    },\n    output:{\n        filename:'[name].js',\n        path:resolve(__dirname,'dll'),\n        library:'[name] // 打包的库里向外暴露的内容名称将什么'\n    },\n    plugins:[\n        // 打包生成一个manifest.json --> 提供和jquery映射\n        new webpack.DllPlugin({\n            name:'[name]_[hash]',// 映射库的暴露的内容名称,\n            path:resolve(__dirname,'dll/manifest.json')\n        })\n    ],\n    mode:'production'\n}\n```\n\n```js\n// webpack.config.s\n// 需要安装 add-asset-html-webpack-plugin 该插件告诉webpack\nmodule.exports = {\n    ..\n    \n    plugins:[\n    \t// 告诉webpack哪些库不需要打包，同时使用的名称也需要该\n    \tnew webpack.DllReferencePlugin({\n    \t\tmanifest:resolve(__dirname,'dll/manifest.json')\n\t\t}),\n        // 将某个文件打包输出去，并在htmlz自动引入该资源\n        new AddAssetHtmlWebpackPlugin({\n            filepath:resolve(__dirname,'dll/jquery.js'))\n        })\n    ]\n}\n```\n\n\n\n## 优化总结\n\n#### 开发环境优化\n\n优化打包构建速度\n\n1. HMR\n\n优化代码调试\n\n1. source-map\n\n#### 生产环境性能优化\n\n优化打包构建速度\n\n1. oneOf\n2. BABEL缓存\n3. 多进程打包\n4. externals\n5. dll \n\n优化代码运行性能\n\n1. 文件缓存(hash,chunkhash,contenthash)\n2. tree shaking  打包时删除无用代码，从而使得打包后的体积更小\n3. 代码分割 \n4. 懒加载/预加载\n5. pwa","source":"_posts/前端/Webpack/04 优化配置.md","raw":"---\ntitle: Webpack 优化配置\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2019-12-30\ncomments: false\ndescription: Webpack 优化配置\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/webpack_4.jpg\n---\n\n#### 1. 开发环境性能优化\n\n1. 优化打包构建速度\n2. 优化代码调试\n\n#### 2. 生产环境性能优化\n\n1. 优化打包构建速度\n2. 优化代码运行时的性能\n\n## 开发环境 优化打包构建速度\n\n#### HMR\n\n之前的问题：代码修改，全局刷新\n\n**HMR**: hot module replacement 热模块替换 / 模块热替换\n\n一个模块发生变化，只会重新打包这一个模块（而不是重新打包全部模块）\n\n只需将devServer的hot属性改为true,即可开启HMR\n\n样式文件：可以使用HMR功能：因为style-loader内部已经实现：\n\njs文件：默认不能使用HMR功能 但我们需要HMR\n\nhtml文件：默认不能使用HMR功能。html无法热更新（将html文件引入到入口配置），其实html无需HMR\n\nHMR针对的是那些非入口的js文件\n\n#### source-map\n\n[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map\n\n\n一种技术，提供源代码到构建后代码的映射\n\n\n如果构建后后代码出错了，通过映射可以追踪源代码错误\n\n\n我们只需在webpack配置中添加属性devtool:'source-map'\n\n内联和外部的区别\n\n1. 外部生成了文件，内联没有\n2. 内联构建速度够快\n\nsource-map\n\n\n外部\n错误代码准确原因和源代码的错误位置\n\n\ninline-source-map \n\n\n内联\n错误代码准确原因和源代码的错误位置\n\n\nhidden-source-map\t\n\n\n 外部\n 错误代码准确原因但不提供源代码的错误位置（即不能追踪到源代码的错误，只追踪到构建后代码的位置）\n\n\neval-source-map\t\t\t（每一个引入的模块之后都有源代码地址的，并在eval中）\n\n\n内联\n错误代码准确原因和源代码的错误位置\n\n\nnosources-source-map\t\n\n\n外部\n错误代码准确原因,但是没有任何源代码错误的相关提示\n\n\ncheap-source-map\t\t外部\n\n\n外部\n错误代码准确原因和源代码的错误位置(源代码错误代码只能精确到行)\n\n\ncheap-module-source-map\t\n\n\n外部\n错误代码准确原因和源代码的错误位置\nmodule会将loader的source-map加入\n\n\n考虑环境的使用\n\n1. 开发环境：打包速度块，调试方便\n\n速度块\n    eval>inline>cheap>......\n    eval-cheap-source-map 打包速度最快\n    eval-source-map\n调试更友好\n    source-map\n    cheap-module-source-map\n    cheap-source-map\n--> eval-source-map/eval-cheap-source-map是一个比较好的方案（具体情况具体看）\n\n\n2. 生产环境：源代码隐藏是否\n\n\nnosources-source-map 隐藏全部代码\nhidden-source-map\t只隐藏源代码，会提示构建后代码错误信息\n内联会让代码体积变得非常大，因此内联的所有方案都要排除\n-->  source-map/cheap-module-source-map\n\n\n## 优化配置方案\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = {\n\n    entry: './src/js/index.js',\n\n    output: {\n        filename: 'js/built.js',\n        path: resolve(__dirname, 'build')\n    },\n    module: {\n        rules: [\n            {\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [{\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [...commonCssloader, 'less-loader']\n                    },\n                    {\n                        // 在package.json中eslintConfig --> aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: 'babel-loader',\n                        options: {\n                            presets: [\n                                '@babel/preset-env',\n                                {\n                                    useBuiltIns: 'usage',\n                                    corejs: {\n                                        version: 3\n                                    },\n                                    targets: {\n                                        chrome: '60',\n                                        firefox: '50'\n                                    }\n                                }\n                            ]\n                        }\n                    },\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: 'url-loader',\n                        options: {\n                            limit: 8 * 1024,\n                            name: '[hash:10].[ext]',\n                            outputPath: 'imgs',\n                            esModule: false\n                        }\n                    },\n                    {\n                        test: /\\.html$/,\n                        loader: 'html-loader'\n                    },\n                    {\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'media'\n                        }\n                    }\n                ]\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n\n    mode: 'production'\n\n}\n\n// browserslist:{\n//     \"development\":[\n//         \"last 1 chrome version\",\n//         \"last 1 firefox version\",\n//         \"last 1 safari version\"\n//     ],\n//     \"production\":[\n//         \">0.2%\",\n//         \"not dead\",\n//         \"not op_mini all\"\n//     ]\n// }\n\n// eslintConfig:{\n//     \"extends\":'aribnb-base'\n// }\n```\n\n\n\n## 缓存\n\n1. babel缓存\n   第二次打包速度更快\n2. 文件资源缓存\n   让代码上线运行缓存更好使用，页面访问速度更快\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = 'development'\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    'css-loader',\n    {\n        // 还需要browserslist定义\n        loader: 'postcss-loader',\n        options: {\n            ident: 'postcss',\n            plugins: () => {\n                require(\"postcss-preset-env\")()\n            }\n        }\n    }\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n * \n * babel缓存\n * 文件资源缓存：给文件名添加一个哈希值\n * 问题：因为js和css同时使用一个哈希值\n * 如果重新打包，会导致所有缓存失效，在这里指修改一个js\n * hash改为使用chunkhash:如果打包来源于一个chunk，则chunkhash相同\n * 问题是js和css来源于同一个模块（因为css要在js引入才能被打包）\n * contenthash:根据文件的内容生成hash值，不同文件hash值不同\n */\nmodule.exports = {\n\n    entry: './src/js/index.js',\n\n    output: {\n        filename: 'js/built_[contenthash:10].js',\n        path: resolve(__dirname, 'build')\n    },\n\n    module: {\n        rules: [\n            {\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [\n                    {\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    },\n                    {\n                        test: /\\.less$/,\n                        use: [...commonCssloader, 'less-loader']\n                    },\n                    {\n                        // 在package.json中eslintConfig --> aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: 'babel-loader',\n                        options: {\n                            presets: [\n                                '@babel/preset-env',\n                                {\n                                    useBuiltIns: 'usage',\n                                    corejs: {\n                                        version: 3\n                                    },\n                                    targets: {\n                                        chrome: '60',\n                                        firefox: '50'\n                                    }\n                                }\n                            ],\n                            // 开启babel缓存\n                            // 第二次构建时，会读取之前的缓存\n                            cacheDirectory:true\n                        }\n                    },\n                    {\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: 'url-loader',\n                        options: {\n                            limit: 8 * 1024,\n                            name: '[hash:10].[ext]',\n                            outputPath: 'imgs',\n                            esModule: false\n                        }\n                    },\n                    {\n                        test: /\\.html$/,\n                        loader: 'html-loader'\n                    },\n                    {\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'media'\n                        }\n                    }\n                ]\n            },\n            {\n                // 在package.json中eslintConfig --> aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: 'pre',\n                loader: 'eslint-loader',\n                options: {\n                    fix: true\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: 'css/built.[contenthash:10].css'\n        }),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './src/index.html',\n            minify: {\n                collapseWhitespace: true,\n                removeComments: true\n            }\n        })\n    ],\n\n    mode: 'production'\n\n}\n```\n\n\n\n## tree shaking\n\n为了去除在代码中没有使用到的代码\n\n```\n使用前提：\n1. 必须使用ES6模块化\n2. 模式为‘production’\n作用\n减少我们的打包体积\n\n在package.json中设置sideEffects:false 所有代码都没有作用(都可以使用tree shaking)\n问题：可能会把css/@babel/polyfill (副作用)进行删除\n\"sideEffect\":['*.css','*.less'] 这些类型的文件就不会进行tree shaking\n```\n\n\n\n## 代码分割\n\n文件分割（分割的代码是js代码），按需加载\n\n方法\n\n1. 多入口文件\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:{\n        main:\"./src/js/main.js\",\n        test:'./src/js/test.js'\n    },\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    mode:'development'\n}\n```\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:{\n        main:\"./src/js/main.js\",\n        test:'./src/js/test.js'\n    },\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:{\n      splitChunks:{\n          chunks:'all'\n      }  \n    },\n    mode:'development'\n}\n```\n\n```js\nconst  { resolve } = require(\"path\") \nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:\"./src/js/main.js\",\n    output:{\n        filename:'js/[name].[contenthash:10].js',\n        path:resolve(__dirname,'build')\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template:'./src/index.html',\n            minify:{\n                collapseWhitespace:true,\n                removeComment:true\n            }\n        })\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:{\n      splitChunks:{\n          chunks:'all'\n      }  \n    },\n    mode:'development'\n}\n```\n\n```js\n// 通过js代码使得当前模块单独打包成一个chunk\n// import动态导入语法：能将文件单独打包\nimport(/* webpackChunkName:'test' */'./test').then((res)=>{\n    console.log(res);\n}).catch(()=>{\n    console.log(\"文件加载失败\")\n})\n```\n\n## 懒加载\n\n等触发某些条件才会加载\n\n使用import的动态加载语法\n\n```js\n// 懒加载 当文件需要时才加载\n// 预加载 prefetch 会提前加载js之前 等其他资源加载完成，等浏览器空闲在加载（慎用，兼容性问题）\n// 正常加载可以认为是并行加载(同一时间加载多个文件)\nimport(/*webpackNameChunk:'test',*/,'./test').then(({f})=>{f()});\n```\n\n## PWA(渐进式网络开发应用程序，离线可访问)\n\nworkbox --> workbox-webpack-plugin\n\n离线状态下也可以使得一部分功能能使用\n\n```js\nplugins:[\n    new WorkboxWebpackPlugin.GenerateSW({\n        // 1. 帮助serviceworker快速启动\n        // 2. 删除旧的serviceworker\n        \n        // 生成一个serviceworker\n        clientsClaim:true\n        skipWaiting:true\n    })\n]\n```\n\n```js\n// 注册servceworker\n// 处理兼容性问题\n// 测试需要在服务端运行 serve -s build 启动服务端\n// 可在浏览器的application中查看\nif('serviceworker' in navigator){\n    window.addEventListener('load',()=>{\n        navigator.注册servceworker.register('./serviceworker').\n        then(()=>{\n             console.log(\"构建成功\");\n        }).catch(()=>{\n            console.log(\"构建失败\");\n        })\n    })\n}\n```\n\n## 多进程打包\n\n包 thread-loader\n\n在babel打包中引入loader\n\n优点\n\n进行开启需要时间，启动时间大概为600ms，进程通信也有开销\n\n只有工作消耗时间比较长，才需要多进程打包\n\n因为在我们开发中，js打包所需要的时间一般是最多的，所有一般是在js的相关loader开启多进程\n\n## externals\n\n就是我们使用cdn引入资源时，不要让Webpack打包cdn资源，直接cdn引入即可\n\n```js\nmodule.exports = {\n    ....\n    \n    \n    externals:{\n    \t// 忽略的库名 -- npm 包名\n    \t// 拒绝jQuery被打包，主要要自己在html中cdn引入\n    \tjquery:'jQuery'\n\t}\n}\n```\n\n## dll\n\n动态打包\n\n可以将node_module分块打包\n\n在webpack.dll.js中填写\n\n```js\nconst { resolve } = require('path');\nconst webpack = require('webpack')\n\n/*\n\t使用dll技术，对某些库(第三方库：jquery,react,vue)进行单独打包\n\t当我们运行webpack时，默认查找webpack.config.js 配置文件\n\t --> webpack --config 配置文件\n\t就是单独打包某些库\n*/\nmodule.exports = {\n    entry:{\n        // 最终打包生成的[name] --> jquery\n        //['jquery'] --> 要打包的库是jquery\n        juery:['jquery']\n    },\n    output:{\n        filename:'[name].js',\n        path:resolve(__dirname,'dll'),\n        library:'[name] // 打包的库里向外暴露的内容名称将什么'\n    },\n    plugins:[\n        // 打包生成一个manifest.json --> 提供和jquery映射\n        new webpack.DllPlugin({\n            name:'[name]_[hash]',// 映射库的暴露的内容名称,\n            path:resolve(__dirname,'dll/manifest.json')\n        })\n    ],\n    mode:'production'\n}\n```\n\n```js\n// webpack.config.s\n// 需要安装 add-asset-html-webpack-plugin 该插件告诉webpack\nmodule.exports = {\n    ..\n    \n    plugins:[\n    \t// 告诉webpack哪些库不需要打包，同时使用的名称也需要该\n    \tnew webpack.DllReferencePlugin({\n    \t\tmanifest:resolve(__dirname,'dll/manifest.json')\n\t\t}),\n        // 将某个文件打包输出去，并在htmlz自动引入该资源\n        new AddAssetHtmlWebpackPlugin({\n            filepath:resolve(__dirname,'dll/jquery.js'))\n        })\n    ]\n}\n```\n\n\n\n## 优化总结\n\n#### 开发环境优化\n\n优化打包构建速度\n\n1. HMR\n\n优化代码调试\n\n1. source-map\n\n#### 生产环境性能优化\n\n优化打包构建速度\n\n1. oneOf\n2. BABEL缓存\n3. 多进程打包\n4. externals\n5. dll \n\n优化代码运行性能\n\n1. 文件缓存(hash,chunkhash,contenthash)\n2. tree shaking  打包时删除无用代码，从而使得打包后的体积更小\n3. 代码分割 \n4. 懒加载/预加载\n5. pwa","slug":"前端/Webpack/04 优化配置","published":1,"updated":"2023-05-12T23:28:10.995Z","layout":"post","link":"","_id":"clhws1t32002k2h17fhk684yq","content":"<h4 id=\"1-开发环境性能优化\"><a href=\"#1-开发环境性能优化\" class=\"headerlink\" title=\"1. 开发环境性能优化\"></a>1. 开发环境性能优化</h4><ol>\n<li>优化打包构建速度</li>\n<li>优化代码调试</li>\n</ol>\n<h4 id=\"2-生产环境性能优化\"><a href=\"#2-生产环境性能优化\" class=\"headerlink\" title=\"2. 生产环境性能优化\"></a>2. 生产环境性能优化</h4><ol>\n<li>优化打包构建速度</li>\n<li>优化代码运行时的性能</li>\n</ol>\n<h2 id=\"开发环境-优化打包构建速度\"><a href=\"#开发环境-优化打包构建速度\" class=\"headerlink\" title=\"开发环境 优化打包构建速度\"></a>开发环境 优化打包构建速度</h2><h4 id=\"HMR\"><a href=\"#HMR\" class=\"headerlink\" title=\"HMR\"></a>HMR</h4><p>之前的问题：代码修改，全局刷新</p>\n<p><strong>HMR</strong>: hot module replacement 热模块替换 &#x2F; 模块热替换</p>\n<p>一个模块发生变化，只会重新打包这一个模块（而不是重新打包全部模块）</p>\n<p>只需将devServer的hot属性改为true,即可开启HMR</p>\n<p>样式文件：可以使用HMR功能：因为style-loader内部已经实现：</p>\n<p>js文件：默认不能使用HMR功能 但我们需要HMR</p>\n<p>html文件：默认不能使用HMR功能。html无法热更新（将html文件引入到入口配置），其实html无需HMR</p>\n<p>HMR针对的是那些非入口的js文件</p>\n<h4 id=\"source-map\"><a href=\"#source-map\" class=\"headerlink\" title=\"source-map\"></a>source-map</h4><p>[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map</p>\n<p>一种技术，提供源代码到构建后代码的映射</p>\n<p>如果构建后后代码出错了，通过映射可以追踪源代码错误</p>\n<p>我们只需在webpack配置中添加属性devtool:’source-map’</p>\n<p>内联和外部的区别</p>\n<ol>\n<li>外部生成了文件，内联没有</li>\n<li>内联构建速度够快</li>\n</ol>\n<p>source-map</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置</p>\n<p>inline-source-map </p>\n<p>内联<br>错误代码准确原因和源代码的错误位置</p>\n<p>hidden-source-map\t</p>\n<p> 外部<br> 错误代码准确原因但不提供源代码的错误位置（即不能追踪到源代码的错误，只追踪到构建后代码的位置）</p>\n<p>eval-source-map\t\t\t（每一个引入的模块之后都有源代码地址的，并在eval中）</p>\n<p>内联<br>错误代码准确原因和源代码的错误位置</p>\n<p>nosources-source-map\t</p>\n<p>外部<br>错误代码准确原因,但是没有任何源代码错误的相关提示</p>\n<p>cheap-source-map\t\t外部</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置(源代码错误代码只能精确到行)</p>\n<p>cheap-module-source-map\t</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置<br>module会将loader的source-map加入</p>\n<p>考虑环境的使用</p>\n<ol>\n<li>开发环境：打包速度块，调试方便</li>\n</ol>\n<p>速度块<br>    eval&gt;inline&gt;cheap&gt;……<br>    eval-cheap-source-map 打包速度最快<br>    eval-source-map<br>调试更友好<br>    source-map<br>    cheap-module-source-map<br>    cheap-source-map<br>–&gt; eval-source-map&#x2F;eval-cheap-source-map是一个比较好的方案（具体情况具体看）</p>\n<ol start=\"2\">\n<li>生产环境：源代码隐藏是否</li>\n</ol>\n<p>nosources-source-map 隐藏全部代码<br>hidden-source-map\t只隐藏源代码，会提示构建后代码错误信息<br>内联会让代码体积变得非常大，因此内联的所有方案都要排除<br>–&gt;  source-map&#x2F;cheap-module-source-map</p>\n<h2 id=\"优化配置方案\"><a href=\"#优化配置方案\" class=\"headerlink\" title=\"优化配置方案\"></a>优化配置方案</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = &#123;\n\n    entry: &#39;./src/js/index.js&#39;,\n\n    output: &#123;\n        filename: &#39;js/built.js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n    module: &#123;\n        rules: [\n            &#123;\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [&#123;\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    &#125;,\n                    &#123;\n                        test: /\\.less$/,\n                        use: [...commonCssloader, &#39;less-loader&#39;]\n                    &#125;,\n                    &#123;\n                        // 在package.json中eslintConfig --&gt; aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: &#39;babel-loader&#39;,\n                        options: &#123;\n                            presets: [\n                                &#39;@babel/preset-env&#39;,\n                                &#123;\n                                    useBuiltIns: &#39;usage&#39;,\n                                    corejs: &#123;\n                                        version: 3\n                                    &#125;,\n                                    targets: &#123;\n                                        chrome: &#39;60&#39;,\n                                        firefox: &#39;50&#39;\n                                    &#125;\n                                &#125;\n                            ]\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 8 * 1024,\n                            name: &#39;[hash:10].[ext]&#39;,\n                            outputPath: &#39;imgs&#39;,\n                            esModule: false\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.html$/,\n                        loader: &#39;html-loader&#39;\n                    &#125;,\n                    &#123;\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: &#39;file-loader&#39;,\n                        options: &#123;\n                            outputPath: &#39;media&#39;\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n\n    mode: &#39;production&#39;\n\n&#125;\n\n// browserslist:&#123;\n//     &quot;development&quot;:[\n//         &quot;last 1 chrome version&quot;,\n//         &quot;last 1 firefox version&quot;,\n//         &quot;last 1 safari version&quot;\n//     ],\n//     &quot;production&quot;:[\n//         &quot;&gt;0.2%&quot;,\n//         &quot;not dead&quot;,\n//         &quot;not op_mini all&quot;\n//     ]\n// &#125;\n\n// eslintConfig:&#123;\n//     &quot;extends&quot;:&#39;aribnb-base&#39;\n// &#125;\n</code></pre>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ol>\n<li>babel缓存<br>第二次打包速度更快</li>\n<li>文件资源缓存<br>让代码上线运行缓存更好使用，页面访问速度更快</li>\n</ol>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n * \n * babel缓存\n * 文件资源缓存：给文件名添加一个哈希值\n * 问题：因为js和css同时使用一个哈希值\n * 如果重新打包，会导致所有缓存失效，在这里指修改一个js\n * hash改为使用chunkhash:如果打包来源于一个chunk，则chunkhash相同\n * 问题是js和css来源于同一个模块（因为css要在js引入才能被打包）\n * contenthash:根据文件的内容生成hash值，不同文件hash值不同\n */\nmodule.exports = &#123;\n\n    entry: &#39;./src/js/index.js&#39;,\n\n    output: &#123;\n        filename: &#39;js/built_[contenthash:10].js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n\n    module: &#123;\n        rules: [\n            &#123;\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [\n                    &#123;\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    &#125;,\n                    &#123;\n                        test: /\\.less$/,\n                        use: [...commonCssloader, &#39;less-loader&#39;]\n                    &#125;,\n                    &#123;\n                        // 在package.json中eslintConfig --&gt; aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: &#39;babel-loader&#39;,\n                        options: &#123;\n                            presets: [\n                                &#39;@babel/preset-env&#39;,\n                                &#123;\n                                    useBuiltIns: &#39;usage&#39;,\n                                    corejs: &#123;\n                                        version: 3\n                                    &#125;,\n                                    targets: &#123;\n                                        chrome: &#39;60&#39;,\n                                        firefox: &#39;50&#39;\n                                    &#125;\n                                &#125;\n                            ],\n                            // 开启babel缓存\n                            // 第二次构建时，会读取之前的缓存\n                            cacheDirectory:true\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 8 * 1024,\n                            name: &#39;[hash:10].[ext]&#39;,\n                            outputPath: &#39;imgs&#39;,\n                            esModule: false\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.html$/,\n                        loader: &#39;html-loader&#39;\n                    &#125;,\n                    &#123;\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: &#39;file-loader&#39;,\n                        options: &#123;\n                            outputPath: &#39;media&#39;\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.[contenthash:10].css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n\n    mode: &#39;production&#39;\n\n&#125;\n</code></pre>\n<h2 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree shaking\"></a>tree shaking</h2><p>为了去除在代码中没有使用到的代码</p>\n<pre><code>使用前提：\n1. 必须使用ES6模块化\n2. 模式为‘production’\n作用\n减少我们的打包体积\n\n在package.json中设置sideEffects:false 所有代码都没有作用(都可以使用tree shaking)\n问题：可能会把css/@babel/polyfill (副作用)进行删除\n&quot;sideEffect&quot;:[&#39;*.css&#39;,&#39;*.less&#39;] 这些类型的文件就不会进行tree shaking\n</code></pre>\n<h2 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h2><p>文件分割（分割的代码是js代码），按需加载</p>\n<p>方法</p>\n<ol>\n<li>多入口文件</li>\n</ol>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&#123;\n        main:&quot;./src/js/main.js&quot;,\n        test:&#39;./src/js/test.js&#39;\n    &#125;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&#123;\n        main:&quot;./src/js/main.js&quot;,\n        test:&#39;./src/js/test.js&#39;\n    &#125;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:&#123;\n      splitChunks:&#123;\n          chunks:&#39;all&#39;\n      &#125;  \n    &#125;,\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&quot;./src/js/main.js&quot;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:&#123;\n      splitChunks:&#123;\n          chunks:&#39;all&#39;\n      &#125;  \n    &#125;,\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// 通过js代码使得当前模块单独打包成一个chunk\n// import动态导入语法：能将文件单独打包\nimport(/* webpackChunkName:&#39;test&#39; */&#39;./test&#39;).then((res)=&gt;&#123;\n    console.log(res);\n&#125;).catch(()=&gt;&#123;\n    console.log(&quot;文件加载失败&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h2><p>等触发某些条件才会加载</p>\n<p>使用import的动态加载语法</p>\n<pre><code class=\"js\">// 懒加载 当文件需要时才加载\n// 预加载 prefetch 会提前加载js之前 等其他资源加载完成，等浏览器空闲在加载（慎用，兼容性问题）\n// 正常加载可以认为是并行加载(同一时间加载多个文件)\nimport(/*webpackNameChunk:&#39;test&#39;,*/,&#39;./test&#39;).then((&#123;f&#125;)=&gt;&#123;f()&#125;);\n</code></pre>\n<h2 id=\"PWA-渐进式网络开发应用程序，离线可访问\"><a href=\"#PWA-渐进式网络开发应用程序，离线可访问\" class=\"headerlink\" title=\"PWA(渐进式网络开发应用程序，离线可访问)\"></a>PWA(渐进式网络开发应用程序，离线可访问)</h2><p>workbox –&gt; workbox-webpack-plugin</p>\n<p>离线状态下也可以使得一部分功能能使用</p>\n<pre><code class=\"js\">plugins:[\n    new WorkboxWebpackPlugin.GenerateSW(&#123;\n        // 1. 帮助serviceworker快速启动\n        // 2. 删除旧的serviceworker\n        \n        // 生成一个serviceworker\n        clientsClaim:true\n        skipWaiting:true\n    &#125;)\n]\n</code></pre>\n<pre><code class=\"js\">// 注册servceworker\n// 处理兼容性问题\n// 测试需要在服务端运行 serve -s build 启动服务端\n// 可在浏览器的application中查看\nif(&#39;serviceworker&#39; in navigator)&#123;\n    window.addEventListener(&#39;load&#39;,()=&gt;&#123;\n        navigator.注册servceworker.register(&#39;./serviceworker&#39;).\n        then(()=&gt;&#123;\n             console.log(&quot;构建成功&quot;);\n        &#125;).catch(()=&gt;&#123;\n            console.log(&quot;构建失败&quot;);\n        &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"多进程打包\"><a href=\"#多进程打包\" class=\"headerlink\" title=\"多进程打包\"></a>多进程打包</h2><p>包 thread-loader</p>\n<p>在babel打包中引入loader</p>\n<p>优点</p>\n<p>进行开启需要时间，启动时间大概为600ms，进程通信也有开销</p>\n<p>只有工作消耗时间比较长，才需要多进程打包</p>\n<p>因为在我们开发中，js打包所需要的时间一般是最多的，所有一般是在js的相关loader开启多进程</p>\n<h2 id=\"externals\"><a href=\"#externals\" class=\"headerlink\" title=\"externals\"></a>externals</h2><p>就是我们使用cdn引入资源时，不要让Webpack打包cdn资源，直接cdn引入即可</p>\n<pre><code class=\"js\">module.exports = &#123;\n    ....\n    \n    \n    externals:&#123;\n        // 忽略的库名 -- npm 包名\n        // 拒绝jQuery被打包，主要要自己在html中cdn引入\n        jquery:&#39;jQuery&#39;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"dll\"><a href=\"#dll\" class=\"headerlink\" title=\"dll\"></a>dll</h2><p>动态打包</p>\n<p>可以将node_module分块打包</p>\n<p>在webpack.dll.js中填写</p>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst webpack = require(&#39;webpack&#39;)\n\n/*\n    使用dll技术，对某些库(第三方库：jquery,react,vue)进行单独打包\n    当我们运行webpack时，默认查找webpack.config.js 配置文件\n     --&gt; webpack --config 配置文件\n    就是单独打包某些库\n*/\nmodule.exports = &#123;\n    entry:&#123;\n        // 最终打包生成的[name] --&gt; jquery\n        //[&#39;jquery&#39;] --&gt; 要打包的库是jquery\n        juery:[&#39;jquery&#39;]\n    &#125;,\n    output:&#123;\n        filename:&#39;[name].js&#39;,\n        path:resolve(__dirname,&#39;dll&#39;),\n        library:&#39;[name] // 打包的库里向外暴露的内容名称将什么&#39;\n    &#125;,\n    plugins:[\n        // 打包生成一个manifest.json --&gt; 提供和jquery映射\n        new webpack.DllPlugin(&#123;\n            name:&#39;[name]_[hash]&#39;,// 映射库的暴露的内容名称,\n            path:resolve(__dirname,&#39;dll/manifest.json&#39;)\n        &#125;)\n    ],\n    mode:&#39;production&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// webpack.config.s\n// 需要安装 add-asset-html-webpack-plugin 该插件告诉webpack\nmodule.exports = &#123;\n    ..\n    \n    plugins:[\n        // 告诉webpack哪些库不需要打包，同时使用的名称也需要该\n        new webpack.DllReferencePlugin(&#123;\n            manifest:resolve(__dirname,&#39;dll/manifest.json&#39;)\n        &#125;),\n        // 将某个文件打包输出去，并在htmlz自动引入该资源\n        new AddAssetHtmlWebpackPlugin(&#123;\n            filepath:resolve(__dirname,&#39;dll/jquery.js&#39;))\n        &#125;)\n    ]\n&#125;\n</code></pre>\n<h2 id=\"优化总结\"><a href=\"#优化总结\" class=\"headerlink\" title=\"优化总结\"></a>优化总结</h2><h4 id=\"开发环境优化\"><a href=\"#开发环境优化\" class=\"headerlink\" title=\"开发环境优化\"></a>开发环境优化</h4><p>优化打包构建速度</p>\n<ol>\n<li>HMR</li>\n</ol>\n<p>优化代码调试</p>\n<ol>\n<li>source-map</li>\n</ol>\n<h4 id=\"生产环境性能优化\"><a href=\"#生产环境性能优化\" class=\"headerlink\" title=\"生产环境性能优化\"></a>生产环境性能优化</h4><p>优化打包构建速度</p>\n<ol>\n<li>oneOf</li>\n<li>BABEL缓存</li>\n<li>多进程打包</li>\n<li>externals</li>\n<li>dll</li>\n</ol>\n<p>优化代码运行性能</p>\n<ol>\n<li>文件缓存(hash,chunkhash,contenthash)</li>\n<li>tree shaking  打包时删除无用代码，从而使得打包后的体积更小</li>\n<li>代码分割 </li>\n<li>懒加载&#x2F;预加载</li>\n<li>pwa</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-开发环境性能优化\"><a href=\"#1-开发环境性能优化\" class=\"headerlink\" title=\"1. 开发环境性能优化\"></a>1. 开发环境性能优化</h4><ol>\n<li>优化打包构建速度</li>\n<li>优化代码调试</li>\n</ol>\n<h4 id=\"2-生产环境性能优化\"><a href=\"#2-生产环境性能优化\" class=\"headerlink\" title=\"2. 生产环境性能优化\"></a>2. 生产环境性能优化</h4><ol>\n<li>优化打包构建速度</li>\n<li>优化代码运行时的性能</li>\n</ol>\n<h2 id=\"开发环境-优化打包构建速度\"><a href=\"#开发环境-优化打包构建速度\" class=\"headerlink\" title=\"开发环境 优化打包构建速度\"></a>开发环境 优化打包构建速度</h2><h4 id=\"HMR\"><a href=\"#HMR\" class=\"headerlink\" title=\"HMR\"></a>HMR</h4><p>之前的问题：代码修改，全局刷新</p>\n<p><strong>HMR</strong>: hot module replacement 热模块替换 &#x2F; 模块热替换</p>\n<p>一个模块发生变化，只会重新打包这一个模块（而不是重新打包全部模块）</p>\n<p>只需将devServer的hot属性改为true,即可开启HMR</p>\n<p>样式文件：可以使用HMR功能：因为style-loader内部已经实现：</p>\n<p>js文件：默认不能使用HMR功能 但我们需要HMR</p>\n<p>html文件：默认不能使用HMR功能。html无法热更新（将html文件引入到入口配置），其实html无需HMR</p>\n<p>HMR针对的是那些非入口的js文件</p>\n<h4 id=\"source-map\"><a href=\"#source-map\" class=\"headerlink\" title=\"source-map\"></a>source-map</h4><p>[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map</p>\n<p>一种技术，提供源代码到构建后代码的映射</p>\n<p>如果构建后后代码出错了，通过映射可以追踪源代码错误</p>\n<p>我们只需在webpack配置中添加属性devtool:’source-map’</p>\n<p>内联和外部的区别</p>\n<ol>\n<li>外部生成了文件，内联没有</li>\n<li>内联构建速度够快</li>\n</ol>\n<p>source-map</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置</p>\n<p>inline-source-map </p>\n<p>内联<br>错误代码准确原因和源代码的错误位置</p>\n<p>hidden-source-map\t</p>\n<p> 外部<br> 错误代码准确原因但不提供源代码的错误位置（即不能追踪到源代码的错误，只追踪到构建后代码的位置）</p>\n<p>eval-source-map\t\t\t（每一个引入的模块之后都有源代码地址的，并在eval中）</p>\n<p>内联<br>错误代码准确原因和源代码的错误位置</p>\n<p>nosources-source-map\t</p>\n<p>外部<br>错误代码准确原因,但是没有任何源代码错误的相关提示</p>\n<p>cheap-source-map\t\t外部</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置(源代码错误代码只能精确到行)</p>\n<p>cheap-module-source-map\t</p>\n<p>外部<br>错误代码准确原因和源代码的错误位置<br>module会将loader的source-map加入</p>\n<p>考虑环境的使用</p>\n<ol>\n<li>开发环境：打包速度块，调试方便</li>\n</ol>\n<p>速度块<br>    eval&gt;inline&gt;cheap&gt;……<br>    eval-cheap-source-map 打包速度最快<br>    eval-source-map<br>调试更友好<br>    source-map<br>    cheap-module-source-map<br>    cheap-source-map<br>–&gt; eval-source-map&#x2F;eval-cheap-source-map是一个比较好的方案（具体情况具体看）</p>\n<ol start=\"2\">\n<li>生产环境：源代码隐藏是否</li>\n</ol>\n<p>nosources-source-map 隐藏全部代码<br>hidden-source-map\t只隐藏源代码，会提示构建后代码错误信息<br>内联会让代码体积变得非常大，因此内联的所有方案都要排除<br>–&gt;  source-map&#x2F;cheap-module-source-map</p>\n<h2 id=\"优化配置方案\"><a href=\"#优化配置方案\" class=\"headerlink\" title=\"优化配置方案\"></a>优化配置方案</h2><pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n */\nmodule.exports = &#123;\n\n    entry: &#39;./src/js/index.js&#39;,\n\n    output: &#123;\n        filename: &#39;js/built.js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n    module: &#123;\n        rules: [\n            &#123;\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [&#123;\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    &#125;,\n                    &#123;\n                        test: /\\.less$/,\n                        use: [...commonCssloader, &#39;less-loader&#39;]\n                    &#125;,\n                    &#123;\n                        // 在package.json中eslintConfig --&gt; aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: &#39;babel-loader&#39;,\n                        options: &#123;\n                            presets: [\n                                &#39;@babel/preset-env&#39;,\n                                &#123;\n                                    useBuiltIns: &#39;usage&#39;,\n                                    corejs: &#123;\n                                        version: 3\n                                    &#125;,\n                                    targets: &#123;\n                                        chrome: &#39;60&#39;,\n                                        firefox: &#39;50&#39;\n                                    &#125;\n                                &#125;\n                            ]\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 8 * 1024,\n                            name: &#39;[hash:10].[ext]&#39;,\n                            outputPath: &#39;imgs&#39;,\n                            esModule: false\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.html$/,\n                        loader: &#39;html-loader&#39;\n                    &#125;,\n                    &#123;\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: &#39;file-loader&#39;,\n                        options: &#123;\n                            outputPath: &#39;media&#39;\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n\n    mode: &#39;production&#39;\n\n&#125;\n\n// browserslist:&#123;\n//     &quot;development&quot;:[\n//         &quot;last 1 chrome version&quot;,\n//         &quot;last 1 firefox version&quot;,\n//         &quot;last 1 safari version&quot;\n//     ],\n//     &quot;production&quot;:[\n//         &quot;&gt;0.2%&quot;,\n//         &quot;not dead&quot;,\n//         &quot;not op_mini all&quot;\n//     ]\n// &#125;\n\n// eslintConfig:&#123;\n//     &quot;extends&quot;:&#39;aribnb-base&#39;\n// &#125;\n</code></pre>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ol>\n<li>babel缓存<br>第二次打包速度更快</li>\n<li>文件资源缓存<br>让代码上线运行缓存更好使用，页面访问速度更快</li>\n</ol>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)\nconst OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;)\nconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)\n\n// 开启生产环境配置\n// 定义nodejs环境变量：决定使用browserslist的哪一个环境\nprocess.env.NODE_ENV = &#39;development&#39;\n\n// 复用loader\nconst commonCssloader = [\n    MiniCssExtractPlugin.loader,\n    &#39;css-loader&#39;,\n    &#123;\n        // 还需要browserslist定义\n        loader: &#39;postcss-loader&#39;,\n        options: &#123;\n            ident: &#39;postcss&#39;,\n            plugins: () =&gt; &#123;\n                require(&quot;postcss-preset-env&quot;)()\n            &#125;\n        &#125;\n    &#125;\n]\n\n/**\n * 当一个文件被多个loader处理时，我们要清楚文件被处理的顺序\n * 从下向上执行\n * \n * babel缓存\n * 文件资源缓存：给文件名添加一个哈希值\n * 问题：因为js和css同时使用一个哈希值\n * 如果重新打包，会导致所有缓存失效，在这里指修改一个js\n * hash改为使用chunkhash:如果打包来源于一个chunk，则chunkhash相同\n * 问题是js和css来源于同一个模块（因为css要在js引入才能被打包）\n * contenthash:根据文件的内容生成hash值，不同文件hash值不同\n */\nmodule.exports = &#123;\n\n    entry: &#39;./src/js/index.js&#39;,\n\n    output: &#123;\n        filename: &#39;js/built_[contenthash:10].js&#39;,\n        path: resolve(__dirname, &#39;build&#39;)\n    &#125;,\n\n    module: &#123;\n        rules: [\n            &#123;\n                // 以下loader只会匹配一个\n                // 注意，同一个类型的文件不能被多种loader处理\n                oneOf: [\n                    &#123;\n                        test: /\\.css$/,\n                        use: [...commonCssloader]\n                    &#125;,\n                    &#123;\n                        test: /\\.less$/,\n                        use: [...commonCssloader, &#39;less-loader&#39;]\n                    &#125;,\n                    &#123;\n                        // 在package.json中eslintConfig --&gt; aribnb\n                        test: /\\.js$/,\n                        execlude: /node_modules/,\n                        loader: &#39;babel-loader&#39;,\n                        options: &#123;\n                            presets: [\n                                &#39;@babel/preset-env&#39;,\n                                &#123;\n                                    useBuiltIns: &#39;usage&#39;,\n                                    corejs: &#123;\n                                        version: 3\n                                    &#125;,\n                                    targets: &#123;\n                                        chrome: &#39;60&#39;,\n                                        firefox: &#39;50&#39;\n                                    &#125;\n                                &#125;\n                            ],\n                            // 开启babel缓存\n                            // 第二次构建时，会读取之前的缓存\n                            cacheDirectory:true\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.(jpg|png|gif)$/,\n                        loader: &#39;url-loader&#39;,\n                        options: &#123;\n                            limit: 8 * 1024,\n                            name: &#39;[hash:10].[ext]&#39;,\n                            outputPath: &#39;imgs&#39;,\n                            esModule: false\n                        &#125;\n                    &#125;,\n                    &#123;\n                        test: /\\.html$/,\n                        loader: &#39;html-loader&#39;\n                    &#125;,\n                    &#123;\n                        execlude: /\\.(js|css|less|png|gif|jpg|html)/,\n                        loader: &#39;file-loader&#39;,\n                        options: &#123;\n                            outputPath: &#39;media&#39;\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            &#123;\n                // 在package.json中eslintConfig --&gt; aribnb\n                test: /\\.js$/,\n                execlude: /node_modules/,\n                // 优先执行\n                enforce: &#39;pre&#39;,\n                loader: &#39;eslint-loader&#39;,\n                options: &#123;\n                    fix: true\n                &#125;\n            &#125;,\n        ]\n    &#125;,\n\n    plugins: [\n        new MiniCssExtractPlugin(&#123;\n            filename: &#39;css/built.[contenthash:10].css&#39;\n        &#125;),\n        new OptimizeCssAssetsWebpackPlugin(),\n        new HtmlWebpackPlugin(&#123;\n            template: &#39;./src/index.html&#39;,\n            minify: &#123;\n                collapseWhitespace: true,\n                removeComments: true\n            &#125;\n        &#125;)\n    ],\n\n    mode: &#39;production&#39;\n\n&#125;\n</code></pre>\n<h2 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree shaking\"></a>tree shaking</h2><p>为了去除在代码中没有使用到的代码</p>\n<pre><code>使用前提：\n1. 必须使用ES6模块化\n2. 模式为‘production’\n作用\n减少我们的打包体积\n\n在package.json中设置sideEffects:false 所有代码都没有作用(都可以使用tree shaking)\n问题：可能会把css/@babel/polyfill (副作用)进行删除\n&quot;sideEffect&quot;:[&#39;*.css&#39;,&#39;*.less&#39;] 这些类型的文件就不会进行tree shaking\n</code></pre>\n<h2 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h2><p>文件分割（分割的代码是js代码），按需加载</p>\n<p>方法</p>\n<ol>\n<li>多入口文件</li>\n</ol>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&#123;\n        main:&quot;./src/js/main.js&quot;,\n        test:&#39;./src/js/test.js&#39;\n    &#125;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&#123;\n        main:&quot;./src/js/main.js&quot;,\n        test:&#39;./src/js/test.js&#39;\n    &#125;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:&#123;\n      splitChunks:&#123;\n          chunks:&#39;all&#39;\n      &#125;  \n    &#125;,\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">const  &#123; resolve &#125; = require(&quot;path&quot;) \nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = &#123;\n    entry:&quot;./src/js/main.js&quot;,\n    output:&#123;\n        filename:&#39;js/[name].[contenthash:10].js&#39;,\n        path:resolve(__dirname,&#39;build&#39;)\n    &#125;,\n    plugins:[\n        new HtmlWebpackPlugin(&#123;\n            template:&#39;./src/index.html&#39;,\n            minify:&#123;\n                collapseWhitespace:true,\n                removeComment:true\n            &#125;\n        &#125;)\n    ],\n    // 可以将node_modules中的代码单独打包成一个chunk最终输出\n    // 可以避免node_modules中的代码重复加载被打包\n    // 自动分析多入口chunk中，有没有公共依赖，如果有，会打包成单独的一个chunk\n    optimization:&#123;\n      splitChunks:&#123;\n          chunks:&#39;all&#39;\n      &#125;  \n    &#125;,\n    mode:&#39;development&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// 通过js代码使得当前模块单独打包成一个chunk\n// import动态导入语法：能将文件单独打包\nimport(/* webpackChunkName:&#39;test&#39; */&#39;./test&#39;).then((res)=&gt;&#123;\n    console.log(res);\n&#125;).catch(()=&gt;&#123;\n    console.log(&quot;文件加载失败&quot;)\n&#125;)\n</code></pre>\n<h2 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h2><p>等触发某些条件才会加载</p>\n<p>使用import的动态加载语法</p>\n<pre><code class=\"js\">// 懒加载 当文件需要时才加载\n// 预加载 prefetch 会提前加载js之前 等其他资源加载完成，等浏览器空闲在加载（慎用，兼容性问题）\n// 正常加载可以认为是并行加载(同一时间加载多个文件)\nimport(/*webpackNameChunk:&#39;test&#39;,*/,&#39;./test&#39;).then((&#123;f&#125;)=&gt;&#123;f()&#125;);\n</code></pre>\n<h2 id=\"PWA-渐进式网络开发应用程序，离线可访问\"><a href=\"#PWA-渐进式网络开发应用程序，离线可访问\" class=\"headerlink\" title=\"PWA(渐进式网络开发应用程序，离线可访问)\"></a>PWA(渐进式网络开发应用程序，离线可访问)</h2><p>workbox –&gt; workbox-webpack-plugin</p>\n<p>离线状态下也可以使得一部分功能能使用</p>\n<pre><code class=\"js\">plugins:[\n    new WorkboxWebpackPlugin.GenerateSW(&#123;\n        // 1. 帮助serviceworker快速启动\n        // 2. 删除旧的serviceworker\n        \n        // 生成一个serviceworker\n        clientsClaim:true\n        skipWaiting:true\n    &#125;)\n]\n</code></pre>\n<pre><code class=\"js\">// 注册servceworker\n// 处理兼容性问题\n// 测试需要在服务端运行 serve -s build 启动服务端\n// 可在浏览器的application中查看\nif(&#39;serviceworker&#39; in navigator)&#123;\n    window.addEventListener(&#39;load&#39;,()=&gt;&#123;\n        navigator.注册servceworker.register(&#39;./serviceworker&#39;).\n        then(()=&gt;&#123;\n             console.log(&quot;构建成功&quot;);\n        &#125;).catch(()=&gt;&#123;\n            console.log(&quot;构建失败&quot;);\n        &#125;)\n    &#125;)\n&#125;\n</code></pre>\n<h2 id=\"多进程打包\"><a href=\"#多进程打包\" class=\"headerlink\" title=\"多进程打包\"></a>多进程打包</h2><p>包 thread-loader</p>\n<p>在babel打包中引入loader</p>\n<p>优点</p>\n<p>进行开启需要时间，启动时间大概为600ms，进程通信也有开销</p>\n<p>只有工作消耗时间比较长，才需要多进程打包</p>\n<p>因为在我们开发中，js打包所需要的时间一般是最多的，所有一般是在js的相关loader开启多进程</p>\n<h2 id=\"externals\"><a href=\"#externals\" class=\"headerlink\" title=\"externals\"></a>externals</h2><p>就是我们使用cdn引入资源时，不要让Webpack打包cdn资源，直接cdn引入即可</p>\n<pre><code class=\"js\">module.exports = &#123;\n    ....\n    \n    \n    externals:&#123;\n        // 忽略的库名 -- npm 包名\n        // 拒绝jQuery被打包，主要要自己在html中cdn引入\n        jquery:&#39;jQuery&#39;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"dll\"><a href=\"#dll\" class=\"headerlink\" title=\"dll\"></a>dll</h2><p>动态打包</p>\n<p>可以将node_module分块打包</p>\n<p>在webpack.dll.js中填写</p>\n<pre><code class=\"js\">const &#123; resolve &#125; = require(&#39;path&#39;);\nconst webpack = require(&#39;webpack&#39;)\n\n/*\n    使用dll技术，对某些库(第三方库：jquery,react,vue)进行单独打包\n    当我们运行webpack时，默认查找webpack.config.js 配置文件\n     --&gt; webpack --config 配置文件\n    就是单独打包某些库\n*/\nmodule.exports = &#123;\n    entry:&#123;\n        // 最终打包生成的[name] --&gt; jquery\n        //[&#39;jquery&#39;] --&gt; 要打包的库是jquery\n        juery:[&#39;jquery&#39;]\n    &#125;,\n    output:&#123;\n        filename:&#39;[name].js&#39;,\n        path:resolve(__dirname,&#39;dll&#39;),\n        library:&#39;[name] // 打包的库里向外暴露的内容名称将什么&#39;\n    &#125;,\n    plugins:[\n        // 打包生成一个manifest.json --&gt; 提供和jquery映射\n        new webpack.DllPlugin(&#123;\n            name:&#39;[name]_[hash]&#39;,// 映射库的暴露的内容名称,\n            path:resolve(__dirname,&#39;dll/manifest.json&#39;)\n        &#125;)\n    ],\n    mode:&#39;production&#39;\n&#125;\n</code></pre>\n<pre><code class=\"js\">// webpack.config.s\n// 需要安装 add-asset-html-webpack-plugin 该插件告诉webpack\nmodule.exports = &#123;\n    ..\n    \n    plugins:[\n        // 告诉webpack哪些库不需要打包，同时使用的名称也需要该\n        new webpack.DllReferencePlugin(&#123;\n            manifest:resolve(__dirname,&#39;dll/manifest.json&#39;)\n        &#125;),\n        // 将某个文件打包输出去，并在htmlz自动引入该资源\n        new AddAssetHtmlWebpackPlugin(&#123;\n            filepath:resolve(__dirname,&#39;dll/jquery.js&#39;))\n        &#125;)\n    ]\n&#125;\n</code></pre>\n<h2 id=\"优化总结\"><a href=\"#优化总结\" class=\"headerlink\" title=\"优化总结\"></a>优化总结</h2><h4 id=\"开发环境优化\"><a href=\"#开发环境优化\" class=\"headerlink\" title=\"开发环境优化\"></a>开发环境优化</h4><p>优化打包构建速度</p>\n<ol>\n<li>HMR</li>\n</ol>\n<p>优化代码调试</p>\n<ol>\n<li>source-map</li>\n</ol>\n<h4 id=\"生产环境性能优化\"><a href=\"#生产环境性能优化\" class=\"headerlink\" title=\"生产环境性能优化\"></a>生产环境性能优化</h4><p>优化打包构建速度</p>\n<ol>\n<li>oneOf</li>\n<li>BABEL缓存</li>\n<li>多进程打包</li>\n<li>externals</li>\n<li>dll</li>\n</ol>\n<p>优化代码运行性能</p>\n<ol>\n<li>文件缓存(hash,chunkhash,contenthash)</li>\n<li>tree shaking  打包时删除无用代码，从而使得打包后的体积更小</li>\n<li>代码分割 </li>\n<li>懒加载&#x2F;预加载</li>\n<li>pwa</li>\n</ol>\n"},{"title":"Webpack 配置详解","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2020-01-05T16:00:00.000Z","comments":0,"description":"Webpack 配置详解","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/webpack_5.jpg"],"_content":"\n\n## entry\n\n含义：打包的入口文件\n\n属性值\n\n1. **string** --> './src/index.js'\n\n```\n单入口\n打包形成一个chunk,输出一个bundle文件\n此时chunk的名称默认为main\n```\n\n2. array --->  ['./src/add.js'  , './src/index.js']\n\n```\n多入口\n所有的入口文件最终只会形成一个chunk，输出出去只有一个bundle\n只有在HMR功能中让html热更新生效\n```\n\n3. object（文件名称：文件路径）\n\n```\n多入口\n有几个入口文件就形成几个chunk，输出几个bundle文件\n此时chunk的名称是key\n特殊用法\n{\n    // 所有入口文件最终只会形成一个chunk,输出一个bundle\n   \t“index\":['index.js','count.js'],\n   \t// 形成一个chunk,输出一个bundle\n   \t'add':'./src/add.js'\n}\n```\n\n\n## output\n\n基本配置\n\n```js\n....\nmodule.exports = {\n    entry:'./src/index.js',\n    output:{\n        // 文件名称(指定名称+目录)\n        filename:'js/[name].js',\n        // 输出文件目录(将来所以输出资源的公共目录)\n        path:resolve(__dirname,'build'),\n        // 所有输出资源引用公共路径 --> 路径的前面\n        publicPath:'/',\n        // 非chunk的名称\n        chunkFilename:'[name]_chunk.js',\n        library:'[name]', // 整个库向外暴露的变量名\n        libraryTarget:'window' // 变量名添加到哪一个上面 browser 添加到window\n        libraryTarget:'global' // 变量名添加到哪一个上面 node 添加到global\n        libraryTarget:'commonjs' // 以\n    }\t\n}\n```\n\n## module\n\n```js\nmodule:{\n    rules:[\n        //loader 配置\n        {\n            test:/\\.css$/,\n            // 多个loader用use\n            use:['style-loader','css-loader']\n        },\n        {\n            test:/\\.js$/,\n            // 排除/node_modules/下的js文件\n            exclude: /node_modules/,\n            // 只检查src的js文件\n            include:resolve(__dirname,'src')\n            // 优先执行\n            // enforce:'pre',\n            // 延后执行\n            // enforce:'post',\n            // 多个loader用loader\n            loader:'eslint-loader',\n            // 给loader传递参数\n            options:{}\n        },\n        {\n            // 以下配置只生效一个\n            oneOf:[]\n        }\n    ]\n}\n```\n\n## resolve\n\n用于解析模块规则\n\n```js\nmodule.exports = {\n    // 解析模块的规则\n    resolve:{\n        // 配置解析模块路径别名\n        // 可以简写引入模块的路径\n        // 代码语义不明\n        alias:{\n            $css:resolve(__dirname,'src/css')\n        }，\n        // 配置省略文件路径的后缀名\n        extensions:['js','json','css','.jsx'],\n    \t// 告诉webpack解析模块去哪个目录找\n    \tmodules:[resolve(__dirname,'../../node_modules')'node_modules']\n    }\n}\n```\n\n## devServer\n\n```js\nmodule.exports = {\n    devServer:{\n        // 运行代码的目录\n        contentBase:resolve(__dirname,'build'),\n        // 监视contentBase目录下的所有文件，一旦文件变化就会reload\n        watchContentBase:true,\n        // 监视配置\n        watchOptions:{\n        \t// 忽略文件\n            ignored:/node_modules/            \n        },\n        // 启动gzip压缩\n        compress:true,\n        // 端口号\n        port:5000,\n        // 域名\n        host:'localhost'\n        // 自动打开浏览器\n        open:true,\n        // 开启HMR功能\n        hot:true,\n        // 服务器日志相关配置信息\n        clientLogLevel:'none'\n        // 除了一些基本的启动信息以外，其他内容都不要显示\t\n        quiet:true,\n        // 如果出现错误，不要全屏提示\n        overlay:false\n        // 服务器代理 --> 解决开发环境跨域问题\n        proxy:{\n        \t// 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到端口号3000\n        \t'/api':{\n        \t\ttarget:'http://localhost:3000',\n        \t\t// 发送请求时，请求路径重写 将 '^/api/xxx ---> /xxx'\n        \t\tpathRewrite:{\n        \t\t\t'^/api':''\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n}\n```\n\n## optimization\n\n```js\nmodule.exports = {\n    \n    optimization:{\n        splitChunks :{\n            chunks:'all',\n            // 以下都是默认值\n            minSize:30*1024, // 分割的chunk最小为30kb\n            maxSize:0, // 最大没有限制\n            minChunks:1 // 要提取的chunk最少次数为1次\n            maxAsyncRequests:5, // 按需加载时并行加载的文件最大数量\n            minInitialRequest:3, // 入口js文件最大并行请求数量\n            automaticeNameDelimiter:'~' // 名称连接符\n            name:true, // 可以使用命名规则\n            // 分割chunk的组\n            cacheGroups:{\n            \t// node_modules文件会被打包到vendors组的chunk中 --> vendors~xxx.js\n            \t// 还要满足上面的公共规则\n            \tvendors:{\n            \t\ttest:/[\\\\/]node_modules[\\\\/]/,\n            \t\t// 打包的优先级\n            \t\tpriority:-10\n        \t\t},\n        \t\tdefault:{\n                    // 要提取的chunk最少次数为2次\n            \t\tminChunks:2,\n                    // 打包的优先级\n            \t\tpriority:-20,\n                    // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n                    reuseExistingChunk:true\n        \t\t}\n        \t}\n        },\n        runtimeChunk:{\n            // 将当前模块记录的引入其他模块哈希值打包成一个单独文件\n            name:entrypoint=>`runtime-${entrypoint.name}`\n        },\n         minimizer:[\n             // 配置js和Css的压缩方案\n             new TerserWebpackPlugin({\n                 // 开启缓存\n                 cache:true,\n                 // 开启多进程打包\n                 parallel:true,\n                 // 开启sourceMap\n                 sourceMap:true\n             })\n         ]       \n    }\n    \n}\n```\n\n\n\n","source":"_posts/前端/Webpack/05 配置详解.md","raw":"---\ntitle: Webpack 配置详解\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2020-01-06\ncomments: false\ndescription: Webpack 配置详解\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/webpack_5.jpg\n---\n\n\n## entry\n\n含义：打包的入口文件\n\n属性值\n\n1. **string** --> './src/index.js'\n\n```\n单入口\n打包形成一个chunk,输出一个bundle文件\n此时chunk的名称默认为main\n```\n\n2. array --->  ['./src/add.js'  , './src/index.js']\n\n```\n多入口\n所有的入口文件最终只会形成一个chunk，输出出去只有一个bundle\n只有在HMR功能中让html热更新生效\n```\n\n3. object（文件名称：文件路径）\n\n```\n多入口\n有几个入口文件就形成几个chunk，输出几个bundle文件\n此时chunk的名称是key\n特殊用法\n{\n    // 所有入口文件最终只会形成一个chunk,输出一个bundle\n   \t“index\":['index.js','count.js'],\n   \t// 形成一个chunk,输出一个bundle\n   \t'add':'./src/add.js'\n}\n```\n\n\n## output\n\n基本配置\n\n```js\n....\nmodule.exports = {\n    entry:'./src/index.js',\n    output:{\n        // 文件名称(指定名称+目录)\n        filename:'js/[name].js',\n        // 输出文件目录(将来所以输出资源的公共目录)\n        path:resolve(__dirname,'build'),\n        // 所有输出资源引用公共路径 --> 路径的前面\n        publicPath:'/',\n        // 非chunk的名称\n        chunkFilename:'[name]_chunk.js',\n        library:'[name]', // 整个库向外暴露的变量名\n        libraryTarget:'window' // 变量名添加到哪一个上面 browser 添加到window\n        libraryTarget:'global' // 变量名添加到哪一个上面 node 添加到global\n        libraryTarget:'commonjs' // 以\n    }\t\n}\n```\n\n## module\n\n```js\nmodule:{\n    rules:[\n        //loader 配置\n        {\n            test:/\\.css$/,\n            // 多个loader用use\n            use:['style-loader','css-loader']\n        },\n        {\n            test:/\\.js$/,\n            // 排除/node_modules/下的js文件\n            exclude: /node_modules/,\n            // 只检查src的js文件\n            include:resolve(__dirname,'src')\n            // 优先执行\n            // enforce:'pre',\n            // 延后执行\n            // enforce:'post',\n            // 多个loader用loader\n            loader:'eslint-loader',\n            // 给loader传递参数\n            options:{}\n        },\n        {\n            // 以下配置只生效一个\n            oneOf:[]\n        }\n    ]\n}\n```\n\n## resolve\n\n用于解析模块规则\n\n```js\nmodule.exports = {\n    // 解析模块的规则\n    resolve:{\n        // 配置解析模块路径别名\n        // 可以简写引入模块的路径\n        // 代码语义不明\n        alias:{\n            $css:resolve(__dirname,'src/css')\n        }，\n        // 配置省略文件路径的后缀名\n        extensions:['js','json','css','.jsx'],\n    \t// 告诉webpack解析模块去哪个目录找\n    \tmodules:[resolve(__dirname,'../../node_modules')'node_modules']\n    }\n}\n```\n\n## devServer\n\n```js\nmodule.exports = {\n    devServer:{\n        // 运行代码的目录\n        contentBase:resolve(__dirname,'build'),\n        // 监视contentBase目录下的所有文件，一旦文件变化就会reload\n        watchContentBase:true,\n        // 监视配置\n        watchOptions:{\n        \t// 忽略文件\n            ignored:/node_modules/            \n        },\n        // 启动gzip压缩\n        compress:true,\n        // 端口号\n        port:5000,\n        // 域名\n        host:'localhost'\n        // 自动打开浏览器\n        open:true,\n        // 开启HMR功能\n        hot:true,\n        // 服务器日志相关配置信息\n        clientLogLevel:'none'\n        // 除了一些基本的启动信息以外，其他内容都不要显示\t\n        quiet:true,\n        // 如果出现错误，不要全屏提示\n        overlay:false\n        // 服务器代理 --> 解决开发环境跨域问题\n        proxy:{\n        \t// 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到端口号3000\n        \t'/api':{\n        \t\ttarget:'http://localhost:3000',\n        \t\t// 发送请求时，请求路径重写 将 '^/api/xxx ---> /xxx'\n        \t\tpathRewrite:{\n        \t\t\t'^/api':''\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n}\n```\n\n## optimization\n\n```js\nmodule.exports = {\n    \n    optimization:{\n        splitChunks :{\n            chunks:'all',\n            // 以下都是默认值\n            minSize:30*1024, // 分割的chunk最小为30kb\n            maxSize:0, // 最大没有限制\n            minChunks:1 // 要提取的chunk最少次数为1次\n            maxAsyncRequests:5, // 按需加载时并行加载的文件最大数量\n            minInitialRequest:3, // 入口js文件最大并行请求数量\n            automaticeNameDelimiter:'~' // 名称连接符\n            name:true, // 可以使用命名规则\n            // 分割chunk的组\n            cacheGroups:{\n            \t// node_modules文件会被打包到vendors组的chunk中 --> vendors~xxx.js\n            \t// 还要满足上面的公共规则\n            \tvendors:{\n            \t\ttest:/[\\\\/]node_modules[\\\\/]/,\n            \t\t// 打包的优先级\n            \t\tpriority:-10\n        \t\t},\n        \t\tdefault:{\n                    // 要提取的chunk最少次数为2次\n            \t\tminChunks:2,\n                    // 打包的优先级\n            \t\tpriority:-20,\n                    // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n                    reuseExistingChunk:true\n        \t\t}\n        \t}\n        },\n        runtimeChunk:{\n            // 将当前模块记录的引入其他模块哈希值打包成一个单独文件\n            name:entrypoint=>`runtime-${entrypoint.name}`\n        },\n         minimizer:[\n             // 配置js和Css的压缩方案\n             new TerserWebpackPlugin({\n                 // 开启缓存\n                 cache:true,\n                 // 开启多进程打包\n                 parallel:true,\n                 // 开启sourceMap\n                 sourceMap:true\n             })\n         ]       \n    }\n    \n}\n```\n\n\n\n","slug":"前端/Webpack/05 配置详解","published":1,"updated":"2023-05-12T23:28:10.995Z","layout":"post","link":"","_id":"clhws1t33002n2h17bezkfk8a","content":"<h2 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h2><p>含义：打包的入口文件</p>\n<p>属性值</p>\n<ol>\n<li><strong>string</strong> –&gt; ‘.&#x2F;src&#x2F;index.js’</li>\n</ol>\n<pre><code>单入口\n打包形成一个chunk,输出一个bundle文件\n此时chunk的名称默认为main\n</code></pre>\n<ol start=\"2\">\n<li>array —&gt;  [‘.&#x2F;src&#x2F;add.js’  , ‘.&#x2F;src&#x2F;index.js’]</li>\n</ol>\n<pre><code>多入口\n所有的入口文件最终只会形成一个chunk，输出出去只有一个bundle\n只有在HMR功能中让html热更新生效\n</code></pre>\n<ol start=\"3\">\n<li>object（文件名称：文件路径）</li>\n</ol>\n<pre><code>多入口\n有几个入口文件就形成几个chunk，输出几个bundle文件\n此时chunk的名称是key\n特殊用法\n&#123;\n    // 所有入口文件最终只会形成一个chunk,输出一个bundle\n       “index&quot;:[&#39;index.js&#39;,&#39;count.js&#39;],\n       // 形成一个chunk,输出一个bundle\n       &#39;add&#39;:&#39;./src/add.js&#39;\n&#125;\n</code></pre>\n<h2 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h2><p>基本配置</p>\n<pre><code class=\"js\">....\nmodule.exports = &#123;\n    entry:&#39;./src/index.js&#39;,\n    output:&#123;\n        // 文件名称(指定名称+目录)\n        filename:&#39;js/[name].js&#39;,\n        // 输出文件目录(将来所以输出资源的公共目录)\n        path:resolve(__dirname,&#39;build&#39;),\n        // 所有输出资源引用公共路径 --&gt; 路径的前面\n        publicPath:&#39;/&#39;,\n        // 非chunk的名称\n        chunkFilename:&#39;[name]_chunk.js&#39;,\n        library:&#39;[name]&#39;, // 整个库向外暴露的变量名\n        libraryTarget:&#39;window&#39; // 变量名添加到哪一个上面 browser 添加到window\n        libraryTarget:&#39;global&#39; // 变量名添加到哪一个上面 node 添加到global\n        libraryTarget:&#39;commonjs&#39; // 以\n    &#125;\t\n&#125;\n</code></pre>\n<h2 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h2><pre><code class=\"js\">module:&#123;\n    rules:[\n        //loader 配置\n        &#123;\n            test:/\\.css$/,\n            // 多个loader用use\n            use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n        &#125;,\n        &#123;\n            test:/\\.js$/,\n            // 排除/node_modules/下的js文件\n            exclude: /node_modules/,\n            // 只检查src的js文件\n            include:resolve(__dirname,&#39;src&#39;)\n            // 优先执行\n            // enforce:&#39;pre&#39;,\n            // 延后执行\n            // enforce:&#39;post&#39;,\n            // 多个loader用loader\n            loader:&#39;eslint-loader&#39;,\n            // 给loader传递参数\n            options:&#123;&#125;\n        &#125;,\n        &#123;\n            // 以下配置只生效一个\n            oneOf:[]\n        &#125;\n    ]\n&#125;\n</code></pre>\n<h2 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve\"></a>resolve</h2><p>用于解析模块规则</p>\n<pre><code class=\"js\">module.exports = &#123;\n    // 解析模块的规则\n    resolve:&#123;\n        // 配置解析模块路径别名\n        // 可以简写引入模块的路径\n        // 代码语义不明\n        alias:&#123;\n            $css:resolve(__dirname,&#39;src/css&#39;)\n        &#125;，\n        // 配置省略文件路径的后缀名\n        extensions:[&#39;js&#39;,&#39;json&#39;,&#39;css&#39;,&#39;.jsx&#39;],\n        // 告诉webpack解析模块去哪个目录找\n        modules:[resolve(__dirname,&#39;../../node_modules&#39;)&#39;node_modules&#39;]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h2><pre><code class=\"js\">module.exports = &#123;\n    devServer:&#123;\n        // 运行代码的目录\n        contentBase:resolve(__dirname,&#39;build&#39;),\n        // 监视contentBase目录下的所有文件，一旦文件变化就会reload\n        watchContentBase:true,\n        // 监视配置\n        watchOptions:&#123;\n            // 忽略文件\n            ignored:/node_modules/            \n        &#125;,\n        // 启动gzip压缩\n        compress:true,\n        // 端口号\n        port:5000,\n        // 域名\n        host:&#39;localhost&#39;\n        // 自动打开浏览器\n        open:true,\n        // 开启HMR功能\n        hot:true,\n        // 服务器日志相关配置信息\n        clientLogLevel:&#39;none&#39;\n        // 除了一些基本的启动信息以外，其他内容都不要显示\t\n        quiet:true,\n        // 如果出现错误，不要全屏提示\n        overlay:false\n        // 服务器代理 --&gt; 解决开发环境跨域问题\n        proxy:&#123;\n            // 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到端口号3000\n            &#39;/api&#39;:&#123;\n                target:&#39;http://localhost:3000&#39;,\n                // 发送请求时，请求路径重写 将 &#39;^/api/xxx ---&gt; /xxx&#39;\n                pathRewrite:&#123;\n                    &#39;^/api&#39;:&#39;&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"optimization\"><a href=\"#optimization\" class=\"headerlink\" title=\"optimization\"></a>optimization</h2><pre><code class=\"js\">module.exports = &#123;\n    \n    optimization:&#123;\n        splitChunks :&#123;\n            chunks:&#39;all&#39;,\n            // 以下都是默认值\n            minSize:30*1024, // 分割的chunk最小为30kb\n            maxSize:0, // 最大没有限制\n            minChunks:1 // 要提取的chunk最少次数为1次\n            maxAsyncRequests:5, // 按需加载时并行加载的文件最大数量\n            minInitialRequest:3, // 入口js文件最大并行请求数量\n            automaticeNameDelimiter:&#39;~&#39; // 名称连接符\n            name:true, // 可以使用命名规则\n            // 分割chunk的组\n            cacheGroups:&#123;\n                // node_modules文件会被打包到vendors组的chunk中 --&gt; vendors~xxx.js\n                // 还要满足上面的公共规则\n                vendors:&#123;\n                    test:/[\\\\/]node_modules[\\\\/]/,\n                    // 打包的优先级\n                    priority:-10\n                &#125;,\n                default:&#123;\n                    // 要提取的chunk最少次数为2次\n                    minChunks:2,\n                    // 打包的优先级\n                    priority:-20,\n                    // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n                    reuseExistingChunk:true\n                &#125;\n            &#125;\n        &#125;,\n        runtimeChunk:&#123;\n            // 将当前模块记录的引入其他模块哈希值打包成一个单独文件\n            name:entrypoint=&gt;`runtime-$&#123;entrypoint.name&#125;`\n        &#125;,\n         minimizer:[\n             // 配置js和Css的压缩方案\n             new TerserWebpackPlugin(&#123;\n                 // 开启缓存\n                 cache:true,\n                 // 开启多进程打包\n                 parallel:true,\n                 // 开启sourceMap\n                 sourceMap:true\n             &#125;)\n         ]       \n    &#125;\n    \n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h2><p>含义：打包的入口文件</p>\n<p>属性值</p>\n<ol>\n<li><strong>string</strong> –&gt; ‘.&#x2F;src&#x2F;index.js’</li>\n</ol>\n<pre><code>单入口\n打包形成一个chunk,输出一个bundle文件\n此时chunk的名称默认为main\n</code></pre>\n<ol start=\"2\">\n<li>array —&gt;  [‘.&#x2F;src&#x2F;add.js’  , ‘.&#x2F;src&#x2F;index.js’]</li>\n</ol>\n<pre><code>多入口\n所有的入口文件最终只会形成一个chunk，输出出去只有一个bundle\n只有在HMR功能中让html热更新生效\n</code></pre>\n<ol start=\"3\">\n<li>object（文件名称：文件路径）</li>\n</ol>\n<pre><code>多入口\n有几个入口文件就形成几个chunk，输出几个bundle文件\n此时chunk的名称是key\n特殊用法\n&#123;\n    // 所有入口文件最终只会形成一个chunk,输出一个bundle\n       “index&quot;:[&#39;index.js&#39;,&#39;count.js&#39;],\n       // 形成一个chunk,输出一个bundle\n       &#39;add&#39;:&#39;./src/add.js&#39;\n&#125;\n</code></pre>\n<h2 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h2><p>基本配置</p>\n<pre><code class=\"js\">....\nmodule.exports = &#123;\n    entry:&#39;./src/index.js&#39;,\n    output:&#123;\n        // 文件名称(指定名称+目录)\n        filename:&#39;js/[name].js&#39;,\n        // 输出文件目录(将来所以输出资源的公共目录)\n        path:resolve(__dirname,&#39;build&#39;),\n        // 所有输出资源引用公共路径 --&gt; 路径的前面\n        publicPath:&#39;/&#39;,\n        // 非chunk的名称\n        chunkFilename:&#39;[name]_chunk.js&#39;,\n        library:&#39;[name]&#39;, // 整个库向外暴露的变量名\n        libraryTarget:&#39;window&#39; // 变量名添加到哪一个上面 browser 添加到window\n        libraryTarget:&#39;global&#39; // 变量名添加到哪一个上面 node 添加到global\n        libraryTarget:&#39;commonjs&#39; // 以\n    &#125;\t\n&#125;\n</code></pre>\n<h2 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h2><pre><code class=\"js\">module:&#123;\n    rules:[\n        //loader 配置\n        &#123;\n            test:/\\.css$/,\n            // 多个loader用use\n            use:[&#39;style-loader&#39;,&#39;css-loader&#39;]\n        &#125;,\n        &#123;\n            test:/\\.js$/,\n            // 排除/node_modules/下的js文件\n            exclude: /node_modules/,\n            // 只检查src的js文件\n            include:resolve(__dirname,&#39;src&#39;)\n            // 优先执行\n            // enforce:&#39;pre&#39;,\n            // 延后执行\n            // enforce:&#39;post&#39;,\n            // 多个loader用loader\n            loader:&#39;eslint-loader&#39;,\n            // 给loader传递参数\n            options:&#123;&#125;\n        &#125;,\n        &#123;\n            // 以下配置只生效一个\n            oneOf:[]\n        &#125;\n    ]\n&#125;\n</code></pre>\n<h2 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\"resolve\"></a>resolve</h2><p>用于解析模块规则</p>\n<pre><code class=\"js\">module.exports = &#123;\n    // 解析模块的规则\n    resolve:&#123;\n        // 配置解析模块路径别名\n        // 可以简写引入模块的路径\n        // 代码语义不明\n        alias:&#123;\n            $css:resolve(__dirname,&#39;src/css&#39;)\n        &#125;，\n        // 配置省略文件路径的后缀名\n        extensions:[&#39;js&#39;,&#39;json&#39;,&#39;css&#39;,&#39;.jsx&#39;],\n        // 告诉webpack解析模块去哪个目录找\n        modules:[resolve(__dirname,&#39;../../node_modules&#39;)&#39;node_modules&#39;]\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"devServer\"><a href=\"#devServer\" class=\"headerlink\" title=\"devServer\"></a>devServer</h2><pre><code class=\"js\">module.exports = &#123;\n    devServer:&#123;\n        // 运行代码的目录\n        contentBase:resolve(__dirname,&#39;build&#39;),\n        // 监视contentBase目录下的所有文件，一旦文件变化就会reload\n        watchContentBase:true,\n        // 监视配置\n        watchOptions:&#123;\n            // 忽略文件\n            ignored:/node_modules/            \n        &#125;,\n        // 启动gzip压缩\n        compress:true,\n        // 端口号\n        port:5000,\n        // 域名\n        host:&#39;localhost&#39;\n        // 自动打开浏览器\n        open:true,\n        // 开启HMR功能\n        hot:true,\n        // 服务器日志相关配置信息\n        clientLogLevel:&#39;none&#39;\n        // 除了一些基本的启动信息以外，其他内容都不要显示\t\n        quiet:true,\n        // 如果出现错误，不要全屏提示\n        overlay:false\n        // 服务器代理 --&gt; 解决开发环境跨域问题\n        proxy:&#123;\n            // 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到端口号3000\n            &#39;/api&#39;:&#123;\n                target:&#39;http://localhost:3000&#39;,\n                // 发送请求时，请求路径重写 将 &#39;^/api/xxx ---&gt; /xxx&#39;\n                pathRewrite:&#123;\n                    &#39;^/api&#39;:&#39;&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"optimization\"><a href=\"#optimization\" class=\"headerlink\" title=\"optimization\"></a>optimization</h2><pre><code class=\"js\">module.exports = &#123;\n    \n    optimization:&#123;\n        splitChunks :&#123;\n            chunks:&#39;all&#39;,\n            // 以下都是默认值\n            minSize:30*1024, // 分割的chunk最小为30kb\n            maxSize:0, // 最大没有限制\n            minChunks:1 // 要提取的chunk最少次数为1次\n            maxAsyncRequests:5, // 按需加载时并行加载的文件最大数量\n            minInitialRequest:3, // 入口js文件最大并行请求数量\n            automaticeNameDelimiter:&#39;~&#39; // 名称连接符\n            name:true, // 可以使用命名规则\n            // 分割chunk的组\n            cacheGroups:&#123;\n                // node_modules文件会被打包到vendors组的chunk中 --&gt; vendors~xxx.js\n                // 还要满足上面的公共规则\n                vendors:&#123;\n                    test:/[\\\\/]node_modules[\\\\/]/,\n                    // 打包的优先级\n                    priority:-10\n                &#125;,\n                default:&#123;\n                    // 要提取的chunk最少次数为2次\n                    minChunks:2,\n                    // 打包的优先级\n                    priority:-20,\n                    // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n                    reuseExistingChunk:true\n                &#125;\n            &#125;\n        &#125;,\n        runtimeChunk:&#123;\n            // 将当前模块记录的引入其他模块哈希值打包成一个单独文件\n            name:entrypoint=&gt;`runtime-$&#123;entrypoint.name&#125;`\n        &#125;,\n         minimizer:[\n             // 配置js和Css的压缩方案\n             new TerserWebpackPlugin(&#123;\n                 // 开启缓存\n                 cache:true,\n                 // 开启多进程打包\n                 parallel:true,\n                 // 开启sourceMap\n                 sourceMap:true\n             &#125;)\n         ]       \n    &#125;\n    \n&#125;\n</code></pre>\n"},{"title":"Webpack webpack5","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"webpack","date":"2020-02-20T16:00:00.000Z","comments":0,"description":"Webpack webpack5","photos":["https://gitee.com/trueLoving/cdn/raw/master/img/daily.jpg"],"_content":"\n#### 安装 \n\nnpm i webpack@next webpack-cli -D\n\n#### 关注点\n\n1. 通过持久缓存提高构建性能\n2. 使用更好的算法和默认值来改善长期缓存\n3. 通过更好的树摇和代码生成来改善捆绑包\n4. 清除处于怪异状态的内部结构，同时在v4中实现功能二不引入重大改变\n5. 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间使用v5\n\n#### 自动删除Node.js Polyfills\n\n在webpack5中，会自动停止Node的核心模块的提供，并专注于前端兼容的模块\n\n迁移\n\n1. 尽可能尝试使用与前端兼容的模块\n2. 可以为nodejs核心模块手动添加一个polyfill。错误信息会提示如何实现该目标\n\n#### Chunk 和 模块ID\n\n添加了用于长期缓存的新算法。在生产模式默认启动\n\n```js\nchunkId:'deterministic',moduleIds:'deterministic'\n```\n\n#### Chunk ID\n\n我们可以不用使用`import(/*webpackChunkName:'name'*/'module')`在开发环境来为chunk命名\n\nwebpack内部有chunk的命名规则，不再是以id(0,1,2)命名\n\n#### Tree Shaking\n\n1. webpack5能够处理嵌套模块的tree shaking\n\n```js\n// index.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from './inner';\nexport { inner }\n\n// user.js\nimport * as module from './module';\nconsole.log(module.inner.a);\n```\n\n在生产环境中，inner模块的b会被删除\n\n2. webpack5能够处理多个模块之前的关系\n\n```js\nimport { something } from './something';\n\nfunction usingSomething(){\n    return something;\n}\n\nexport function test(){\n    return usingSomething();\n}\n```\n\n当设置`'sideEffects':false`时，一旦发现`test`方法没有使用，不但会删除test，还会删除`./something` \n\n3. webpack5能够处理Commonjs的tree shaking\n\n#### output\n\nwebpack4 默认输出ES5代码\n\nwebpack5 开始新增一个属性output.ecmaVersion,可以生成ES5和ES6代码\n\n#### Caching\n\n```js\ncache:{\n    // 缓存类型\n    type:'filesystem',\n    buildDependencies:{\n        // 当配置修改时，缓存失效\n        config:[__filename]\n    }\n}\n```\n\n缓存将存储到node_modules/.cache/webpack\n\n#### 更多内容 https://github.com/webpack/changelog-v5","source":"_posts/前端/Webpack/06 webpack5.md","raw":"---\ntitle: Webpack webpack5\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - webpack\nkeywords: webpack\ndate: 2020-02-21\ncomments: false\ndescription: Webpack webpack5\nphotos: https://gitee.com/trueLoving/cdn/raw/master/img/daily.jpg\n---\n\n#### 安装 \n\nnpm i webpack@next webpack-cli -D\n\n#### 关注点\n\n1. 通过持久缓存提高构建性能\n2. 使用更好的算法和默认值来改善长期缓存\n3. 通过更好的树摇和代码生成来改善捆绑包\n4. 清除处于怪异状态的内部结构，同时在v4中实现功能二不引入重大改变\n5. 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间使用v5\n\n#### 自动删除Node.js Polyfills\n\n在webpack5中，会自动停止Node的核心模块的提供，并专注于前端兼容的模块\n\n迁移\n\n1. 尽可能尝试使用与前端兼容的模块\n2. 可以为nodejs核心模块手动添加一个polyfill。错误信息会提示如何实现该目标\n\n#### Chunk 和 模块ID\n\n添加了用于长期缓存的新算法。在生产模式默认启动\n\n```js\nchunkId:'deterministic',moduleIds:'deterministic'\n```\n\n#### Chunk ID\n\n我们可以不用使用`import(/*webpackChunkName:'name'*/'module')`在开发环境来为chunk命名\n\nwebpack内部有chunk的命名规则，不再是以id(0,1,2)命名\n\n#### Tree Shaking\n\n1. webpack5能够处理嵌套模块的tree shaking\n\n```js\n// index.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from './inner';\nexport { inner }\n\n// user.js\nimport * as module from './module';\nconsole.log(module.inner.a);\n```\n\n在生产环境中，inner模块的b会被删除\n\n2. webpack5能够处理多个模块之前的关系\n\n```js\nimport { something } from './something';\n\nfunction usingSomething(){\n    return something;\n}\n\nexport function test(){\n    return usingSomething();\n}\n```\n\n当设置`'sideEffects':false`时，一旦发现`test`方法没有使用，不但会删除test，还会删除`./something` \n\n3. webpack5能够处理Commonjs的tree shaking\n\n#### output\n\nwebpack4 默认输出ES5代码\n\nwebpack5 开始新增一个属性output.ecmaVersion,可以生成ES5和ES6代码\n\n#### Caching\n\n```js\ncache:{\n    // 缓存类型\n    type:'filesystem',\n    buildDependencies:{\n        // 当配置修改时，缓存失效\n        config:[__filename]\n    }\n}\n```\n\n缓存将存储到node_modules/.cache/webpack\n\n#### 更多内容 https://github.com/webpack/changelog-v5","slug":"前端/Webpack/06 webpack5","published":1,"updated":"2023-05-12T23:28:10.995Z","layout":"post","link":"","_id":"clhws1t34002q2h177frm4ge6","content":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>npm i webpack@next webpack-cli -D</p>\n<h4 id=\"关注点\"><a href=\"#关注点\" class=\"headerlink\" title=\"关注点\"></a>关注点</h4><ol>\n<li>通过持久缓存提高构建性能</li>\n<li>使用更好的算法和默认值来改善长期缓存</li>\n<li>通过更好的树摇和代码生成来改善捆绑包</li>\n<li>清除处于怪异状态的内部结构，同时在v4中实现功能二不引入重大改变</li>\n<li>通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间使用v5</li>\n</ol>\n<h4 id=\"自动删除Node-js-Polyfills\"><a href=\"#自动删除Node-js-Polyfills\" class=\"headerlink\" title=\"自动删除Node.js Polyfills\"></a>自动删除Node.js Polyfills</h4><p>在webpack5中，会自动停止Node的核心模块的提供，并专注于前端兼容的模块</p>\n<p>迁移</p>\n<ol>\n<li>尽可能尝试使用与前端兼容的模块</li>\n<li>可以为nodejs核心模块手动添加一个polyfill。错误信息会提示如何实现该目标</li>\n</ol>\n<h4 id=\"Chunk-和-模块ID\"><a href=\"#Chunk-和-模块ID\" class=\"headerlink\" title=\"Chunk 和 模块ID\"></a>Chunk 和 模块ID</h4><p>添加了用于长期缓存的新算法。在生产模式默认启动</p>\n<pre><code class=\"js\">chunkId:&#39;deterministic&#39;,moduleIds:&#39;deterministic&#39;\n</code></pre>\n<h4 id=\"Chunk-ID\"><a href=\"#Chunk-ID\" class=\"headerlink\" title=\"Chunk ID\"></a>Chunk ID</h4><p>我们可以不用使用<code>import(/*webpackChunkName:&#39;name&#39;*/&#39;module&#39;)</code>在开发环境来为chunk命名</p>\n<p>webpack内部有chunk的命名规则，不再是以id(0,1,2)命名</p>\n<h4 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h4><ol>\n<li>webpack5能够处理嵌套模块的tree shaking</li>\n</ol>\n<pre><code class=\"js\">// index.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from &#39;./inner&#39;;\nexport &#123; inner &#125;\n\n// user.js\nimport * as module from &#39;./module&#39;;\nconsole.log(module.inner.a);\n</code></pre>\n<p>在生产环境中，inner模块的b会被删除</p>\n<ol start=\"2\">\n<li>webpack5能够处理多个模块之前的关系</li>\n</ol>\n<pre><code class=\"js\">import &#123; something &#125; from &#39;./something&#39;;\n\nfunction usingSomething()&#123;\n    return something;\n&#125;\n\nexport function test()&#123;\n    return usingSomething();\n&#125;\n</code></pre>\n<p>当设置<code>&#39;sideEffects&#39;:false</code>时，一旦发现<code>test</code>方法没有使用，不但会删除test，还会删除<code>./something</code> </p>\n<ol start=\"3\">\n<li>webpack5能够处理Commonjs的tree shaking</li>\n</ol>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>webpack4 默认输出ES5代码</p>\n<p>webpack5 开始新增一个属性output.ecmaVersion,可以生成ES5和ES6代码</p>\n<h4 id=\"Caching\"><a href=\"#Caching\" class=\"headerlink\" title=\"Caching\"></a>Caching</h4><pre><code class=\"js\">cache:&#123;\n    // 缓存类型\n    type:&#39;filesystem&#39;,\n    buildDependencies:&#123;\n        // 当配置修改时，缓存失效\n        config:[__filename]\n    &#125;\n&#125;\n</code></pre>\n<p>缓存将存储到node_modules&#x2F;.cache&#x2F;webpack</p>\n<h4 id=\"更多内容-https-github-com-webpack-changelog-v5\"><a href=\"#更多内容-https-github-com-webpack-changelog-v5\" class=\"headerlink\" title=\"更多内容 https://github.com/webpack/changelog-v5\"></a>更多内容 <a href=\"https://github.com/webpack/changelog-v5\">https://github.com/webpack/changelog-v5</a></h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>npm i webpack@next webpack-cli -D</p>\n<h4 id=\"关注点\"><a href=\"#关注点\" class=\"headerlink\" title=\"关注点\"></a>关注点</h4><ol>\n<li>通过持久缓存提高构建性能</li>\n<li>使用更好的算法和默认值来改善长期缓存</li>\n<li>通过更好的树摇和代码生成来改善捆绑包</li>\n<li>清除处于怪异状态的内部结构，同时在v4中实现功能二不引入重大改变</li>\n<li>通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间使用v5</li>\n</ol>\n<h4 id=\"自动删除Node-js-Polyfills\"><a href=\"#自动删除Node-js-Polyfills\" class=\"headerlink\" title=\"自动删除Node.js Polyfills\"></a>自动删除Node.js Polyfills</h4><p>在webpack5中，会自动停止Node的核心模块的提供，并专注于前端兼容的模块</p>\n<p>迁移</p>\n<ol>\n<li>尽可能尝试使用与前端兼容的模块</li>\n<li>可以为nodejs核心模块手动添加一个polyfill。错误信息会提示如何实现该目标</li>\n</ol>\n<h4 id=\"Chunk-和-模块ID\"><a href=\"#Chunk-和-模块ID\" class=\"headerlink\" title=\"Chunk 和 模块ID\"></a>Chunk 和 模块ID</h4><p>添加了用于长期缓存的新算法。在生产模式默认启动</p>\n<pre><code class=\"js\">chunkId:&#39;deterministic&#39;,moduleIds:&#39;deterministic&#39;\n</code></pre>\n<h4 id=\"Chunk-ID\"><a href=\"#Chunk-ID\" class=\"headerlink\" title=\"Chunk ID\"></a>Chunk ID</h4><p>我们可以不用使用<code>import(/*webpackChunkName:&#39;name&#39;*/&#39;module&#39;)</code>在开发环境来为chunk命名</p>\n<p>webpack内部有chunk的命名规则，不再是以id(0,1,2)命名</p>\n<h4 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h4><ol>\n<li>webpack5能够处理嵌套模块的tree shaking</li>\n</ol>\n<pre><code class=\"js\">// index.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from &#39;./inner&#39;;\nexport &#123; inner &#125;\n\n// user.js\nimport * as module from &#39;./module&#39;;\nconsole.log(module.inner.a);\n</code></pre>\n<p>在生产环境中，inner模块的b会被删除</p>\n<ol start=\"2\">\n<li>webpack5能够处理多个模块之前的关系</li>\n</ol>\n<pre><code class=\"js\">import &#123; something &#125; from &#39;./something&#39;;\n\nfunction usingSomething()&#123;\n    return something;\n&#125;\n\nexport function test()&#123;\n    return usingSomething();\n&#125;\n</code></pre>\n<p>当设置<code>&#39;sideEffects&#39;:false</code>时，一旦发现<code>test</code>方法没有使用，不但会删除test，还会删除<code>./something</code> </p>\n<ol start=\"3\">\n<li>webpack5能够处理Commonjs的tree shaking</li>\n</ol>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>webpack4 默认输出ES5代码</p>\n<p>webpack5 开始新增一个属性output.ecmaVersion,可以生成ES5和ES6代码</p>\n<h4 id=\"Caching\"><a href=\"#Caching\" class=\"headerlink\" title=\"Caching\"></a>Caching</h4><pre><code class=\"js\">cache:&#123;\n    // 缓存类型\n    type:&#39;filesystem&#39;,\n    buildDependencies:&#123;\n        // 当配置修改时，缓存失效\n        config:[__filename]\n    &#125;\n&#125;\n</code></pre>\n<p>缓存将存储到node_modules&#x2F;.cache&#x2F;webpack</p>\n<h4 id=\"更多内容-https-github-com-webpack-changelog-v5\"><a href=\"#更多内容-https-github-com-webpack-changelog-v5\" class=\"headerlink\" title=\"更多内容 https://github.com/webpack/changelog-v5\"></a>更多内容 <a href=\"https://github.com/webpack/changelog-v5\">https://github.com/webpack/changelog-v5</a></h4>"},{"title":"代理模式","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"设计模式","date":"2020-07-17T16:00:00.000Z","comments":0,"description":"代理模式","photos":["https://yanxuan.nosdn.127.net/1f38efb8ce69e6fbcf9d7ea7af1d35b3.jpg"],"_content":"\n## 简单认识\n\n代理模式是为一个对象提供一个替代品或占位符，以便于控制对它的访问\n\n代理模式的关键是，当我们不便直接去访问一个对象时，我们可以去访问该对象的代理对象，然后该对象的代理对象会将我们发出的请求反馈到对象本体上\n\n## 好处及适用场景\n\n我们可以通过代理模式，来控制外界对对象的访问，我们可以过滤到一些无必要的访问，亦或者将对对象的访问进行改进让对象的操作更加方便\n\n主要的好处如下\n1. 保护了对象，不让外部轻易修改该对象\n2. 控制不同权限对象对目标对象的访问\n\n## 代理类型\n\n#### 虚拟代理\n\n虚拟代理是指当发出请求操作方要做出一些开销很大的操作时，可以将该操作交给代理对象，当目标对象真正可以进行请求操作时再做操作\n\n#### 保护代理\n\n保护代理是指代理对象可以帮助目标对象过滤一些没有意义的操作，减少对目标对象的操作\n\n#### 缓存代理\n\n缓存代理是指在我们进行开销大的运算操作时，可以提供暂时的存储。当下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n## 代理模式的应用场景\n\n#### 图片预加载\n\n需求：当我们加载一张图片时，我们需要异步加载图片，只有当图片加载完成后才会显示图片，否则在这之前要用一张loading图片来进行占位\n\n思路：\n\n `代码实现`\n\n``` js\n\n```\n\n#### 合并HTTP请求\n\n需求：现有一个列表的文件，每一个文件对应一个checkbox, 当打勾时立马把相应文件上传到服务器，若勾取消掉则立马将对应文件在服务器删除\n\n思路：\n\n `代码实现`\n\n``` js\n\n```\n\n#### 计算乘积缓存\n\n需求：乘积缓存\n\n#### 惰性加载\n\n需求：资源懒加载\n","source":"_posts/前端/设计模式/代理模式.md","raw":"---\ntitle: 代理模式\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg\nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - 设计模式\nkeywords: 设计模式\ndate: 2020-07-18\ncomments: false\ndescription: 代理模式\nphotos: https://yanxuan.nosdn.127.net/1f38efb8ce69e6fbcf9d7ea7af1d35b3.jpg\n---\n\n## 简单认识\n\n代理模式是为一个对象提供一个替代品或占位符，以便于控制对它的访问\n\n代理模式的关键是，当我们不便直接去访问一个对象时，我们可以去访问该对象的代理对象，然后该对象的代理对象会将我们发出的请求反馈到对象本体上\n\n## 好处及适用场景\n\n我们可以通过代理模式，来控制外界对对象的访问，我们可以过滤到一些无必要的访问，亦或者将对对象的访问进行改进让对象的操作更加方便\n\n主要的好处如下\n1. 保护了对象，不让外部轻易修改该对象\n2. 控制不同权限对象对目标对象的访问\n\n## 代理类型\n\n#### 虚拟代理\n\n虚拟代理是指当发出请求操作方要做出一些开销很大的操作时，可以将该操作交给代理对象，当目标对象真正可以进行请求操作时再做操作\n\n#### 保护代理\n\n保护代理是指代理对象可以帮助目标对象过滤一些没有意义的操作，减少对目标对象的操作\n\n#### 缓存代理\n\n缓存代理是指在我们进行开销大的运算操作时，可以提供暂时的存储。当下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n## 代理模式的应用场景\n\n#### 图片预加载\n\n需求：当我们加载一张图片时，我们需要异步加载图片，只有当图片加载完成后才会显示图片，否则在这之前要用一张loading图片来进行占位\n\n思路：\n\n `代码实现`\n\n``` js\n\n```\n\n#### 合并HTTP请求\n\n需求：现有一个列表的文件，每一个文件对应一个checkbox, 当打勾时立马把相应文件上传到服务器，若勾取消掉则立马将对应文件在服务器删除\n\n思路：\n\n `代码实现`\n\n``` js\n\n```\n\n#### 计算乘积缓存\n\n需求：乘积缓存\n\n#### 惰性加载\n\n需求：资源懒加载\n","slug":"前端/设计模式/代理模式","published":1,"updated":"2023-05-12T23:28:10.997Z","layout":"post","link":"","_id":"clhws1t34002t2h17bt5gbpcg","content":"<h2 id=\"简单认识\"><a href=\"#简单认识\" class=\"headerlink\" title=\"简单认识\"></a>简单认识</h2><p>代理模式是为一个对象提供一个替代品或占位符，以便于控制对它的访问</p>\n<p>代理模式的关键是，当我们不便直接去访问一个对象时，我们可以去访问该对象的代理对象，然后该对象的代理对象会将我们发出的请求反馈到对象本体上</p>\n<h2 id=\"好处及适用场景\"><a href=\"#好处及适用场景\" class=\"headerlink\" title=\"好处及适用场景\"></a>好处及适用场景</h2><p>我们可以通过代理模式，来控制外界对对象的访问，我们可以过滤到一些无必要的访问，亦或者将对对象的访问进行改进让对象的操作更加方便</p>\n<p>主要的好处如下</p>\n<ol>\n<li>保护了对象，不让外部轻易修改该对象</li>\n<li>控制不同权限对象对目标对象的访问</li>\n</ol>\n<h2 id=\"代理类型\"><a href=\"#代理类型\" class=\"headerlink\" title=\"代理类型\"></a>代理类型</h2><h4 id=\"虚拟代理\"><a href=\"#虚拟代理\" class=\"headerlink\" title=\"虚拟代理\"></a>虚拟代理</h4><p>虚拟代理是指当发出请求操作方要做出一些开销很大的操作时，可以将该操作交给代理对象，当目标对象真正可以进行请求操作时再做操作</p>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>保护代理是指代理对象可以帮助目标对象过滤一些没有意义的操作，减少对目标对象的操作</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>缓存代理是指在我们进行开销大的运算操作时，可以提供暂时的存储。当下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>\n<h2 id=\"代理模式的应用场景\"><a href=\"#代理模式的应用场景\" class=\"headerlink\" title=\"代理模式的应用场景\"></a>代理模式的应用场景</h2><h4 id=\"图片预加载\"><a href=\"#图片预加载\" class=\"headerlink\" title=\"图片预加载\"></a>图片预加载</h4><p>需求：当我们加载一张图片时，我们需要异步加载图片，只有当图片加载完成后才会显示图片，否则在这之前要用一张loading图片来进行占位</p>\n<p>思路：</p>\n<p> <code>代码实现</code></p>\n<pre><code class=\"js\">\n</code></pre>\n<h4 id=\"合并HTTP请求\"><a href=\"#合并HTTP请求\" class=\"headerlink\" title=\"合并HTTP请求\"></a>合并HTTP请求</h4><p>需求：现有一个列表的文件，每一个文件对应一个checkbox, 当打勾时立马把相应文件上传到服务器，若勾取消掉则立马将对应文件在服务器删除</p>\n<p>思路：</p>\n<p> <code>代码实现</code></p>\n<pre><code class=\"js\">\n</code></pre>\n<h4 id=\"计算乘积缓存\"><a href=\"#计算乘积缓存\" class=\"headerlink\" title=\"计算乘积缓存\"></a>计算乘积缓存</h4><p>需求：乘积缓存</p>\n<h4 id=\"惰性加载\"><a href=\"#惰性加载\" class=\"headerlink\" title=\"惰性加载\"></a>惰性加载</h4><p>需求：资源懒加载</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单认识\"><a href=\"#简单认识\" class=\"headerlink\" title=\"简单认识\"></a>简单认识</h2><p>代理模式是为一个对象提供一个替代品或占位符，以便于控制对它的访问</p>\n<p>代理模式的关键是，当我们不便直接去访问一个对象时，我们可以去访问该对象的代理对象，然后该对象的代理对象会将我们发出的请求反馈到对象本体上</p>\n<h2 id=\"好处及适用场景\"><a href=\"#好处及适用场景\" class=\"headerlink\" title=\"好处及适用场景\"></a>好处及适用场景</h2><p>我们可以通过代理模式，来控制外界对对象的访问，我们可以过滤到一些无必要的访问，亦或者将对对象的访问进行改进让对象的操作更加方便</p>\n<p>主要的好处如下</p>\n<ol>\n<li>保护了对象，不让外部轻易修改该对象</li>\n<li>控制不同权限对象对目标对象的访问</li>\n</ol>\n<h2 id=\"代理类型\"><a href=\"#代理类型\" class=\"headerlink\" title=\"代理类型\"></a>代理类型</h2><h4 id=\"虚拟代理\"><a href=\"#虚拟代理\" class=\"headerlink\" title=\"虚拟代理\"></a>虚拟代理</h4><p>虚拟代理是指当发出请求操作方要做出一些开销很大的操作时，可以将该操作交给代理对象，当目标对象真正可以进行请求操作时再做操作</p>\n<h4 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h4><p>保护代理是指代理对象可以帮助目标对象过滤一些没有意义的操作，减少对目标对象的操作</p>\n<h4 id=\"缓存代理\"><a href=\"#缓存代理\" class=\"headerlink\" title=\"缓存代理\"></a>缓存代理</h4><p>缓存代理是指在我们进行开销大的运算操作时，可以提供暂时的存储。当下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>\n<h2 id=\"代理模式的应用场景\"><a href=\"#代理模式的应用场景\" class=\"headerlink\" title=\"代理模式的应用场景\"></a>代理模式的应用场景</h2><h4 id=\"图片预加载\"><a href=\"#图片预加载\" class=\"headerlink\" title=\"图片预加载\"></a>图片预加载</h4><p>需求：当我们加载一张图片时，我们需要异步加载图片，只有当图片加载完成后才会显示图片，否则在这之前要用一张loading图片来进行占位</p>\n<p>思路：</p>\n<p> <code>代码实现</code></p>\n<pre><code class=\"js\">\n</code></pre>\n<h4 id=\"合并HTTP请求\"><a href=\"#合并HTTP请求\" class=\"headerlink\" title=\"合并HTTP请求\"></a>合并HTTP请求</h4><p>需求：现有一个列表的文件，每一个文件对应一个checkbox, 当打勾时立马把相应文件上传到服务器，若勾取消掉则立马将对应文件在服务器删除</p>\n<p>思路：</p>\n<p> <code>代码实现</code></p>\n<pre><code class=\"js\">\n</code></pre>\n<h4 id=\"计算乘积缓存\"><a href=\"#计算乘积缓存\" class=\"headerlink\" title=\"计算乘积缓存\"></a>计算乘积缓存</h4><p>需求：乘积缓存</p>\n<h4 id=\"惰性加载\"><a href=\"#惰性加载\" class=\"headerlink\" title=\"惰性加载\"></a>惰性加载</h4><p>需求：资源懒加载</p>\n"},{"title":"单例模式","author":"Re_Star","avatar":"https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg","authorAbout":"一个十分骚气的宅男","authorDesc":"一个十分骚气的宅男","keywords":"设计模式","date":"2020-07-14T16:00:00.000Z","comments":0,"description":"单例模式","photos":["https://ae01.alicdn.com/kf/H3137199903e545088863b23a32bac75cd.jpg"],"_content":"\n## 基本认识\n\n单例模式的定义是：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点\n\n采用单例模式实现的类一般具有以下特点\n1. 透明化：透明化是指当用户在使用单例类的时候跟使用普通类是一样的，即对用户来说，单例类对用户是“透明”的\n2. 惰性化：只有当我们真正需要该单例类的时候才会实例化出该单例类的实例对象\n3. 唯一化：单例类的实例对象全局唯一只有一个\n\n## 好处及适用场景\n\n单例模式的好处是可以避免一个类创建实例对象过多\n\n例如，全局的弹出框一般就只有一个，也因此弹出框类只需要一个实例对象就可以了，创建多个弹出框实例对象只会造成没必要的浪费\n\n适合场景：登录框(类似于QQ)/浏览器的弹出框...\n\n## 实现方式\n\n首先，单例类是一种特殊的类，即该类的实例对象全局唯一只有一个\n\n实现单例类，我们必须要搞清楚哪些是变化的，哪些是不会变化的\n\n在这里，对于单例实例的管理是不会发生变化的\n\n如果已经创建该类对应实例，则返回该实例，否则就创建该类\n\n而对于如果创建单例类对对应的实例则是会变化的\n\n也因此，要实现单例模式，我们可以将对单例实例的管理和单例实例的创建进行分离\n\n但是，在我们实现单例模式的时候要考虑实现语言的特性，就比如JavaScript就没有类的概念，那生搬单例模式的类概念是不现实的\n\n其实，在JavaScript中实现单例模式的最好方式就是`闭包`\n\n\n在这里，就用单例模式来实现登录框\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>单例模式 登录框实现</title>\n</head>\n\n<body>\n    <button id=\"button\">show login layer</button>\n    <script>\n        // 管理单例实例函数\n        function getSingle(fn) {\n            var instance;\n            return function () {\n                return instance || (instance = fn.apply(this, arguments));\n            }\n        }\n\n        // 构造函数，创建登录框\n        var createLoginLayer = function(){\n            var div = document.createElement('div');\n            div.innerHTML = 'Login Layer';\n            div.style.display = 'none';\n            document.body.appendChild(div);\n            return div;\n        }\n\n        // 基于构造函数返回一个用于获取对于单例实例的函数方法\n        var createSingleLoginLayer = getSingle(createLoginLayer);\n\n        document.getElementById('button').onclick = function(){\n            // 执行函数方法，获取构造函数对应的唯一实例对象\n            var loginLayer = createSingleLoginLayer();\n            loginLayer.style.display = 'block';\n        }\n    </script>\n</body>\n\n</html>\n```","source":"_posts/前端/设计模式/单例模式.md","raw":"---\ntitle: 单例模式\nauthor: Re_Star\navatar: https://gitee.com/trueLoving/cdn/raw/master/img/avatar.jpg \nauthorAbout: 一个十分骚气的宅男\nauthorDesc: 一个十分骚气的宅男\ncategories: 前端\ntags:\n - 设计模式\nkeywords: 设计模式\ndate: 2020-07-15\ncomments: false\ndescription: 单例模式\nphotos: https://ae01.alicdn.com/kf/H3137199903e545088863b23a32bac75cd.jpg\n---\n\n## 基本认识\n\n单例模式的定义是：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点\n\n采用单例模式实现的类一般具有以下特点\n1. 透明化：透明化是指当用户在使用单例类的时候跟使用普通类是一样的，即对用户来说，单例类对用户是“透明”的\n2. 惰性化：只有当我们真正需要该单例类的时候才会实例化出该单例类的实例对象\n3. 唯一化：单例类的实例对象全局唯一只有一个\n\n## 好处及适用场景\n\n单例模式的好处是可以避免一个类创建实例对象过多\n\n例如，全局的弹出框一般就只有一个，也因此弹出框类只需要一个实例对象就可以了，创建多个弹出框实例对象只会造成没必要的浪费\n\n适合场景：登录框(类似于QQ)/浏览器的弹出框...\n\n## 实现方式\n\n首先，单例类是一种特殊的类，即该类的实例对象全局唯一只有一个\n\n实现单例类，我们必须要搞清楚哪些是变化的，哪些是不会变化的\n\n在这里，对于单例实例的管理是不会发生变化的\n\n如果已经创建该类对应实例，则返回该实例，否则就创建该类\n\n而对于如果创建单例类对对应的实例则是会变化的\n\n也因此，要实现单例模式，我们可以将对单例实例的管理和单例实例的创建进行分离\n\n但是，在我们实现单例模式的时候要考虑实现语言的特性，就比如JavaScript就没有类的概念，那生搬单例模式的类概念是不现实的\n\n其实，在JavaScript中实现单例模式的最好方式就是`闭包`\n\n\n在这里，就用单例模式来实现登录框\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>单例模式 登录框实现</title>\n</head>\n\n<body>\n    <button id=\"button\">show login layer</button>\n    <script>\n        // 管理单例实例函数\n        function getSingle(fn) {\n            var instance;\n            return function () {\n                return instance || (instance = fn.apply(this, arguments));\n            }\n        }\n\n        // 构造函数，创建登录框\n        var createLoginLayer = function(){\n            var div = document.createElement('div');\n            div.innerHTML = 'Login Layer';\n            div.style.display = 'none';\n            document.body.appendChild(div);\n            return div;\n        }\n\n        // 基于构造函数返回一个用于获取对于单例实例的函数方法\n        var createSingleLoginLayer = getSingle(createLoginLayer);\n\n        document.getElementById('button').onclick = function(){\n            // 执行函数方法，获取构造函数对应的唯一实例对象\n            var loginLayer = createSingleLoginLayer();\n            loginLayer.style.display = 'block';\n        }\n    </script>\n</body>\n\n</html>\n```","slug":"前端/设计模式/单例模式","published":1,"updated":"2023-05-12T23:28:10.997Z","layout":"post","link":"","_id":"clhws1t35002w2h17e0f00oxn","content":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点</p>\n<p>采用单例模式实现的类一般具有以下特点</p>\n<ol>\n<li>透明化：透明化是指当用户在使用单例类的时候跟使用普通类是一样的，即对用户来说，单例类对用户是“透明”的</li>\n<li>惰性化：只有当我们真正需要该单例类的时候才会实例化出该单例类的实例对象</li>\n<li>唯一化：单例类的实例对象全局唯一只有一个</li>\n</ol>\n<h2 id=\"好处及适用场景\"><a href=\"#好处及适用场景\" class=\"headerlink\" title=\"好处及适用场景\"></a>好处及适用场景</h2><p>单例模式的好处是可以避免一个类创建实例对象过多</p>\n<p>例如，全局的弹出框一般就只有一个，也因此弹出框类只需要一个实例对象就可以了，创建多个弹出框实例对象只会造成没必要的浪费</p>\n<p>适合场景：登录框(类似于QQ)&#x2F;浏览器的弹出框…</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>首先，单例类是一种特殊的类，即该类的实例对象全局唯一只有一个</p>\n<p>实现单例类，我们必须要搞清楚哪些是变化的，哪些是不会变化的</p>\n<p>在这里，对于单例实例的管理是不会发生变化的</p>\n<p>如果已经创建该类对应实例，则返回该实例，否则就创建该类</p>\n<p>而对于如果创建单例类对对应的实例则是会变化的</p>\n<p>也因此，要实现单例模式，我们可以将对单例实例的管理和单例实例的创建进行分离</p>\n<p>但是，在我们实现单例模式的时候要考虑实现语言的特性，就比如JavaScript就没有类的概念，那生搬单例模式的类概念是不现实的</p>\n<p>其实，在JavaScript中实现单例模式的最好方式就是<code>闭包</code></p>\n<p>在这里，就用单例模式来实现登录框</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;单例模式 登录框实现&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;button id=&quot;button&quot;&gt;show login layer&lt;/button&gt;\n    &lt;script&gt;\n        // 管理单例实例函数\n        function getSingle(fn) &#123;\n            var instance;\n            return function () &#123;\n                return instance || (instance = fn.apply(this, arguments));\n            &#125;\n        &#125;\n\n        // 构造函数，创建登录框\n        var createLoginLayer = function()&#123;\n            var div = document.createElement(&#39;div&#39;);\n            div.innerHTML = &#39;Login Layer&#39;;\n            div.style.display = &#39;none&#39;;\n            document.body.appendChild(div);\n            return div;\n        &#125;\n\n        // 基于构造函数返回一个用于获取对于单例实例的函数方法\n        var createSingleLoginLayer = getSingle(createLoginLayer);\n\n        document.getElementById(&#39;button&#39;).onclick = function()&#123;\n            // 执行函数方法，获取构造函数对应的唯一实例对象\n            var loginLayer = createSingleLoginLayer();\n            loginLayer.style.display = &#39;block&#39;;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本认识\"><a href=\"#基本认识\" class=\"headerlink\" title=\"基本认识\"></a>基本认识</h2><p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点</p>\n<p>采用单例模式实现的类一般具有以下特点</p>\n<ol>\n<li>透明化：透明化是指当用户在使用单例类的时候跟使用普通类是一样的，即对用户来说，单例类对用户是“透明”的</li>\n<li>惰性化：只有当我们真正需要该单例类的时候才会实例化出该单例类的实例对象</li>\n<li>唯一化：单例类的实例对象全局唯一只有一个</li>\n</ol>\n<h2 id=\"好处及适用场景\"><a href=\"#好处及适用场景\" class=\"headerlink\" title=\"好处及适用场景\"></a>好处及适用场景</h2><p>单例模式的好处是可以避免一个类创建实例对象过多</p>\n<p>例如，全局的弹出框一般就只有一个，也因此弹出框类只需要一个实例对象就可以了，创建多个弹出框实例对象只会造成没必要的浪费</p>\n<p>适合场景：登录框(类似于QQ)&#x2F;浏览器的弹出框…</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>首先，单例类是一种特殊的类，即该类的实例对象全局唯一只有一个</p>\n<p>实现单例类，我们必须要搞清楚哪些是变化的，哪些是不会变化的</p>\n<p>在这里，对于单例实例的管理是不会发生变化的</p>\n<p>如果已经创建该类对应实例，则返回该实例，否则就创建该类</p>\n<p>而对于如果创建单例类对对应的实例则是会变化的</p>\n<p>也因此，要实现单例模式，我们可以将对单例实例的管理和单例实例的创建进行分离</p>\n<p>但是，在我们实现单例模式的时候要考虑实现语言的特性，就比如JavaScript就没有类的概念，那生搬单例模式的类概念是不现实的</p>\n<p>其实，在JavaScript中实现单例模式的最好方式就是<code>闭包</code></p>\n<p>在这里，就用单例模式来实现登录框</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;单例模式 登录框实现&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;button id=&quot;button&quot;&gt;show login layer&lt;/button&gt;\n    &lt;script&gt;\n        // 管理单例实例函数\n        function getSingle(fn) &#123;\n            var instance;\n            return function () &#123;\n                return instance || (instance = fn.apply(this, arguments));\n            &#125;\n        &#125;\n\n        // 构造函数，创建登录框\n        var createLoginLayer = function()&#123;\n            var div = document.createElement(&#39;div&#39;);\n            div.innerHTML = &#39;Login Layer&#39;;\n            div.style.display = &#39;none&#39;;\n            document.body.appendChild(div);\n            return div;\n        &#125;\n\n        // 基于构造函数返回一个用于获取对于单例实例的函数方法\n        var createSingleLoginLayer = getSingle(createLoginLayer);\n\n        document.getElementById(&#39;button&#39;).onclick = function()&#123;\n            // 执行函数方法，获取构造函数对应的唯一实例对象\n            var loginLayer = createSingleLoginLayer();\n            loginLayer.style.display = &#39;block&#39;;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clhws1t2700012h178o413jz1","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2l000j2h17hkvb1vj1"},{"post_id":"clhws1t2j000g2h176mfz49vb","category_id":"clhws1t2i000c2h17gwika0pw","_id":"clhws1t2o000s2h17h9r3hiu3"},{"post_id":"clhws1t2b00032h1735o70imh","category_id":"clhws1t2i000c2h17gwika0pw","_id":"clhws1t2q000x2h17dpvh6a2d"},{"post_id":"clhws1t2f00072h178wv5714y","category_id":"clhws1t2i000c2h17gwika0pw","_id":"clhws1t2r00122h17at5l82be"},{"post_id":"clhws1t2o000r2h17d3pafu6n","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2s00162h170rzbecgd"},{"post_id":"clhws1t2p000w2h17e27g6zz8","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2t00192h17cdwodoj4"},{"post_id":"clhws1t2g00092h17djwh8bs3","category_id":"clhws1t2i000c2h17gwika0pw","_id":"clhws1t2t001d2h17ganfdb8r"},{"post_id":"clhws1t2q00102h178s6qe35p","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2u001f2h177io8dqjm"},{"post_id":"clhws1t2r00142h17h2589xsw","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2v001j2h17f4xye1ov"},{"post_id":"clhws1t2h000b2h178e3rd2a9","category_id":"clhws1t2i000c2h17gwika0pw","_id":"clhws1t2v001m2h170knv0ee7"},{"post_id":"clhws1t2s00172h172aujb0sk","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2w001p2h17640ahbli"},{"post_id":"clhws1t2t001b2h17fus4f84o","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2x001s2h17daeugziv"},{"post_id":"clhws1t2k000i2h1793uracyh","category_id":"clhws1t2s00182h172ct07ajt","_id":"clhws1t2x001v2h178cmjgpzt"},{"post_id":"clhws1t2u001e2h173y3zbalc","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2y001y2h176z145ce7"},{"post_id":"clhws1t2u001i2h1729w39p5r","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t2y00202h17b4drdosq"},{"post_id":"clhws1t2n000o2h17dt4z7bo7","category_id":"clhws1t2u001g2h172xghh3n3","_id":"clhws1t2z00242h173mfw7hf5"},{"post_id":"clhws1t2v001l2h17519jc4xc","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3000262h174o7qhpg8"},{"post_id":"clhws1t2w001o2h173zywcov3","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t30002a2h1708gict6r"},{"post_id":"clhws1t2w001r2h1728msfcnl","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t31002c2h17dsxyd96z"},{"post_id":"clhws1t2x001t2h17amnw4vhy","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t32002g2h175cki1am8"},{"post_id":"clhws1t2y001x2h17hezag1fo","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t32002i2h1710l76zog"},{"post_id":"clhws1t2y001z2h1798wthyew","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t33002m2h178i0r7qwc"},{"post_id":"clhws1t2z00222h17d6bed0ad","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t33002o2h177arb2gm8"},{"post_id":"clhws1t2z00252h171t4rhpqs","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t34002s2h179rp84ago"},{"post_id":"clhws1t3000282h171z4m9aym","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t35002u2h177lzx4wmg"},{"post_id":"clhws1t31002b2h17h4b1847j","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t35002y2h171hfa1qdo"},{"post_id":"clhws1t31002e2h1752556n05","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t35002z2h17b1elh6yv"},{"post_id":"clhws1t32002h2h17as2y9ezl","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3600312h1780kud3qh"},{"post_id":"clhws1t32002k2h17fhk684yq","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3600332h174v8iepih"},{"post_id":"clhws1t33002n2h17bezkfk8a","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3600352h17776r3icz"},{"post_id":"clhws1t34002q2h177frm4ge6","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3600372h17frcu6o18"},{"post_id":"clhws1t34002t2h17bt5gbpcg","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t3700392h176z4nesdm"},{"post_id":"clhws1t35002w2h17e0f00oxn","category_id":"clhws1t2d00042h17789m4pyc","_id":"clhws1t37003b2h178yf1alrb"}],"PostTag":[{"post_id":"clhws1t2700012h178o413jz1","tag_id":"clhws1t2e00052h178cy9ajrb","_id":"clhws1t2i000e2h17diqo8fqw"},{"post_id":"clhws1t2j000g2h176mfz49vb","tag_id":"clhws1t2i000d2h174p7s7inf","_id":"clhws1t2m000m2h177gg7a3w9"},{"post_id":"clhws1t2b00032h1735o70imh","tag_id":"clhws1t2i000d2h174p7s7inf","_id":"clhws1t2n000p2h1764f97jq3"},{"post_id":"clhws1t2f00072h178wv5714y","tag_id":"clhws1t2i000d2h174p7s7inf","_id":"clhws1t2q000y2h176a3x28z2"},{"post_id":"clhws1t2g00092h17djwh8bs3","tag_id":"clhws1t2i000d2h174p7s7inf","_id":"clhws1t2s00152h17e71z81r0"},{"post_id":"clhws1t2h000b2h178e3rd2a9","tag_id":"clhws1t2i000d2h174p7s7inf","_id":"clhws1t2t001c2h1708ddebzi"},{"post_id":"clhws1t2k000i2h1793uracyh","tag_id":"clhws1t2t001a2h170h34fwo6","_id":"clhws1t2v001k2h179axded43"},{"post_id":"clhws1t2n000o2h17dt4z7bo7","tag_id":"clhws1t2u001h2h17d6um4hgl","_id":"clhws1t2w001q2h174vcjdiw5"},{"post_id":"clhws1t2o000r2h17d3pafu6n","tag_id":"clhws1t2v001n2h178d15fncv","_id":"clhws1t2y001w2h178lzyafjh"},{"post_id":"clhws1t2p000w2h17e27g6zz8","tag_id":"clhws1t2x001u2h17g6lh26k4","_id":"clhws1t2z00232h17cxcq1inw"},{"post_id":"clhws1t2q00102h178s6qe35p","tag_id":"clhws1t2v001n2h178d15fncv","_id":"clhws1t3000292h17cl1nc48w"},{"post_id":"clhws1t2r00142h17h2589xsw","tag_id":"clhws1t2x001u2h17g6lh26k4","_id":"clhws1t32002f2h174hse5pl5"},{"post_id":"clhws1t2s00172h172aujb0sk","tag_id":"clhws1t2v001n2h178d15fncv","_id":"clhws1t33002l2h176qhycov5"},{"post_id":"clhws1t2t001b2h17fus4f84o","tag_id":"clhws1t2v001n2h178d15fncv","_id":"clhws1t34002r2h17730xd2l3"},{"post_id":"clhws1t2u001e2h173y3zbalc","tag_id":"clhws1t2v001n2h178d15fncv","_id":"clhws1t35002x2h179agah3gt"},{"post_id":"clhws1t2u001i2h1729w39p5r","tag_id":"clhws1t35002v2h176vo71pj9","_id":"clhws1t3600322h17eqsce2n8"},{"post_id":"clhws1t2v001l2h17519jc4xc","tag_id":"clhws1t35002v2h176vo71pj9","_id":"clhws1t3600362h178tc5c8x6"},{"post_id":"clhws1t2w001o2h173zywcov3","tag_id":"clhws1t35002v2h176vo71pj9","_id":"clhws1t37003a2h171ovm9ntt"},{"post_id":"clhws1t2w001r2h1728msfcnl","tag_id":"clhws1t35002v2h176vo71pj9","_id":"clhws1t37003d2h1784sihbgt"},{"post_id":"clhws1t2x001t2h17amnw4vhy","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t37003f2h171k5gcvpf"},{"post_id":"clhws1t2y001x2h17hezag1fo","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t37003h2h17grgb0fm2"},{"post_id":"clhws1t2y001z2h1798wthyew","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t38003j2h1795ebe4hq"},{"post_id":"clhws1t2z00222h17d6bed0ad","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t38003l2h17eugqbaiv"},{"post_id":"clhws1t2z00252h171t4rhpqs","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t38003n2h172lx918l4"},{"post_id":"clhws1t3000282h171z4m9aym","tag_id":"clhws1t37003c2h17givf62d0","_id":"clhws1t38003p2h171sstd51o"},{"post_id":"clhws1t31002b2h17h4b1847j","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t39003r2h17cy54c6d7"},{"post_id":"clhws1t31002e2h1752556n05","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t39003t2h174ix2eyyj"},{"post_id":"clhws1t32002h2h17as2y9ezl","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t39003v2h17edxvh9v2"},{"post_id":"clhws1t32002k2h17fhk684yq","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t39003x2h17ft3q7cij"},{"post_id":"clhws1t33002n2h17bezkfk8a","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t3a003z2h17ghua4g0w"},{"post_id":"clhws1t34002q2h177frm4ge6","tag_id":"clhws1t38003o2h170kbbcwlg","_id":"clhws1t3a00412h17a0h95maz"},{"post_id":"clhws1t34002t2h17bt5gbpcg","tag_id":"clhws1t3a00402h17hmfj8ysy","_id":"clhws1t3a00432h17fx1a3pyj"},{"post_id":"clhws1t35002w2h17e0f00oxn","tag_id":"clhws1t3a00402h17hmfj8ysy","_id":"clhws1t3a00442h17bcloamnu"}],"Tag":[{"name":"网络基础","_id":"clhws1t2e00052h178cy9ajrb"},{"name":"笔记","_id":"clhws1t2i000d2h174p7s7inf"},{"name":"数学","_id":"clhws1t2t001a2h170h34fwo6"},{"name":"算法","_id":"clhws1t2u001h2h17d6um4hgl"},{"name":"ES6","_id":"clhws1t2v001n2h178d15fncv"},{"name":"Promise","_id":"clhws1t2x001u2h17g6lh26k4"},{"name":"javascript","_id":"clhws1t35002v2h176vo71pj9"},{"name":"vue","_id":"clhws1t37003c2h17givf62d0"},{"name":"webpack","_id":"clhws1t38003o2h170kbbcwlg"},{"name":"设计模式","_id":"clhws1t3a00402h17hmfj8ysy"}]}}